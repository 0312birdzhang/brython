__BRYTHON__.libs = __BRYTHON__.libs || {};
__BRYTHON__.=libs['unittest']={"unittest.test.test_setups": ["import io\nimport sys\nimport unittest\ndef resultFactory(*_):\n return unittest.TestResult()\nclass TestSetups(unittest.TestCase):\n def getRunner(self):\n  return unittest.TextTestRunner(resultclass=resultFactory,\n  stream=io.StringIO())\n def runTests(self,*cases):\n  suite=unittest.TestSuite()\n  for case in cases:\n   tests=unittest.defaultTestLoader.loadTestsFromTestCase(case)\n   suite.addTests(tests)\n  runner=self.getRunner()\n  realSuite=unittest.TestSuite()\n  realSuite.addTest(suite)\n  suite.addTest(unittest.TestSuite())\n  realSuite.addTest(unittest.TestSuite())\n  return runner.run(realSuite)\n def test_setup_class(self):\n  class Test(unittest.TestCase):\n   setUpCalled=0\n   @classmethod\n   def setUpClass(cls):\n    Test.setUpCalled+=1\n    unittest.TestCase.setUpClass()\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n  result=self.runTests(Test)\n  self.assertEqual(Test.setUpCalled,1)\n  self.assertEqual(result.testsRun,2)\n  self.assertEqual(len(result.errors),0)\n def test_teardown_class(self):\n  class Test(unittest.TestCase):\n   tearDownCalled=0\n   @classmethod\n   def tearDownClass(cls):\n    Test.tearDownCalled+=1\n    unittest.TestCase.tearDownClass()\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n  result=self.runTests(Test)\n  self.assertEqual(Test.tearDownCalled,1)\n  self.assertEqual(result.testsRun,2)\n  self.assertEqual(len(result.errors),0)\n def test_teardown_class_two_classes(self):\n  class Test(unittest.TestCase):\n   tearDownCalled=0\n   @classmethod\n   def tearDownClass(cls):\n    Test.tearDownCalled+=1\n    unittest.TestCase.tearDownClass()\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n  class Test2(unittest.TestCase):\n   tearDownCalled=0\n   @classmethod\n   def tearDownClass(cls):\n    Test2.tearDownCalled+=1\n    unittest.TestCase.tearDownClass()\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n  result=self.runTests(Test,Test2)\n  self.assertEqual(Test.tearDownCalled,1)\n  self.assertEqual(Test2.tearDownCalled,1)\n  self.assertEqual(result.testsRun,4)\n  self.assertEqual(len(result.errors),0)\n def test_error_in_setupclass(self):\n  class BrokenTest(unittest.TestCase):\n   @classmethod\n   def setUpClass(cls):\n    raise TypeError('foo')\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n  result=self.runTests(BrokenTest)\n  self.assertEqual(result.testsRun,0)\n  self.assertEqual(len(result.errors),1)\n  error,_=result.errors[0]\n  self.assertEqual(str(error),\n  'setUpClass (%s.BrokenTest)'%__name__)\n def test_error_in_teardown_class(self):\n  class Test(unittest.TestCase):\n   tornDown=0\n   @classmethod\n   def tearDownClass(cls):\n    Test.tornDown+=1\n    raise TypeError('foo')\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n  class Test2(unittest.TestCase):\n   tornDown=0\n   @classmethod\n   def tearDownClass(cls):\n    Test2.tornDown+=1\n    raise TypeError('foo')\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n  result=self.runTests(Test,Test2)\n  self.assertEqual(result.testsRun,4)\n  self.assertEqual(len(result.errors),2)\n  self.assertEqual(Test.tornDown,1)\n  self.assertEqual(Test2.tornDown,1)\n  error,_=result.errors[0]\n  self.assertEqual(str(error),\n  'tearDownClass (%s.Test)'%__name__)\n def test_class_not_torndown_when_setup_fails(self):\n  class Test(unittest.TestCase):\n   tornDown=False\n   @classmethod\n   def setUpClass(cls):\n    raise TypeError\n   @classmethod\n   def tearDownClass(cls):\n    Test.tornDown=True\n    raise TypeError('foo')\n   def test_one(self):\n    pass\n  self.runTests(Test)\n  self.assertFalse(Test.tornDown)\n def test_class_not_setup_or_torndown_when_skipped(self):\n  class Test(unittest.TestCase):\n   classSetUp=False\n   tornDown=False\n   @classmethod\n   def setUpClass(cls):\n    Test.classSetUp=True\n   @classmethod\n   def tearDownClass(cls):\n    Test.tornDown=True\n   def test_one(self):\n    pass\n  Test=unittest.skip(\"hop\")(Test)\n  self.runTests(Test)\n  self.assertFalse(Test.classSetUp)\n  self.assertFalse(Test.tornDown)\n def test_setup_teardown_order_with_pathological_suite(self):\n  results=[]\n  class Module1(object):\n   @staticmethod\n   def setUpModule():\n    results.append('Module1.setUpModule')\n   @staticmethod\n   def tearDownModule():\n    results.append('Module1.tearDownModule')\n  class Module2(object):\n   @staticmethod\n   def setUpModule():\n    results.append('Module2.setUpModule')\n   @staticmethod\n   def tearDownModule():\n    results.append('Module2.tearDownModule')\n  class Test1(unittest.TestCase):\n   @classmethod\n   def setUpClass(cls):\n    results.append('setup 1')\n   @classmethod\n   def tearDownClass(cls):\n    results.append('teardown 1')\n   def testOne(self):\n    results.append('Test1.testOne')\n   def testTwo(self):\n    results.append('Test1.testTwo')\n  class Test2(unittest.TestCase):\n   @classmethod\n   def setUpClass(cls):\n    results.append('setup 2')\n   @classmethod\n   def tearDownClass(cls):\n    results.append('teardown 2')\n   def testOne(self):\n    results.append('Test2.testOne')\n   def testTwo(self):\n    results.append('Test2.testTwo')\n  class Test3(unittest.TestCase):\n   @classmethod\n   def setUpClass(cls):\n    results.append('setup 3')\n   @classmethod\n   def tearDownClass(cls):\n    results.append('teardown 3')\n   def testOne(self):\n    results.append('Test3.testOne')\n   def testTwo(self):\n    results.append('Test3.testTwo')\n  Test1.__module__=Test2.__module__='Module'\n  Test3.__module__='Module2'\n  sys.modules['Module']=Module1\n  sys.modules['Module2']=Module2\n  first=unittest.TestSuite((Test1('testOne'),))\n  second=unittest.TestSuite((Test1('testTwo'),))\n  third=unittest.TestSuite((Test2('testOne'),))\n  fourth=unittest.TestSuite((Test2('testTwo'),))\n  fifth=unittest.TestSuite((Test3('testOne'),))\n  sixth=unittest.TestSuite((Test3('testTwo'),))\n  suite=unittest.TestSuite((first,second,third,fourth,fifth,sixth))\n  runner=self.getRunner()\n  result=runner.run(suite)\n  self.assertEqual(result.testsRun,6)\n  self.assertEqual(len(result.errors),0)\n  self.assertEqual(results,\n  ['Module1.setUpModule','setup 1',\n  'Test1.testOne','Test1.testTwo','teardown 1',\n  'setup 2','Test2.testOne','Test2.testTwo',\n  'teardown 2','Module1.tearDownModule',\n  'Module2.setUpModule','setup 3',\n  'Test3.testOne','Test3.testTwo',\n  'teardown 3','Module2.tearDownModule'])\n def test_setup_module(self):\n  class Module(object):\n   moduleSetup=0\n   @staticmethod\n   def setUpModule():\n    Module.moduleSetup+=1\n  class Test(unittest.TestCase):\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n  Test.__module__='Module'\n  sys.modules['Module']=Module\n  result=self.runTests(Test)\n  self.assertEqual(Module.moduleSetup,1)\n  self.assertEqual(result.testsRun,2)\n  self.assertEqual(len(result.errors),0)\n def test_error_in_setup_module(self):\n  class Module(object):\n   moduleSetup=0\n   moduleTornDown=0\n   @staticmethod\n   def setUpModule():\n    Module.moduleSetup+=1\n    raise TypeError('foo')\n   @staticmethod\n   def tearDownModule():\n    Module.moduleTornDown+=1\n  class Test(unittest.TestCase):\n   classSetUp=False\n   classTornDown=False\n   @classmethod\n   def setUpClass(cls):\n    Test.classSetUp=True\n   @classmethod\n   def tearDownClass(cls):\n    Test.classTornDown=True\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n  class Test2(unittest.TestCase):\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n  Test.__module__='Module'\n  Test2.__module__='Module'\n  sys.modules['Module']=Module\n  result=self.runTests(Test,Test2)\n  self.assertEqual(Module.moduleSetup,1)\n  self.assertEqual(Module.moduleTornDown,0)\n  self.assertEqual(result.testsRun,0)\n  self.assertFalse(Test.classSetUp)\n  self.assertFalse(Test.classTornDown)\n  self.assertEqual(len(result.errors),1)\n  error,_=result.errors[0]\n  self.assertEqual(str(error),'setUpModule (Module)')\n def test_testcase_with_missing_module(self):\n  class Test(unittest.TestCase):\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n  Test.__module__='Module'\n  sys.modules.pop('Module',None)\n  result=self.runTests(Test)\n  self.assertEqual(result.testsRun,2)\n def test_teardown_module(self):\n  class Module(object):\n   moduleTornDown=0\n   @staticmethod\n   def tearDownModule():\n    Module.moduleTornDown+=1\n  class Test(unittest.TestCase):\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n  Test.__module__='Module'\n  sys.modules['Module']=Module\n  result=self.runTests(Test)\n  self.assertEqual(Module.moduleTornDown,1)\n  self.assertEqual(result.testsRun,2)\n  self.assertEqual(len(result.errors),0)\n def test_error_in_teardown_module(self):\n  class Module(object):\n   moduleTornDown=0\n   @staticmethod\n   def tearDownModule():\n    Module.moduleTornDown+=1\n    raise TypeError('foo')\n  class Test(unittest.TestCase):\n   classSetUp=False\n   classTornDown=False\n   @classmethod\n   def setUpClass(cls):\n    Test.classSetUp=True\n   @classmethod\n   def tearDownClass(cls):\n    Test.classTornDown=True\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n  class Test2(unittest.TestCase):\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n  Test.__module__='Module'\n  Test2.__module__='Module'\n  sys.modules['Module']=Module\n  result=self.runTests(Test,Test2)\n  self.assertEqual(Module.moduleTornDown,1)\n  self.assertEqual(result.testsRun,4)\n  self.assertTrue(Test.classSetUp)\n  self.assertTrue(Test.classTornDown)\n  self.assertEqual(len(result.errors),1)\n  error,_=result.errors[0]\n  self.assertEqual(str(error),'tearDownModule (Module)')\n def test_skiptest_in_setupclass(self):\n  class Test(unittest.TestCase):\n   @classmethod\n   def setUpClass(cls):\n    raise unittest.SkipTest('foo')\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n  result=self.runTests(Test)\n  self.assertEqual(result.testsRun,0)\n  self.assertEqual(len(result.errors),0)\n  self.assertEqual(len(result.skipped),1)\n  skipped=result.skipped[0][0]\n  self.assertEqual(str(skipped),'setUpClass (%s.Test)'%__name__)\n def test_skiptest_in_setupmodule(self):\n  class Test(unittest.TestCase):\n   def test_one(self):\n    pass\n   def test_two(self):\n    pass\n  class Module(object):\n   @staticmethod\n   def setUpModule():\n    raise unittest.SkipTest('foo')\n  Test.__module__='Module'\n  sys.modules['Module']=Module\n  result=self.runTests(Test)\n  self.assertEqual(result.testsRun,0)\n  self.assertEqual(len(result.errors),0)\n  self.assertEqual(len(result.skipped),1)\n  skipped=result.skipped[0][0]\n  self.assertEqual(str(skipped),'setUpModule (Module)')\n def test_suite_debug_executes_setups_and_teardowns(self):\n  ordering=[]\n  class Module(object):\n   @staticmethod\n   def setUpModule():\n    ordering.append('setUpModule')\n   @staticmethod\n   def tearDownModule():\n    ordering.append('tearDownModule')\n  class Test(unittest.TestCase):\n   @classmethod\n   def setUpClass(cls):\n    ordering.append('setUpClass')\n   @classmethod\n   def tearDownClass(cls):\n    ordering.append('tearDownClass')\n   def test_something(self):\n    ordering.append('test_something')\n  Test.__module__='Module'\n  sys.modules['Module']=Module\n  suite=unittest.defaultTestLoader.loadTestsFromTestCase(Test)\n  suite.debug()\n  expectedOrder=['setUpModule','setUpClass','test_something','tearDownClass','tearDownModule']\n  self.assertEqual(ordering,expectedOrder)\n def test_suite_debug_propagates_exceptions(self):\n  class Module(object):\n   @staticmethod\n   def setUpModule():\n    if phase==0:\n     raise Exception('setUpModule')\n   @staticmethod\n   def tearDownModule():\n    if phase==1:\n     raise Exception('tearDownModule')\n  class Test(unittest.TestCase):\n   @classmethod\n   def setUpClass(cls):\n    if phase==2:\n     raise Exception('setUpClass')\n   @classmethod\n   def tearDownClass(cls):\n    if phase==3:\n     raise Exception('tearDownClass')\n   def test_something(self):\n    if phase==4:\n     raise Exception('test_something')\n  Test.__module__='Module'\n  sys.modules['Module']=Module\n  _suite=unittest.defaultTestLoader.loadTestsFromTestCase(Test)\n  suite=unittest.TestSuite()\n  suite.addTest(_suite)\n  messages=('setUpModule','tearDownModule','setUpClass','tearDownClass','test_something')\n  for phase,msg in enumerate(messages):\n   with self.assertRaisesRegex(Exception,msg):\n    suite.debug()\nif __name__=='__main__':\n unittest.main()\n"], "unittest.case": ["\nimport sys\nimport functools\nimport difflib\nimport pprint\nimport re\nimport warnings\nimport collections\nfrom.import result\nfrom.util import(strclass,safe_repr,_count_diff_all_purpose,\n_count_diff_hashable)\n__unittest=True\nDIFF_OMITTED=('\\nDiff is %s characters long. '\n'Set self.maxDiff to None to see it.')\nclass SkipTest(Exception):\n '' \nclass _ExpectedFailure(Exception):\n '' \n def __init__(self,exc_info):\n  super(_ExpectedFailure,self).__init__()\n  self.exc_info=exc_info\nclass _UnexpectedSuccess(Exception):\n '' \nclass _Outcome(object):\n def __init__(self):\n  self.success=True\n  self.skipped=None\n  self.unexpectedSuccess=None\n  self.expectedFailure=None\n  self.errors=[]\n  self.failures=[]\ndef _id(obj):\n return obj\ndef skip(reason):\n '' \n def decorator(test_item):\n  if not isinstance(test_item,type):\n   @functools.wraps(test_item)\n   def skip_wrapper(*args,**kwargs):\n    raise SkipTest(reason)\n   test_item=skip_wrapper\n  test_item.__unittest_skip__=True\n  test_item.__unittest_skip_why__=reason\n  return test_item\n return decorator\ndef skipIf(condition,reason):\n '' \n if condition:\n  return skip(reason)\n return _id\ndef skipUnless(condition,reason):\n '' \n if not condition:\n  return skip(reason)\n return _id\ndef expectedFailure(func):\n @functools.wraps(func)\n def wrapper(*args,**kwargs):\n  try:\n   func(*args,**kwargs)\n  except Exception:\n   raise _ExpectedFailure(sys.exc_info())\n  raise _UnexpectedSuccess\n return wrapper\nclass _AssertRaisesBaseContext(object):\n def __init__(self,expected,test_case,callable_obj=None,\n expected_regex=None):\n  self.expected=expected\n  self.test_case=test_case\n  if callable_obj is not None:\n   try:\n    self.obj_name=callable_obj.__name__\n   except AttributeError:\n    self.obj_name=str(callable_obj)\n  else:\n   self.obj_name=None\n  if isinstance(expected_regex,(bytes,str)):\n   expected_regex=re.compile(expected_regex)\n  self.expected_regex=expected_regex\n  self.msg=None\n def _raiseFailure(self,standardMsg):\n  msg=self.test_case._formatMessage(self.msg,standardMsg)\n  raise self.test_case.failureException(msg)\n def handle(self,name,callable_obj,args,kwargs):\n  ''  \n  if callable_obj is None:\n   self.msg=kwargs.pop('msg',None)\n   return self\n  with self:\n   callable_obj(*args,**kwargs)\nclass _AssertRaisesContext(_AssertRaisesBaseContext):\n def __enter__(self):\n  return self\n def __exit__(self,exc_type,exc_value,tb):\n  if exc_type is None:\n   try:\n    exc_name=self.expected.__name__\n   except AttributeError:\n    exc_name=str(self.expected)\n   if self.obj_name:\n    self._raiseFailure(\"{} not raised by {}\".format(exc_name,\n    self.obj_name))\n   else:\n    self._raiseFailure(\"{} not raised\".format(exc_name))\n  if not issubclass(exc_type,self.expected):\n   return False\n  self.exception=exc_value.with_traceback(None)\n  if self.expected_regex is None:\n   return True\n  expected_regex=self.expected_regex\n  if not expected_regex.search(str(exc_value)):\n   self._raiseFailure('\"{}\" does not match \"{}\"'.format(\n   expected_regex.pattern,str(exc_value)))\n  return True\nclass _AssertWarnsContext(_AssertRaisesBaseContext):\n def __enter__(self):\n  for v in sys.modules.values():\n   if getattr(v,'__warningregistry__',None):\n    v.__warningregistry__={}\n  self.warnings_manager=warnings.catch_warnings(record=True)\n  self.warnings=self.warnings_manager.__enter__()\n  warnings.simplefilter(\"always\",self.expected)\n  return self\n def __exit__(self,exc_type,exc_value,tb):\n  self.warnings_manager.__exit__(exc_type,exc_value,tb)\n  if exc_type is not None:\n   return\n  try:\n   exc_name=self.expected.__name__\n  except AttributeError:\n   exc_name=str(self.expected)\n  first_matching=None\n  for m in self.warnings:\n   w=m.message\n   if not isinstance(w,self.expected):\n    continue\n   if first_matching is None:\n    first_matching=w\n   if(self.expected_regex is not None and\n   not self.expected_regex.search(str(w))):\n    continue\n   self.warning=w\n   self.filename=m.filename\n   self.lineno=m.lineno\n   return\n  if first_matching is not None:\n   self._raiseFailure('\"{}\" does not match \"{}\"'.format(\n   self.expected_regex.pattern,str(first_matching)))\n  if self.obj_name:\n   self._raiseFailure(\"{} not triggered by {}\".format(exc_name,\n   self.obj_name))\n  else:\n   self._raiseFailure(\"{} not triggered\".format(exc_name))\nclass TestCase(object):\n '' \n failureException=AssertionError\n longMessage=True\n maxDiff=80*8\n _diffThreshold=2**16\n _classSetupFailed=False\n def __init__(self,methodName='runTest'):\n  ''  \n  self._testMethodName=methodName\n  self._outcomeForDoCleanups=None\n  self._testMethodDoc='No test'\n  try:\n   testMethod=getattr(self,methodName)\n  except AttributeError:\n   if methodName!='runTest':\n    raise ValueError(\"no such test method in %s: %s\"%\n    (self.__class__,methodName))\n  else:\n   self._testMethodDoc=testMethod.__doc__\n  self._cleanups=[]\n  self._type_equality_funcs={}\n  self.addTypeEqualityFunc(dict,'assertDictEqual')\n  self.addTypeEqualityFunc(list,'assertListEqual')\n  self.addTypeEqualityFunc(tuple,'assertTupleEqual')\n  self.addTypeEqualityFunc(set,'assertSetEqual')\n  self.addTypeEqualityFunc(frozenset,'assertSetEqual')\n  self.addTypeEqualityFunc(str,'assertMultiLineEqual')\n def addTypeEqualityFunc(self,typeobj,function):\n  ''  \n  self._type_equality_funcs[typeobj]=function\n def addCleanup(self,function,*args,**kwargs):\n  ''  \n  self._cleanups.append((function,args,kwargs))\n def setUp(self):\n  pass\n def tearDown(self):\n  pass\n @classmethod\n def setUpClass(cls):\n  ''\n @classmethod\n def tearDownClass(cls):\n  ''\n def countTestCases(self):\n  return 1\n def defaultTestResult(self):\n  return result.TestResult()\n def shortDescription(self):\n  ''  \n  doc=self._testMethodDoc\n  return doc and doc.split(\"\\n\")[0].strip()or None\n def id(self):\n  return\"%s.%s\"%(strclass(self.__class__),self._testMethodName)\n def __eq__(self,other):\n  if type(self)is not type(other):\n   return NotImplemented\n  return self._testMethodName==other._testMethodName\n def __hash__(self):\n  return hash((type(self),self._testMethodName))\n def __str__(self):\n  return\"%s (%s)\"%(self._testMethodName,strclass(self.__class__))\n def __repr__(self):\n  return\"<%s testMethod=%s>\"%  (strclass(self.__class__),self._testMethodName)\n def _addSkip(self,result,reason):\n  addSkip=getattr(result,'addSkip',None)\n  if addSkip is not None:\n   addSkip(self,reason)\n  else:\n   warnings.warn(\"TestResult has no addSkip method, skips not reported\",\n   RuntimeWarning,2)\n   result.addSuccess(self)\n def _executeTestPart(self,function,outcome,isTest=False):\n  try:\n   function()\n  except KeyboardInterrupt:\n   raise\n  except SkipTest as e:\n   outcome.success=False\n   outcome.skipped=str(e)\n  except _UnexpectedSuccess:\n   exc_info=sys.exc_info()\n   outcome.success=False\n   if isTest:\n    outcome.unexpectedSuccess=exc_info\n   else:\n    outcome.errors.append(exc_info)\n  except _ExpectedFailure:\n   outcome.success=False\n   exc_info=sys.exc_info()\n   if isTest:\n    outcome.expectedFailure=exc_info\n   else:\n    outcome.errors.append(exc_info)\n  except self.failureException:\n   outcome.success=False\n   outcome.failures.append(sys.exc_info())\n   exc_info=sys.exc_info()\n  except:\n   outcome.success=False\n   outcome.errors.append(sys.exc_info())\n def run(self,result=None):\n  orig_result=result\n  if result is None:\n   result=self.defaultTestResult()\n   startTestRun=getattr(result,'startTestRun',None)\n   if startTestRun is not None:\n    startTestRun()\n  result.startTest(self)\n  testMethod=getattr(self,self._testMethodName)\n  if(getattr(self.__class__,\"__unittest_skip__\",False)or\n  getattr(testMethod,\"__unittest_skip__\",False)):\n   try:\n    skip_why=(getattr(self.__class__,'__unittest_skip_why__','')\n    or getattr(testMethod,'__unittest_skip_why__',''))\n    self._addSkip(result,skip_why)\n   finally:\n    result.stopTest(self)\n   return\n  try:\n   outcome=_Outcome()\n   self._outcomeForDoCleanups=outcome\n   self._executeTestPart(self.setUp,outcome)\n   if outcome.success:\n    self._executeTestPart(testMethod,outcome,isTest=True)\n    self._executeTestPart(self.tearDown,outcome)\n   self.doCleanups()\n   if outcome.success:\n    result.addSuccess(self)\n   else:\n    if outcome.skipped is not None:\n     self._addSkip(result,outcome.skipped)\n    for exc_info in outcome.errors:\n     result.addError(self,exc_info)\n    for exc_info in outcome.failures:\n     result.addFailure(self,exc_info)\n    if outcome.unexpectedSuccess is not None:\n     addUnexpectedSuccess=getattr(result,'addUnexpectedSuccess',None)\n     if addUnexpectedSuccess is not None:\n      addUnexpectedSuccess(self)\n     else:\n      warnings.warn(\"TestResult has no addUnexpectedSuccess method, reporting as failures\",\n      RuntimeWarning)\n      result.addFailure(self,outcome.unexpectedSuccess)\n    if outcome.expectedFailure is not None:\n     addExpectedFailure=getattr(result,'addExpectedFailure',None)\n     if addExpectedFailure is not None:\n      addExpectedFailure(self,outcome.expectedFailure)\n     else:\n      warnings.warn(\"TestResult has no addExpectedFailure method, reporting as passes\",\n      RuntimeWarning)\n      result.addSuccess(self)\n   return result\n  finally:\n   result.stopTest(self)\n   if orig_result is None:\n    stopTestRun=getattr(result,'stopTestRun',None)\n    if stopTestRun is not None:\n     stopTestRun()\n def doCleanups(self):\n  ''  \n  outcome=self._outcomeForDoCleanups or _Outcome()\n  while self._cleanups:\n   function,args,kwargs=self._cleanups.pop()\n   part=lambda:function(*args,**kwargs)\n   self._executeTestPart(part,outcome)\n  return outcome.success\n def __call__(self,*args,**kwds):\n  return self.run(*args,**kwds)\n def debug(self):\n  self.setUp()\n  getattr(self,self._testMethodName)()\n  self.tearDown()\n  while self._cleanups:\n   function,args,kwargs=self._cleanups.pop(-1)\n   function(*args,**kwargs)\n def skipTest(self,reason):\n  raise SkipTest(reason)\n def fail(self,msg=None):\n  raise self.failureException(msg)\n def assertFalse(self,expr,msg=None):\n  if expr:\n   msg=self._formatMessage(msg,\"%s is not false\"%safe_repr(expr))\n   raise self.failureException(msg)\n def assertTrue(self,expr,msg=None):\n  if not expr:\n   msg=self._formatMessage(msg,\"%s is not true\"%safe_repr(expr))\n   raise self.failureException(msg)\n def _formatMessage(self,msg,standardMsg):\n  ''  \n  if not self.longMessage:\n   return msg or standardMsg\n  if msg is None:\n   return standardMsg\n  try:\n   return'%s : %s'%(standardMsg,msg)\n  except UnicodeDecodeError:\n   return'%s : %s'%(safe_repr(standardMsg),safe_repr(msg))\n def assertRaises(self,excClass,callableObj=None,*args,**kwargs):\n  ''  \n  context=_AssertRaisesContext(excClass,self,callableObj)\n  return context.handle('assertRaises',callableObj,args,kwargs)\n def assertWarns(self,expected_warning,callable_obj=None,*args,**kwargs):\n  ''  \n  context=_AssertWarnsContext(expected_warning,self,callable_obj)\n  return context.handle('assertWarns',callable_obj,args,kwargs)\n def _getAssertEqualityFunc(self,first,second):\n  ''  \n  if type(first)is type(second):\n   asserter=self._type_equality_funcs.get(type(first))\n   if asserter is not None:\n    if isinstance(asserter,str):\n     asserter=getattr(self,asserter)\n    return asserter\n  return self._baseAssertEqual\n def _baseAssertEqual(self,first,second,msg=None):\n  if not first==second:\n   standardMsg='%s != %s'%(safe_repr(first),safe_repr(second))\n   msg=self._formatMessage(msg,standardMsg)\n   raise self.failureException(msg)\n def assertEqual(self,first,second,msg=None):\n  ''  \n  assertion_func=self._getAssertEqualityFunc(first,second)\n  assertion_func(first,second,msg=msg)\n def assertNotEqual(self,first,second,msg=None):\n  ''  \n  if not first!=second:\n   msg=self._formatMessage(msg,'%s == %s'%(safe_repr(first),\n   safe_repr(second)))\n   raise self.failureException(msg)\n def assertAlmostEqual(self,first,second,places=None,msg=None,\n delta=None):\n  ''  \n  if first==second:\n   return\n  if delta is not None and places is not None:\n   raise TypeError(\"specify delta or places not both\")\n  if delta is not None:\n   if abs(first-second)<=delta:\n    return\n   standardMsg='%s != %s within %s delta'%(safe_repr(first),\n   safe_repr(second),\n   safe_repr(delta))\n  else:\n   if places is None:\n    places=7\n   if round(abs(second-first),places)==0:\n    return\n   standardMsg='%s != %s within %r places'%(safe_repr(first),\n   safe_repr(second),\n   places)\n  msg=self._formatMessage(msg,standardMsg)\n  raise self.failureException(msg)\n def assertNotAlmostEqual(self,first,second,places=None,msg=None,\n delta=None):\n  ''  \n  if delta is not None and places is not None:\n   raise TypeError(\"specify delta or places not both\")\n  if delta is not None:\n   if not(first==second)and abs(first-second)>delta:\n    return\n   standardMsg='%s == %s within %s delta'%(safe_repr(first),\n   safe_repr(second),\n   safe_repr(delta))\n  else:\n   if places is None:\n    places=7\n   if not(first==second)and round(abs(second-first),places)!=0:\n    return\n   standardMsg='%s == %s within %r places'%(safe_repr(first),\n   safe_repr(second),\n   places)\n  msg=self._formatMessage(msg,standardMsg)\n  raise self.failureException(msg)\n def assertSequenceEqual(self,seq1,seq2,msg=None,seq_type=None):\n  ''  \n  if seq_type is not None:\n   seq_type_name=seq_type.__name__\n   if not isinstance(seq1,seq_type):\n    raise self.failureException('First sequence is not a %s: %s'\n    %(seq_type_name,safe_repr(seq1)))\n   if not isinstance(seq2,seq_type):\n    raise self.failureException('Second sequence is not a %s: %s'\n    %(seq_type_name,safe_repr(seq2)))\n  else:\n   seq_type_name=\"sequence\"\n  differing=None\n  try:\n   len1=len(seq1)\n  except(TypeError,NotImplementedError):\n   differing='First %s has no length.    Non-sequence?'%(\n   seq_type_name)\n  if differing is None:\n   try:\n    len2=len(seq2)\n   except(TypeError,NotImplementedError):\n    differing='Second %s has no length.    Non-sequence?'%(\n    seq_type_name)\n  if differing is None:\n   if seq1==seq2:\n    return\n   seq1_repr=safe_repr(seq1)\n   seq2_repr=safe_repr(seq2)\n   if len(seq1_repr)>30:\n    seq1_repr=seq1_repr[:30]+'...'\n   if len(seq2_repr)>30:\n    seq2_repr=seq2_repr[:30]+'...'\n   elements=(seq_type_name.capitalize(),seq1_repr,seq2_repr)\n   differing='%ss differ: %s != %s\\n'%elements\n   for i in range(min(len1,len2)):\n    try:\n     item1=seq1[i]\n    except(TypeError,IndexError,NotImplementedError):\n     differing+=('\\nUnable to index element %d of first %s\\n'%\n     (i,seq_type_name))\n     break\n    try:\n     item2=seq2[i]\n    except(TypeError,IndexError,NotImplementedError):\n     differing+=('\\nUnable to index element %d of second %s\\n'%\n     (i,seq_type_name))\n     break\n    if item1!=item2:\n     differing+=('\\nFirst differing element %d:\\n%s\\n%s\\n'%\n     (i,item1,item2))\n     break\n   else:\n    if(len1==len2 and seq_type is None and\n    type(seq1)!=type(seq2)):\n     return\n   if len1>len2:\n    differing+=('\\nFirst %s contains %d additional '\n    'elements.\\n'%(seq_type_name,len1-len2))\n    try:\n     differing+=('First extra element %d:\\n%s\\n'%\n     (len2,seq1[len2]))\n    except(TypeError,IndexError,NotImplementedError):\n     differing+=('Unable to index element %d '\n     'of first %s\\n'%(len2,seq_type_name))\n   elif len1<len2:\n    differing+=('\\nSecond %s contains %d additional '\n    'elements.\\n'%(seq_type_name,len2-len1))\n    try:\n     differing+=('First extra element %d:\\n%s\\n'%\n     (len1,seq2[len1]))\n    except(TypeError,IndexError,NotImplementedError):\n     differing+=('Unable to index element %d '\n     'of second %s\\n'%(len1,seq_type_name))\n  standardMsg=differing\n  diffMsg='\\n'+'\\n'.join(\n  difflib.ndiff(pprint.pformat(seq1).splitlines(),\n  pprint.pformat(seq2).splitlines()))\n  standardMsg=self._truncateMessage(standardMsg,diffMsg)\n  msg=self._formatMessage(msg,standardMsg)\n  self.fail(msg)\n def _truncateMessage(self,message,diff):\n  max_diff=self.maxDiff\n  if max_diff is None or len(diff)<=max_diff:\n   return message+diff\n  return message+(DIFF_OMITTED%len(diff))\n def assertListEqual(self,list1,list2,msg=None):\n  ''  \n  self.assertSequenceEqual(list1,list2,msg,seq_type=list)\n def assertTupleEqual(self,tuple1,tuple2,msg=None):\n  ''  \n  self.assertSequenceEqual(tuple1,tuple2,msg,seq_type=tuple)\n def assertSetEqual(self,set1,set2,msg=None):\n  ''  \n  try:\n   difference1=set1.difference(set2)\n  except TypeError as e:\n   self.fail('invalid type when attempting set difference: %s'%e)\n  except AttributeError as e:\n   self.fail('first argument does not support set difference: %s'%e)\n  try:\n   difference2=set2.difference(set1)\n  except TypeError as e:\n   self.fail('invalid type when attempting set difference: %s'%e)\n  except AttributeError as e:\n   self.fail('second argument does not support set difference: %s'%e)\n  if not(difference1 or difference2):\n   return\n  lines=[]\n  if difference1:\n   lines.append('Items in the first set but not the second:')\n   for item in difference1:\n    lines.append(repr(item))\n  if difference2:\n   lines.append('Items in the second set but not the first:')\n   for item in difference2:\n    lines.append(repr(item))\n  standardMsg='\\n'.join(lines)\n  self.fail(self._formatMessage(msg,standardMsg))\n def assertIn(self,member,container,msg=None):\n  if member not in container:\n   standardMsg='%s not found in %s'%(safe_repr(member),\n   safe_repr(container))\n   self.fail(self._formatMessage(msg,standardMsg))\n def assertNotIn(self,member,container,msg=None):\n  if member in container:\n   standardMsg='%s unexpectedly found in %s'%(safe_repr(member),\n   safe_repr(container))\n   self.fail(self._formatMessage(msg,standardMsg))\n def assertIs(self,expr1,expr2,msg=None):\n  if expr1 is not expr2:\n   standardMsg='%s is not %s'%(safe_repr(expr1),\n   safe_repr(expr2))\n   self.fail(self._formatMessage(msg,standardMsg))\n def assertIsNot(self,expr1,expr2,msg=None):\n  if expr1 is expr2:\n   standardMsg='unexpectedly identical: %s'%(safe_repr(expr1),)\n   self.fail(self._formatMessage(msg,standardMsg))\n def assertDictEqual(self,d1,d2,msg=None):\n  self.assertIsInstance(d1,dict,'First argument is not a dictionary')\n  self.assertIsInstance(d2,dict,'Second argument is not a dictionary')\n  if d1!=d2:\n   standardMsg='%s != %s'%(safe_repr(d1,True),safe_repr(d2,True))\n   diff=('\\n'+'\\n'.join(difflib.ndiff(\n   pprint.pformat(d1).splitlines(),\n   pprint.pformat(d2).splitlines())))\n   standardMsg=self._truncateMessage(standardMsg,diff)\n   self.fail(self._formatMessage(msg,standardMsg))\n def assertDictContainsSubset(self,subset,dictionary,msg=None):\n  warnings.warn('assertDictContainsSubset is deprecated',\n  DeprecationWarning)\n  missing=[]\n  mismatched=[]\n  for key,value in subset.items():\n   if key not in dictionary:\n    missing.append(key)\n   elif value!=dictionary[key]:\n    mismatched.append('%s, expected: %s, actual: %s'%\n    (safe_repr(key),safe_repr(value),\n    safe_repr(dictionary[key])))\n  if not(missing or mismatched):\n   return\n  standardMsg=''\n  if missing:\n   standardMsg='Missing: %s'%','.join(safe_repr(m)for m in\n   missing)\n  if mismatched:\n   if standardMsg:\n    standardMsg+='; '\n   standardMsg+='Mismatched values: %s'%','.join(mismatched)\n  self.fail(self._formatMessage(msg,standardMsg))\n def assertCountEqual(self,first,second,msg=None):\n  ''  \n  first_seq,second_seq=list(first),list(second)\n  try:\n   first=collections.Counter(first_seq)\n   second=collections.Counter(second_seq)\n  except TypeError:\n   differences=_count_diff_all_purpose(first_seq,second_seq)\n  else:\n   if first==second:\n    return\n   differences=_count_diff_hashable(first_seq,second_seq)\n  if differences:\n   standardMsg='Element counts were not equal:\\n'\n   lines=['First has %d, Second has %d:  %r'%diff for diff in differences]\n   diffMsg='\\n'.join(lines)\n   standardMsg=self._truncateMessage(standardMsg,diffMsg)\n   msg=self._formatMessage(msg,standardMsg)\n   self.fail(msg)\n def assertMultiLineEqual(self,first,second,msg=None):\n  self.assertIsInstance(first,str,'First argument is not a string')\n  self.assertIsInstance(second,str,'Second argument is not a string')\n  if first!=second:\n   if(len(first)>self._diffThreshold or\n   len(second)>self._diffThreshold):\n    self._baseAssertEqual(first,second,msg)\n   firstlines=first.splitlines(keepends=True)\n   secondlines=second.splitlines(keepends=True)\n   if len(firstlines)==1 and first.strip('\\r\\n')==first:\n    firstlines=[first+'\\n']\n    secondlines=[second+'\\n']\n   standardMsg='%s != %s'%(safe_repr(first,True),\n   safe_repr(second,True))\n   diff='\\n'+''.join(difflib.ndiff(firstlines,secondlines))\n   standardMsg=self._truncateMessage(standardMsg,diff)\n   self.fail(self._formatMessage(msg,standardMsg))\n def assertLess(self,a,b,msg=None):\n  if not a<b:\n   standardMsg='%s not less than %s'%(safe_repr(a),safe_repr(b))\n   self.fail(self._formatMessage(msg,standardMsg))\n def assertLessEqual(self,a,b,msg=None):\n  if not a<=b:\n   standardMsg='%s not less than or equal to %s'%(safe_repr(a),safe_repr(b))\n   self.fail(self._formatMessage(msg,standardMsg))\n def assertGreater(self,a,b,msg=None):\n  if not a>b:\n   standardMsg='%s not greater than %s'%(safe_repr(a),safe_repr(b))\n   self.fail(self._formatMessage(msg,standardMsg))\n def assertGreaterEqual(self,a,b,msg=None):\n  if not a>=b:\n   standardMsg='%s not greater than or equal to %s'%(safe_repr(a),safe_repr(b))\n   self.fail(self._formatMessage(msg,standardMsg))\n def assertIsNone(self,obj,msg=None):\n  if obj is not None:\n   standardMsg='%s is not None'%(safe_repr(obj),)\n   self.fail(self._formatMessage(msg,standardMsg))\n def assertIsNotNone(self,obj,msg=None):\n  if obj is None:\n   standardMsg='unexpectedly None'\n   self.fail(self._formatMessage(msg,standardMsg))\n def assertIsInstance(self,obj,cls,msg=None):\n  ''  \n  if not isinstance(obj,cls):\n   standardMsg='%s is not an instance of %r'%(safe_repr(obj),cls)\n   self.fail(self._formatMessage(msg,standardMsg))\n def assertNotIsInstance(self,obj,cls,msg=None):\n  if isinstance(obj,cls):\n   standardMsg='%s is an instance of %r'%(safe_repr(obj),cls)\n   self.fail(self._formatMessage(msg,standardMsg))\n def assertRaisesRegex(self,expected_exception,expected_regex,\n callable_obj=None,*args,**kwargs):\n  ''  \n  context=_AssertRaisesContext(expected_exception,self,callable_obj,\n  expected_regex)\n  return context.handle('assertRaisesRegex',callable_obj,args,kwargs)\n def assertWarnsRegex(self,expected_warning,expected_regex,\n callable_obj=None,*args,**kwargs):\n  ''  \n  context=_AssertWarnsContext(expected_warning,self,callable_obj,\n  expected_regex)\n  return context.handle('assertWarnsRegex',callable_obj,args,kwargs)\n def assertRegex(self,text,expected_regex,msg=None):\n  if isinstance(expected_regex,(str,bytes)):\n   assert expected_regex,\"expected_regex must not be empty.\"\n   expected_regex=re.compile(expected_regex)\n  if not expected_regex.search(text):\n   msg=msg or\"Regex didn't match\"\n   msg='%s: %r not found in %r'%(msg,expected_regex.pattern,text)\n   raise self.failureException(msg)\n def assertNotRegex(self,text,unexpected_regex,msg=None):\n  if isinstance(unexpected_regex,(str,bytes)):\n   unexpected_regex=re.compile(unexpected_regex)\n  match=unexpected_regex.search(text)\n  if match:\n   msg=msg or\"Regex matched\"\n   msg='%s: %r matches %r in %r'%(msg,\n   text[match.start():match.end()],\n   unexpected_regex.pattern,\n   text)\n   raise self.failureException(msg)\n def _deprecate(original_func):\n  def deprecated_func(*args,**kwargs):\n   warnings.warn(\n   'Please use {0} instead.'.format(original_func.__name__),\n   DeprecationWarning,2)\n   return original_func(*args,**kwargs)\n  return deprecated_func\n failUnlessEqual=assertEquals=_deprecate(assertEqual)\n failIfEqual=assertNotEquals=_deprecate(assertNotEqual)\n failUnlessAlmostEqual=assertAlmostEquals=_deprecate(assertAlmostEqual)\n failIfAlmostEqual=assertNotAlmostEquals=_deprecate(assertNotAlmostEqual)\n failUnless=assert_=_deprecate(assertTrue)\n failUnlessRaises=_deprecate(assertRaises)\n failIf=_deprecate(assertFalse)\n assertRaisesRegexp=_deprecate(assertRaisesRegex)\n assertRegexpMatches=_deprecate(assertRegex)\nclass FunctionTestCase(TestCase):\n '' \n def __init__(self,testFunc,setUp=None,tearDown=None,description=None):\n  super(FunctionTestCase,self).__init__()\n  self._setUpFunc=setUp\n  self._tearDownFunc=tearDown\n  self._testFunc=testFunc\n  self._description=description\n def setUp(self):\n  if self._setUpFunc is not None:\n   self._setUpFunc()\n def tearDown(self):\n  if self._tearDownFunc is not None:\n   self._tearDownFunc()\n def runTest(self):\n  self._testFunc()\n def id(self):\n  return self._testFunc.__name__\n def __eq__(self,other):\n  if not isinstance(other,self.__class__):\n   return NotImplemented\n  return self._setUpFunc==other._setUpFunc and  self._tearDownFunc==other._tearDownFunc and  self._testFunc==other._testFunc and  self._description==other._description\n def __ne__(self,other):\n  return not self==other\n def __hash__(self):\n  return hash((type(self),self._setUpFunc,self._tearDownFunc,\n  self._testFunc,self._description))\n def __str__(self):\n  return\"%s (%s)\"%(strclass(self.__class__),\n  self._testFunc.__name__)\n def __repr__(self):\n  return\"<%s tec=%s>\"%(strclass(self.__class__),\n  self._testFunc)\n def shortDescription(self):\n  if self._description is not None:\n   return self._description\n  doc=self._testFunc.__doc__\n  return doc and doc.split(\"\\n\")[0].strip()or None\n"], "unittest.result": ["\nimport io\nimport sys\nimport traceback\nfrom.import util\nfrom functools import wraps\n__unittest=True\ndef failfast(method):\n @wraps(method)\n def inner(self,*args,**kw):\n  if getattr(self,'failfast',False):\n   self.stop()\n  return method(self,*args,**kw)\n return inner\nSTDOUT_LINE='\\nStdout:\\n%s'\nSTDERR_LINE='\\nStderr:\\n%s'\nclass TestResult(object):\n '' \n _previousTestClass=None\n _testRunEntered=False\n _moduleSetUpFailed=False\n def __init__(self,stream=None,descriptions=None,verbosity=None):\n  self.failfast=False\n  self.failures=[]\n  self.errors=[]\n  self.testsRun=0\n  self.skipped=[]\n  self.expectedFailures=[]\n  self.unexpectedSuccesses=[]\n  self.shouldStop=False\n  self.buffer=False\n  self._stdout_buffer=None\n  self._stderr_buffer=None\n  self._original_stdout=sys.stdout\n  self._original_stderr=sys.stderr\n  self._mirrorOutput=False\n def printErrors(self):\n  pass\n def startTest(self,test):\n  self.testsRun+=1\n  self._mirrorOutput=False\n  self._setupStdout()\n def _setupStdout(self):\n  if self.buffer:\n   if self._stderr_buffer is None:\n    self._stderr_buffer=io.StringIO()\n    self._stdout_buffer=io.StringIO()\n   sys.stdout=self._stdout_buffer\n   sys.stderr=self._stderr_buffer\n def startTestRun(self):\n  ''  \n def stopTest(self,test):\n  self._restoreStdout()\n  self._mirrorOutput=False\n def _restoreStdout(self):\n  if self.buffer:\n   if self._mirrorOutput:\n    output=sys.stdout.getvalue()\n    error=sys.stderr.getvalue()\n    if output:\n     if not output.endswith('\\n'):\n      output+='\\n'\n     self._original_stdout.write(STDOUT_LINE%output)\n    if error:\n     if not error.endswith('\\n'):\n      error+='\\n'\n     self._original_stderr.write(STDERR_LINE%error)\n   sys.stdout=self._original_stdout\n   sys.stderr=self._original_stderr\n   self._stdout_buffer.seek(0)\n   self._stdout_buffer.truncate()\n   self._stderr_buffer.seek(0)\n   self._stderr_buffer.truncate()\n def stopTestRun(self):\n  ''  \n @failfast\n def addError(self,test,err):\n  ''  \n  self.errors.append((test,self._exc_info_to_string(err,test)))\n  self._mirrorOutput=True\n @failfast\n def addFailure(self,test,err):\n  ''  \n  self.failures.append((test,self._exc_info_to_string(err,test)))\n  self._mirrorOutput=True\n def addSuccess(self,test):\n  pass\n def addSkip(self,test,reason):\n  self.skipped.append((test,reason))\n def addExpectedFailure(self,test,err):\n  self.expectedFailures.append(\n  (test,self._exc_info_to_string(err,test)))\n @failfast\n def addUnexpectedSuccess(self,test):\n  self.unexpectedSuccesses.append(test)\n def wasSuccessful(self):\n  return len(self.failures)==len(self.errors)==0\n def stop(self):\n  self.shouldStop=True\n def _exc_info_to_string(self,err,test):\n  exctype,value,tb=err\n  while tb and self._is_relevant_tb_level(tb):\n   tb=tb.tb_next\n  if exctype is test.failureException:\n   length=self._count_relevant_tb_levels(tb)\n   msgLines=traceback.format_exception(exctype,value,tb,length)\n  else:\n   msgLines=traceback.format_exception(exctype,value,tb)\n  if self.buffer:\n   output=sys.stdout.getvalue()\n   error=sys.stderr.getvalue()\n   if output:\n    if not output.endswith('\\n'):\n     output+='\\n'\n    msgLines.append(STDOUT_LINE%output)\n   if error:\n    if not error.endswith('\\n'):\n     error+='\\n'\n    msgLines.append(STDERR_LINE%error)\n  return''.join(msgLines)\n def _is_relevant_tb_level(self,tb):\n  return True\n def _count_relevant_tb_levels(self,tb):\n  length=0\n  while tb and not self._is_relevant_tb_level(tb):\n   length+=1\n   tb=tb.tb_next\n  return length\n def __repr__(self):\n  return(\"<%s run=%i errors=%i failures=%i>\"%\n  (util.strclass(self.__class__),self.testsRun,len(self.errors),\n  len(self.failures)))\n"], "unittest.runner": ["\nimport sys\nimport time\nimport warnings\nfrom.import result\nfrom.signals import registerResult\n__unittest=True\nclass _WritelnDecorator(object):\n def __init__(self,stream):\n  self.stream=stream\n def __getattr__(self,attr):\n  if attr in('stream','__getstate__'):\n   raise AttributeError(attr)\n  return getattr(self.stream,attr)\n def writeln(self,arg=None):\n  if arg:\n   self.write(arg)\n  self.write('\\n')\nclass TextTestResult(result.TestResult):\n '' \n separator1='='*70\n separator2='-'*70\n def __init__(self,stream,descriptions,verbosity):\n  super(TextTestResult,self).__init__(stream,descriptions,verbosity)\n  self.stream=stream\n  self.showAll=verbosity>1\n  self.dots=verbosity==1\n  self.descriptions=descriptions\n def getDescription(self,test):\n  doc_first_line=test.shortDescription()\n  if self.descriptions and doc_first_line:\n   return'\\n'.join((str(test),doc_first_line))\n  else:\n   return str(test)\n def startTest(self,test):\n  super(TextTestResult,self).startTest(test)\n  if self.showAll:\n   self.stream.write(self.getDescription(test))\n   self.stream.write(\" ... \")\n   self.stream.flush()\n def addSuccess(self,test):\n  super(TextTestResult,self).addSuccess(test)\n  if self.showAll:\n   self.stream.writeln(\"ok\")\n  elif self.dots:\n   self.stream.write('.')\n   self.stream.flush()\n def addError(self,test,err):\n  super(TextTestResult,self).addError(test,err)\n  if self.showAll:\n   self.stream.writeln(\"ERROR\")\n  elif self.dots:\n   self.stream.write('E')\n   self.stream.flush()\n def addFailure(self,test,err):\n  super(TextTestResult,self).addFailure(test,err)\n  if self.showAll:\n   self.stream.writeln(\"FAIL\")\n  elif self.dots:\n   self.stream.write('F')\n   self.stream.flush()\n def addSkip(self,test,reason):\n  super(TextTestResult,self).addSkip(test,reason)\n  if self.showAll:\n   self.stream.writeln(\"skipped {0!r}\".format(reason))\n  elif self.dots:\n   self.stream.write(\"s\")\n   self.stream.flush()\n def addExpectedFailure(self,test,err):\n  super(TextTestResult,self).addExpectedFailure(test,err)\n  if self.showAll:\n   self.stream.writeln(\"expected failure\")\n  elif self.dots:\n   self.stream.write(\"x\")\n   self.stream.flush()\n def addUnexpectedSuccess(self,test):\n  super(TextTestResult,self).addUnexpectedSuccess(test)\n  if self.showAll:\n   self.stream.writeln(\"unexpected success\")\n  elif self.dots:\n   self.stream.write(\"u\")\n   self.stream.flush()\n def printErrors(self):\n  if self.dots or self.showAll:\n   self.stream.writeln()\n  self.printErrorList('ERROR',self.errors)\n  self.printErrorList('FAIL',self.failures)\n def printErrorList(self,flavour,errors):\n  for test,err in errors:\n   self.stream.writeln(self.separator1)\n   self.stream.writeln(\"%s: %s\"%(flavour,self.getDescription(test)))\n   self.stream.writeln(self.separator2)\n   self.stream.writeln(\"%s\"%err)\nclass TextTestRunner(object):\n '' \n resultclass=TextTestResult\n def __init__(self,stream=None,descriptions=True,verbosity=1,\n failfast=False,buffer=False,resultclass=None,warnings=None):\n  if stream is None:\n   stream=sys.stderr\n  self.stream=_WritelnDecorator(stream)\n  self.descriptions=descriptions\n  self.verbosity=verbosity\n  self.failfast=failfast\n  self.buffer=buffer\n  self.warnings=warnings\n  if resultclass is not None:\n   self.resultclass=resultclass\n def _makeResult(self):\n  return self.resultclass(self.stream,self.descriptions,self.verbosity)\n def run(self,test):\n  result=self._makeResult()\n  registerResult(result)\n  result.failfast=self.failfast\n  result.buffer=self.buffer\n  with warnings.catch_warnings():\n   if self.warnings:\n    warnings.simplefilter(self.warnings)\n    if self.warnings in['default','always']:\n     warnings.filterwarnings('module',\n     category=DeprecationWarning,\n     message='Please use assert\\w+ instead.')\n   startTime=time.time()\n   startTestRun=getattr(result,'startTestRun',None)\n   if startTestRun is not None:\n    startTestRun()\n   try:\n    test(result)\n   finally:\n    stopTestRun=getattr(result,'stopTestRun',None)\n    if stopTestRun is not None:\n     stopTestRun()\n   stopTime=time.time()\n  timeTaken=stopTime-startTime\n  result.printErrors()\n  if hasattr(result,'separator2'):\n   self.stream.writeln(result.separator2)\n  run=result.testsRun\n  self.stream.writeln(\"Ran %d test%s in %.3fs\"%\n  (run,run!=1 and\"s\"or\"\",timeTaken))\n  self.stream.writeln()\n  expectedFails=unexpectedSuccesses=skipped=0\n  try:\n   results=map(len,(result.expectedFailures,\n   result.unexpectedSuccesses,\n   result.skipped))\n  except AttributeError:\n   pass\n  else:\n   expectedFails,unexpectedSuccesses,skipped=results\n  infos=[]\n  if not result.wasSuccessful():\n   self.stream.write(\"FAILED\")\n   failed,errored=len(result.failures),len(result.errors)\n   if failed:\n    infos.append(\"failures=%d\"%failed)\n   if errored:\n    infos.append(\"errors=%d\"%errored)\n  else:\n   self.stream.write(\"OK\")\n  if skipped:\n   infos.append(\"skipped=%d\"%skipped)\n  if expectedFails:\n   infos.append(\"expected failures=%d\"%expectedFails)\n  if unexpectedSuccesses:\n   infos.append(\"unexpected successes=%d\"%unexpectedSuccesses)\n  if infos:\n   self.stream.writeln(\" (%s)\"%(\", \".join(infos),))\n  else:\n   self.stream.write(\"\\n\")\n  return result\n"], "unittest.util": ["\nfrom collections import namedtuple,OrderedDict\n__unittest=True\n_MAX_LENGTH=80\ndef safe_repr(obj,short=False):\n try:\n  result=repr(obj)\n except Exception:\n  result=object.__repr__(obj)\n if not short or len(result)<_MAX_LENGTH:\n  return result\n return result[:_MAX_LENGTH]+' [truncated]...'\ndef strclass(cls):\n return\"%s.%s\"%(cls.__module__,cls.__name__)\ndef sorted_list_difference(expected,actual):\n '' \n i=j=0\n missing=[]\n unexpected=[]\n while True:\n  try:\n   e=expected[i]\n   a=actual[j]\n   if e<a:\n    missing.append(e)\n    i+=1\n    while expected[i]==e:\n     i+=1\n   elif e>a:\n    unexpected.append(a)\n    j+=1\n    while actual[j]==a:\n     j+=1\n   else:\n    i+=1\n    try:\n     while expected[i]==e:\n      i+=1\n    finally:\n     j+=1\n     while actual[j]==a:\n      j+=1\n  except IndexError:\n   missing.extend(expected[i:])\n   unexpected.extend(actual[j:])\n   break\n return missing,unexpected\ndef unorderable_list_difference(expected,actual):\n '' \n missing=[]\n while expected:\n  item=expected.pop()\n  try:\n   actual.remove(item)\n  except ValueError:\n   missing.append(item)\n return missing,actual\ndef three_way_cmp(x,y):\n return(x>y)-(x<y)\n_Mismatch=namedtuple('Mismatch','actual expected value')\ndef _count_diff_all_purpose(actual,expected):\n s,t=list(actual),list(expected)\n m,n=len(s),len(t)\n NULL=object()\n result=[]\n for i,elem in enumerate(s):\n  if elem is NULL:\n   continue\n  cnt_s=cnt_t=0\n  for j in range(i,m):\n   if s[j]==elem:\n    cnt_s+=1\n    s[j]=NULL\n  for j,other_elem in enumerate(t):\n   if other_elem==elem:\n    cnt_t+=1\n    t[j]=NULL\n  if cnt_s!=cnt_t:\n   diff=_Mismatch(cnt_s,cnt_t,elem)\n   result.append(diff)\n for i,elem in enumerate(t):\n  if elem is NULL:\n   continue\n  cnt_t=0\n  for j in range(i,n):\n   if t[j]==elem:\n    cnt_t+=1\n    t[j]=NULL\n  diff=_Mismatch(0,cnt_t,elem)\n  result.append(diff)\n return result\ndef _ordered_count(iterable):\n c=OrderedDict()\n for elem in iterable:\n  c[elem]=c.get(elem,0)+1\n return c\ndef _count_diff_hashable(actual,expected):\n s,t=_ordered_count(actual),_ordered_count(expected)\n result=[]\n for elem,cnt_s in s.items():\n  cnt_t=t.get(elem,0)\n  if cnt_s!=cnt_t:\n   diff=_Mismatch(cnt_s,cnt_t,elem)\n   result.append(diff)\n for elem,cnt_t in t.items():\n  if elem not in s:\n   diff=_Mismatch(0,cnt_t,elem)\n   result.append(diff)\n return result\n"], "unittest.test.testmock.support": ["import sys\ndef is_instance(obj,klass):\n return issubclass(type(obj),klass)\nclass SomeClass(object):\n class_attribute=None\n def wibble(self):\n  pass\nclass X(object):\n pass\ndef examine_warnings(func):\n def wrapper():\n  with catch_warnings(record=True)as ws:\n   func(ws)\n return wrapper\n"], "unittest.test.test_runner": ["import io\nimport os\nimport sys\nimport pickle\nimport subprocess\nimport unittest\nfrom.support import LoggingResult,ResultWithNoStartTestRunStopTestRun\nclass TestCleanUp(unittest.TestCase):\n def testCleanUp(self):\n  class TestableTest(unittest.TestCase):\n   def testNothing(self):\n    pass\n  test=TestableTest('testNothing')\n  self.assertEqual(test._cleanups,[])\n  cleanups=[]\n  def cleanup1(*args,**kwargs):\n   cleanups.append((1,args,kwargs))\n  def cleanup2(*args,**kwargs):\n   cleanups.append((2,args,kwargs))\n  test.addCleanup(cleanup1,1,2,3,four='hello',five='goodbye')\n  test.addCleanup(cleanup2)\n  self.assertEqual(test._cleanups,\n  [(cleanup1,(1,2,3),dict(four='hello',five='goodbye')),\n  (cleanup2,(),{})])\n  self.assertTrue(test.doCleanups())\n  self.assertEqual(cleanups,[(2,(),{}),(1,(1,2,3),dict(four='hello',five='goodbye'))])\n def testCleanUpWithErrors(self):\n  class TestableTest(unittest.TestCase):\n   def testNothing(self):\n    pass\n  class MockOutcome(object):\n   success=True\n   errors=[]\n  test=TestableTest('testNothing')\n  test._outcomeForDoCleanups=MockOutcome\n  exc1=Exception('foo')\n  exc2=Exception('bar')\n  def cleanup1():\n   raise exc1\n  def cleanup2():\n   raise exc2\n  test.addCleanup(cleanup1)\n  test.addCleanup(cleanup2)\n  self.assertFalse(test.doCleanups())\n  self.assertFalse(MockOutcome.success)\n  (Type1,instance1,_),(Type2,instance2,_)=reversed(MockOutcome.errors)\n  self.assertEqual((Type1,instance1),(Exception,exc1))\n  self.assertEqual((Type2,instance2),(Exception,exc2))\n def testCleanupInRun(self):\n  blowUp=False\n  ordering=[]\n  class TestableTest(unittest.TestCase):\n   def setUp(self):\n    ordering.append('setUp')\n    if blowUp:\n     raise Exception('foo')\n   def testNothing(self):\n    ordering.append('test')\n   def tearDown(self):\n    ordering.append('tearDown')\n  test=TestableTest('testNothing')\n  def cleanup1():\n   ordering.append('cleanup1')\n  def cleanup2():\n   ordering.append('cleanup2')\n  test.addCleanup(cleanup1)\n  test.addCleanup(cleanup2)\n  def success(some_test):\n   self.assertEqual(some_test,test)\n   ordering.append('success')\n  result=unittest.TestResult()\n  result.addSuccess=success\n  test.run(result)\n  self.assertEqual(ordering,['setUp','test','tearDown',\n  'cleanup2','cleanup1','success'])\n  blowUp=True\n  ordering=[]\n  test=TestableTest('testNothing')\n  test.addCleanup(cleanup1)\n  test.run(result)\n  self.assertEqual(ordering,['setUp','cleanup1'])\n def testTestCaseDebugExecutesCleanups(self):\n  ordering=[]\n  class TestableTest(unittest.TestCase):\n   def setUp(self):\n    ordering.append('setUp')\n    self.addCleanup(cleanup1)\n   def testNothing(self):\n    ordering.append('test')\n   def tearDown(self):\n    ordering.append('tearDown')\n  test=TestableTest('testNothing')\n  def cleanup1():\n   ordering.append('cleanup1')\n   test.addCleanup(cleanup2)\n  def cleanup2():\n   ordering.append('cleanup2')\n  test.debug()\n  self.assertEqual(ordering,['setUp','test','tearDown','cleanup1','cleanup2'])\nclass Test_TextTestRunner(unittest.TestCase):\n def test_init(self):\n  runner=unittest.TextTestRunner()\n  self.assertFalse(runner.failfast)\n  self.assertFalse(runner.buffer)\n  self.assertEqual(runner.verbosity,1)\n  self.assertEqual(runner.warnings,None)\n  self.assertTrue(runner.descriptions)\n  self.assertEqual(runner.resultclass,unittest.TextTestResult)\n def testBufferAndFailfast(self):\n  class Test(unittest.TestCase):\n   def testFoo(self):\n    pass\n  result=unittest.TestResult()\n  runner=unittest.TextTestRunner(stream=io.StringIO(),failfast=True,\n  buffer=True)\n  runner._makeResult=lambda:result\n  runner.run(Test('testFoo'))\n  self.assertTrue(result.failfast)\n  self.assertTrue(result.buffer)\n def testRunnerRegistersResult(self):\n  class Test(unittest.TestCase):\n   def testFoo(self):\n    pass\n  originalRegisterResult=unittest.runner.registerResult\n  def cleanup():\n   unittest.runner.registerResult=originalRegisterResult\n  self.addCleanup(cleanup)\n  result=unittest.TestResult()\n  runner=unittest.TextTestRunner(stream=io.StringIO())\n  runner._makeResult=lambda:result\n  self.wasRegistered=0\n  def fakeRegisterResult(thisResult):\n   self.wasRegistered+=1\n   self.assertEqual(thisResult,result)\n  unittest.runner.registerResult=fakeRegisterResult\n  runner.run(unittest.TestSuite())\n  self.assertEqual(self.wasRegistered,1)\n def test_works_with_result_without_startTestRun_stopTestRun(self):\n  class OldTextResult(ResultWithNoStartTestRunStopTestRun):\n   separator2=''\n   def printErrors(self):\n    pass\n  class Runner(unittest.TextTestRunner):\n   def __init__(self):\n    super(Runner,self).__init__(io.StringIO())\n   def _makeResult(self):\n    return OldTextResult()\n  runner=Runner()\n  runner.run(unittest.TestSuite())\n def test_startTestRun_stopTestRun_called(self):\n  class LoggingTextResult(LoggingResult):\n   separator2=''\n   def printErrors(self):\n    pass\n  class LoggingRunner(unittest.TextTestRunner):\n   def __init__(self,events):\n    super(LoggingRunner,self).__init__(io.StringIO())\n    self._events=events\n   def _makeResult(self):\n    return LoggingTextResult(self._events)\n  events=[]\n  runner=LoggingRunner(events)\n  runner.run(unittest.TestSuite())\n  expected=['startTestRun','stopTestRun']\n  self.assertEqual(events,expected)\n def test_pickle_unpickle(self):\n  stream=io.StringIO(\"foo\")\n  runner=unittest.TextTestRunner(stream)\n  for protocol in range(2,pickle.HIGHEST_PROTOCOL+1):\n   s=pickle.dumps(runner,protocol)\n   obj=pickle.loads(s)\n   self.assertEqual(obj.stream.getvalue(),stream.getvalue())\n def test_resultclass(self):\n  def MockResultClass(*args):\n   return args\n  STREAM=object()\n  DESCRIPTIONS=object()\n  VERBOSITY=object()\n  runner=unittest.TextTestRunner(STREAM,DESCRIPTIONS,VERBOSITY,\n  resultclass=MockResultClass)\n  self.assertEqual(runner.resultclass,MockResultClass)\n  expectedresult=(runner.stream,DESCRIPTIONS,VERBOSITY)\n  self.assertEqual(runner._makeResult(),expectedresult)\n def test_warnings(self):\n  ''  \n  def get_parse_out_err(p):\n   return[b.splitlines()for b in p.communicate()]\n  opts=dict(stdout=subprocess.PIPE,stderr=subprocess.PIPE,\n  cwd=os.path.dirname(__file__))\n  ae_msg=b'Please use assertEqual instead.'\n  at_msg=b'Please use assertTrue instead.'\n  p=subprocess.Popen([sys.executable,'_test_warnings.py'],**opts)\n  out,err=get_parse_out_err(p)\n  self.assertIn(b'OK',err)\n  self.assertEqual(len(out),12)\n  for msg in[b'dw',b'iw',b'uw']:\n   self.assertEqual(out.count(msg),3)\n  for msg in[ae_msg,at_msg,b'rw']:\n   self.assertEqual(out.count(msg),1)\n  args_list=(\n  [sys.executable,'_test_warnings.py','ignore'],\n  [sys.executable,'-Wa','_test_warnings.py','ignore'],\n  [sys.executable,'-Wi','_test_warnings.py']\n  )\n  for args in args_list:\n   p=subprocess.Popen(args,**opts)\n   out,err=get_parse_out_err(p)\n   self.assertIn(b'OK',err)\n   self.assertEqual(len(out),0)\n  p=subprocess.Popen([sys.executable,'_test_warnings.py','always'],\n  **opts)\n  out,err=get_parse_out_err(p)\n  self.assertIn(b'OK',err)\n  self.assertEqual(len(out),14)\n  for msg in[b'dw',b'iw',b'uw',b'rw']:\n   self.assertEqual(out.count(msg),3)\n  for msg in[ae_msg,at_msg]:\n   self.assertEqual(out.count(msg),1)\n def testStdErrLookedUpAtInstantiationTime(self):\n  old_stderr=sys.stderr\n  f=io.StringIO()\n  sys.stderr=f\n  try:\n   runner=unittest.TextTestRunner()\n   self.assertTrue(runner.stream.stream is f)\n  finally:\n   sys.stderr=old_stderr\n def testSpecifiedStreamUsed(self):\n  f=io.StringIO()\n  runner=unittest.TextTestRunner(f)\n  self.assertTrue(runner.stream.stream is f)\n"], "unittest.__main__": ["\nimport sys\nif sys.argv[0].endswith(\"__main__.py\"):\n import os.path\n executable=os.path.basename(sys.executable)\n sys.argv[0]=executable+\" -m unittest\"\n del os\n__unittest=True\nfrom.main import main,TestProgram,USAGE_AS_MAIN\nTestProgram.USAGE=USAGE_AS_MAIN\nmain(module=None)\n"], "unittest.test.test_suite": ["import unittest\nimport sys\nfrom.support import LoggingResult,TestEquality\nclass Test(object):\n class Foo(unittest.TestCase):\n  def test_1(self):pass\n  def test_2(self):pass\n  def test_3(self):pass\n  def runTest(self):pass\ndef _mk_TestSuite(*names):\n return unittest.TestSuite(Test.Foo(n)for n in names)\nclass Test_TestSuite(unittest.TestCase,TestEquality):\n eq_pairs=[(unittest.TestSuite(),unittest.TestSuite())\n ,(unittest.TestSuite(),unittest.TestSuite([]))\n ,(_mk_TestSuite('test_1'),_mk_TestSuite('test_1'))]\n ne_pairs=[(unittest.TestSuite(),_mk_TestSuite('test_1'))\n ,(unittest.TestSuite([]),_mk_TestSuite('test_1'))\n ,(_mk_TestSuite('test_1','test_2'),_mk_TestSuite('test_1','test_3'))\n ,(_mk_TestSuite('test_1'),_mk_TestSuite('test_2'))]\n def test_init__tests_optional(self):\n  suite=unittest.TestSuite()\n  self.assertEqual(suite.countTestCases(),0)\n def test_init__empty_tests(self):\n  suite=unittest.TestSuite([])\n  self.assertEqual(suite.countTestCases(),0)\n def test_init__tests_from_any_iterable(self):\n  def tests():\n   yield unittest.FunctionTestCase(lambda:None)\n   yield unittest.FunctionTestCase(lambda:None)\n  suite_1=unittest.TestSuite(tests())\n  self.assertEqual(suite_1.countTestCases(),2)\n  suite_2=unittest.TestSuite(suite_1)\n  self.assertEqual(suite_2.countTestCases(),2)\n  suite_3=unittest.TestSuite(set(suite_1))\n  self.assertEqual(suite_3.countTestCases(),2)\n def test_init__TestSuite_instances_in_tests(self):\n  def tests():\n   ftc=unittest.FunctionTestCase(lambda:None)\n   yield unittest.TestSuite([ftc])\n   yield unittest.FunctionTestCase(lambda:None)\n  suite=unittest.TestSuite(tests())\n  self.assertEqual(suite.countTestCases(),2)\n def test_iter(self):\n  test1=unittest.FunctionTestCase(lambda:None)\n  test2=unittest.FunctionTestCase(lambda:None)\n  suite=unittest.TestSuite((test1,test2))\n  self.assertEqual(list(suite),[test1,test2])\n def test_countTestCases_zero_simple(self):\n  suite=unittest.TestSuite()\n  self.assertEqual(suite.countTestCases(),0)\n def test_countTestCases_zero_nested(self):\n  class Test1(unittest.TestCase):\n   def test(self):\n    pass\n  suite=unittest.TestSuite([unittest.TestSuite()])\n  self.assertEqual(suite.countTestCases(),0)\n def test_countTestCases_simple(self):\n  test1=unittest.FunctionTestCase(lambda:None)\n  test2=unittest.FunctionTestCase(lambda:None)\n  suite=unittest.TestSuite((test1,test2))\n  self.assertEqual(suite.countTestCases(),2)\n def test_countTestCases_nested(self):\n  class Test1(unittest.TestCase):\n   def test1(self):pass\n   def test2(self):pass\n  test2=unittest.FunctionTestCase(lambda:None)\n  test3=unittest.FunctionTestCase(lambda:None)\n  child=unittest.TestSuite((Test1('test2'),test2))\n  parent=unittest.TestSuite((test3,child,Test1('test1')))\n  self.assertEqual(parent.countTestCases(),4)\n def test_run__empty_suite(self):\n  events=[]\n  result=LoggingResult(events)\n  suite=unittest.TestSuite()\n  suite.run(result)\n  self.assertEqual(events,[])\n def test_run__requires_result(self):\n  suite=unittest.TestSuite()\n  try:\n   suite.run()\n  except TypeError:\n   pass\n  else:\n   self.fail(\"Failed to raise TypeError\")\n def test_run(self):\n  events=[]\n  result=LoggingResult(events)\n  class LoggingCase(unittest.TestCase):\n   def run(self,result):\n    events.append('run %s'%self._testMethodName)\n   def test1(self):pass\n   def test2(self):pass\n  tests=[LoggingCase('test1'),LoggingCase('test2')]\n  unittest.TestSuite(tests).run(result)\n  self.assertEqual(events,['run test1','run test2'])\n def test_addTest__TestCase(self):\n  class Foo(unittest.TestCase):\n   def test(self):pass\n  test=Foo('test')\n  suite=unittest.TestSuite()\n  suite.addTest(test)\n  self.assertEqual(suite.countTestCases(),1)\n  self.assertEqual(list(suite),[test])\n def test_addTest__TestSuite(self):\n  class Foo(unittest.TestCase):\n   def test(self):pass\n  suite_2=unittest.TestSuite([Foo('test')])\n  suite=unittest.TestSuite()\n  suite.addTest(suite_2)\n  self.assertEqual(suite.countTestCases(),1)\n  self.assertEqual(list(suite),[suite_2])\n def test_addTests(self):\n  class Foo(unittest.TestCase):\n   def test_1(self):pass\n   def test_2(self):pass\n  test_1=Foo('test_1')\n  test_2=Foo('test_2')\n  inner_suite=unittest.TestSuite([test_2])\n  def gen():\n   yield test_1\n   yield test_2\n   yield inner_suite\n  suite_1=unittest.TestSuite()\n  suite_1.addTests(gen())\n  self.assertEqual(list(suite_1),list(gen()))\n  suite_2=unittest.TestSuite()\n  for t in gen():\n   suite_2.addTest(t)\n  self.assertEqual(suite_1,suite_2)\n def test_addTest__noniterable(self):\n  suite=unittest.TestSuite()\n  try:\n   suite.addTests(5)\n  except TypeError:\n   pass\n  else:\n   self.fail(\"Failed to raise TypeError\")\n def test_addTest__noncallable(self):\n  suite=unittest.TestSuite()\n  self.assertRaises(TypeError,suite.addTest,5)\n def test_addTest__casesuiteclass(self):\n  suite=unittest.TestSuite()\n  self.assertRaises(TypeError,suite.addTest,Test_TestSuite)\n  self.assertRaises(TypeError,suite.addTest,unittest.TestSuite)\n def test_addTests__string(self):\n  suite=unittest.TestSuite()\n  self.assertRaises(TypeError,suite.addTests,\"foo\")\n def test_function_in_suite(self):\n  def f(_):\n   pass\n  suite=unittest.TestSuite()\n  suite.addTest(f)\n  suite.run(unittest.TestResult())\n def test_basetestsuite(self):\n  class Test(unittest.TestCase):\n   wasSetUp=False\n   wasTornDown=False\n   @classmethod\n   def setUpClass(cls):\n    cls.wasSetUp=True\n   @classmethod\n   def tearDownClass(cls):\n    cls.wasTornDown=True\n   def testPass(self):\n    pass\n   def testFail(self):\n    fail\n  class Module(object):\n   wasSetUp=False\n   wasTornDown=False\n   @staticmethod\n   def setUpModule():\n    Module.wasSetUp=True\n   @staticmethod\n   def tearDownModule():\n    Module.wasTornDown=True\n  Test.__module__='Module'\n  sys.modules['Module']=Module\n  self.addCleanup(sys.modules.pop,'Module')\n  suite=unittest.BaseTestSuite()\n  suite.addTests([Test('testPass'),Test('testFail')])\n  self.assertEqual(suite.countTestCases(),2)\n  result=unittest.TestResult()\n  suite.run(result)\n  self.assertFalse(Module.wasSetUp)\n  self.assertFalse(Module.wasTornDown)\n  self.assertFalse(Test.wasSetUp)\n  self.assertFalse(Test.wasTornDown)\n  self.assertEqual(len(result.errors),1)\n  self.assertEqual(len(result.failures),0)\n  self.assertEqual(result.testsRun,2)\n def test_overriding_call(self):\n  class MySuite(unittest.TestSuite):\n   called=False\n   def __call__(self,*args,**kw):\n    self.called=True\n    unittest.TestSuite.__call__(self,*args,**kw)\n  suite=MySuite()\n  result=unittest.TestResult()\n  wrapper=unittest.TestSuite()\n  wrapper.addTest(suite)\n  wrapper(result)\n  self.assertTrue(suite.called)\n  self.assertFalse(result._testRunEntered)\nif __name__=='__main__':\n unittest.main()\n"], "unittest.test.testmock": ["import os\nimport sys\nimport unittest\nhere=os.path.dirname(__file__)\nloader=unittest.defaultTestLoader\ndef load_tests(*args):\n suite=unittest.TestSuite()\n for fn in os.listdir(here):\n  if fn.startswith(\"test\")and fn.endswith(\".py\"):\n   modname=\"unittest.test.testmock.\"+fn[:-3]\n   __import__(modname)\n   module=sys.modules[modname]\n   suite.addTest(loader.loadTestsFromModule(module))\n return suite\n", 1], "unittest.test.test_functiontestcase": ["import unittest\nfrom.support import LoggingResult\nclass Test_FunctionTestCase(unittest.TestCase):\n def test_countTestCases(self):\n  test=unittest.FunctionTestCase(lambda:None)\n  self.assertEqual(test.countTestCases(),1)\n def test_run_call_order__error_in_setUp(self):\n  events=[]\n  result=LoggingResult(events)\n  def setUp():\n   events.append('setUp')\n   raise RuntimeError('raised by setUp')\n  def test():\n   events.append('test')\n  def tearDown():\n   events.append('tearDown')\n  expected=['startTest','setUp','addError','stopTest']\n  unittest.FunctionTestCase(test,setUp,tearDown).run(result)\n  self.assertEqual(events,expected)\n def test_run_call_order__error_in_test(self):\n  events=[]\n  result=LoggingResult(events)\n  def setUp():\n   events.append('setUp')\n  def test():\n   events.append('test')\n   raise RuntimeError('raised by test')\n  def tearDown():\n   events.append('tearDown')\n  expected=['startTest','setUp','test','tearDown',\n  'addError','stopTest']\n  unittest.FunctionTestCase(test,setUp,tearDown).run(result)\n  self.assertEqual(events,expected)\n def test_run_call_order__failure_in_test(self):\n  events=[]\n  result=LoggingResult(events)\n  def setUp():\n   events.append('setUp')\n  def test():\n   events.append('test')\n   self.fail('raised by test')\n  def tearDown():\n   events.append('tearDown')\n  expected=['startTest','setUp','test','tearDown',\n  'addFailure','stopTest']\n  unittest.FunctionTestCase(test,setUp,tearDown).run(result)\n  self.assertEqual(events,expected)\n def test_run_call_order__error_in_tearDown(self):\n  events=[]\n  result=LoggingResult(events)\n  def setUp():\n   events.append('setUp')\n  def test():\n   events.append('test')\n  def tearDown():\n   events.append('tearDown')\n   raise RuntimeError('raised by tearDown')\n  expected=['startTest','setUp','test','tearDown','addError',\n  'stopTest']\n  unittest.FunctionTestCase(test,setUp,tearDown).run(result)\n  self.assertEqual(events,expected)\n def test_id(self):\n  test=unittest.FunctionTestCase(lambda:None)\n  self.assertIsInstance(test.id(),str)\n def test_shortDescription__no_docstring(self):\n  test=unittest.FunctionTestCase(lambda:None)\n  self.assertEqual(test.shortDescription(),None)\n def test_shortDescription__singleline_docstring(self):\n  desc=\"this tests foo\"\n  test=unittest.FunctionTestCase(lambda:None,description=desc)\n  self.assertEqual(test.shortDescription(),\"this tests foo\")\n"], "unittest.test.test_result": ["import io\nimport sys\nimport textwrap\nfrom test import support\nimport traceback\nimport unittest\nclass Test_TestResult(unittest.TestCase):\n def test_init(self):\n  result=unittest.TestResult()\n  self.assertTrue(result.wasSuccessful())\n  self.assertEqual(len(result.errors),0)\n  self.assertEqual(len(result.failures),0)\n  self.assertEqual(result.testsRun,0)\n  self.assertEqual(result.shouldStop,False)\n  self.assertIsNone(result._stdout_buffer)\n  self.assertIsNone(result._stderr_buffer)\n def test_stop(self):\n  result=unittest.TestResult()\n  result.stop()\n  self.assertEqual(result.shouldStop,True)\n def test_startTest(self):\n  class Foo(unittest.TestCase):\n   def test_1(self):\n    pass\n  test=Foo('test_1')\n  result=unittest.TestResult()\n  result.startTest(test)\n  self.assertTrue(result.wasSuccessful())\n  self.assertEqual(len(result.errors),0)\n  self.assertEqual(len(result.failures),0)\n  self.assertEqual(result.testsRun,1)\n  self.assertEqual(result.shouldStop,False)\n  result.stopTest(test)\n def test_stopTest(self):\n  class Foo(unittest.TestCase):\n   def test_1(self):\n    pass\n  test=Foo('test_1')\n  result=unittest.TestResult()\n  result.startTest(test)\n  self.assertTrue(result.wasSuccessful())\n  self.assertEqual(len(result.errors),0)\n  self.assertEqual(len(result.failures),0)\n  self.assertEqual(result.testsRun,1)\n  self.assertEqual(result.shouldStop,False)\n  result.stopTest(test)\n  self.assertTrue(result.wasSuccessful())\n  self.assertEqual(len(result.errors),0)\n  self.assertEqual(len(result.failures),0)\n  self.assertEqual(result.testsRun,1)\n  self.assertEqual(result.shouldStop,False)\n def test_startTestRun_stopTestRun(self):\n  result=unittest.TestResult()\n  result.startTestRun()\n  result.stopTestRun()\n def test_addSuccess(self):\n  class Foo(unittest.TestCase):\n   def test_1(self):\n    pass\n  test=Foo('test_1')\n  result=unittest.TestResult()\n  result.startTest(test)\n  result.addSuccess(test)\n  result.stopTest(test)\n  self.assertTrue(result.wasSuccessful())\n  self.assertEqual(len(result.errors),0)\n  self.assertEqual(len(result.failures),0)\n  self.assertEqual(result.testsRun,1)\n  self.assertEqual(result.shouldStop,False)\n def test_addFailure(self):\n  class Foo(unittest.TestCase):\n   def test_1(self):\n    pass\n  test=Foo('test_1')\n  try:\n   test.fail(\"foo\")\n  except:\n   exc_info_tuple=sys.exc_info()\n  result=unittest.TestResult()\n  result.startTest(test)\n  result.addFailure(test,exc_info_tuple)\n  result.stopTest(test)\n  self.assertFalse(result.wasSuccessful())\n  self.assertEqual(len(result.errors),0)\n  self.assertEqual(len(result.failures),1)\n  self.assertEqual(result.testsRun,1)\n  self.assertEqual(result.shouldStop,False)\n  test_case,formatted_exc=result.failures[0]\n  self.assertTrue(test_case is test)\n  self.assertIsInstance(formatted_exc,str)\n def test_addError(self):\n  class Foo(unittest.TestCase):\n   def test_1(self):\n    pass\n  test=Foo('test_1')\n  try:\n   raise TypeError()\n  except:\n   exc_info_tuple=sys.exc_info()\n  result=unittest.TestResult()\n  result.startTest(test)\n  result.addError(test,exc_info_tuple)\n  result.stopTest(test)\n  self.assertFalse(result.wasSuccessful())\n  self.assertEqual(len(result.errors),1)\n  self.assertEqual(len(result.failures),0)\n  self.assertEqual(result.testsRun,1)\n  self.assertEqual(result.shouldStop,False)\n  test_case,formatted_exc=result.errors[0]\n  self.assertTrue(test_case is test)\n  self.assertIsInstance(formatted_exc,str)\n def testGetDescriptionWithoutDocstring(self):\n  result=unittest.TextTestResult(None,True,1)\n  self.assertEqual(\n  result.getDescription(self),\n  'testGetDescriptionWithoutDocstring ('+__name__+\n  '.Test_TestResult)')\n @unittest.skipIf(sys.flags.optimize>=2,\n \"Docstrings are omitted with -O2 and above\")\n def testGetDescriptionWithOneLineDocstring(self):\n  result=unittest.TextTestResult(None,True,1)\n  self.assertEqual(\n  result.getDescription(self),\n  ('testGetDescriptionWithOneLineDocstring '\n  '('+__name__+'.Test_TestResult)\\n'\n  'Tests getDescription() for a method with a docstring.'))\n @unittest.skipIf(sys.flags.optimize>=2,\n \"Docstrings are omitted with -O2 and above\")\n def testGetDescriptionWithMultiLineDocstring(self):\n  ''  \n  result=unittest.TextTestResult(None,True,1)\n  self.assertEqual(\n  result.getDescription(self),\n  ('testGetDescriptionWithMultiLineDocstring '\n  '('+__name__+'.Test_TestResult)\\n'\n  'Tests getDescription() for a method with a longer '\n  'docstring.'))\n def testStackFrameTrimming(self):\n  class Frame(object):\n   class tb_frame(object):\n    f_globals={}\n  result=unittest.TestResult()\n  self.assertFalse(result._is_relevant_tb_level(Frame))\n  Frame.tb_frame.f_globals['__unittest']=True\n  self.assertTrue(result._is_relevant_tb_level(Frame))\n def testFailFast(self):\n  result=unittest.TestResult()\n  result._exc_info_to_string=lambda*_:''\n  result.failfast=True\n  result.addError(None,None)\n  self.assertTrue(result.shouldStop)\n  result=unittest.TestResult()\n  result._exc_info_to_string=lambda*_:''\n  result.failfast=True\n  result.addFailure(None,None)\n  self.assertTrue(result.shouldStop)\n  result=unittest.TestResult()\n  result._exc_info_to_string=lambda*_:''\n  result.failfast=True\n  result.addUnexpectedSuccess(None)\n  self.assertTrue(result.shouldStop)\n def testFailFastSetByRunner(self):\n  runner=unittest.TextTestRunner(stream=io.StringIO(),failfast=True)\n  def test(result):\n   self.assertTrue(result.failfast)\n  result=runner.run(test)\nclassDict=dict(unittest.TestResult.__dict__)\nfor m in('addSkip','addExpectedFailure','addUnexpectedSuccess',\n'__init__'):\n del classDict[m]\ndef __init__(self,stream=None,descriptions=None,verbosity=None):\n self.failures=[]\n self.errors=[]\n self.testsRun=0\n self.shouldStop=False\n self.buffer=False\nclassDict['__init__']=__init__\nOldResult=type('OldResult',(object,),classDict)\nclass Test_OldTestResult(unittest.TestCase):\n def assertOldResultWarning(self,test,failures):\n  with support.check_warnings((\"TestResult has no add.+ method,\",\n  RuntimeWarning)):\n   result=OldResult()\n   test.run(result)\n   self.assertEqual(len(result.failures),failures)\n def testOldTestResult(self):\n  class Test(unittest.TestCase):\n   def testSkip(self):\n    self.skipTest('foobar')\n   @unittest.expectedFailure\n   def testExpectedFail(self):\n    raise TypeError\n   @unittest.expectedFailure\n   def testUnexpectedSuccess(self):\n    pass\n  for test_name,should_pass in(('testSkip',True),\n  ('testExpectedFail',True),\n  ('testUnexpectedSuccess',False)):\n   test=Test(test_name)\n   self.assertOldResultWarning(test,int(not should_pass))\n def testOldTestTesultSetup(self):\n  class Test(unittest.TestCase):\n   def setUp(self):\n    self.skipTest('no reason')\n   def testFoo(self):\n    pass\n  self.assertOldResultWarning(Test('testFoo'),0)\n def testOldTestResultClass(self):\n  @unittest.skip('no reason')\n  class Test(unittest.TestCase):\n   def testFoo(self):\n    pass\n  self.assertOldResultWarning(Test('testFoo'),0)\n def testOldResultWithRunner(self):\n  class Test(unittest.TestCase):\n   def testFoo(self):\n    pass\n  runner=unittest.TextTestRunner(resultclass=OldResult,\n  stream=io.StringIO())\n  runner.run(Test('testFoo'))\nclass MockTraceback(object):\n @staticmethod\n def format_exception(*_):\n  return['A traceback']\ndef restore_traceback():\n unittest.result.traceback=traceback\nclass TestOutputBuffering(unittest.TestCase):\n def setUp(self):\n  self._real_out=sys.stdout\n  self._real_err=sys.stderr\n def tearDown(self):\n  sys.stdout=self._real_out\n  sys.stderr=self._real_err\n def testBufferOutputOff(self):\n  real_out=self._real_out\n  real_err=self._real_err\n  result=unittest.TestResult()\n  self.assertFalse(result.buffer)\n  self.assertIs(real_out,sys.stdout)\n  self.assertIs(real_err,sys.stderr)\n  result.startTest(self)\n  self.assertIs(real_out,sys.stdout)\n  self.assertIs(real_err,sys.stderr)\n def testBufferOutputStartTestAddSuccess(self):\n  real_out=self._real_out\n  real_err=self._real_err\n  result=unittest.TestResult()\n  self.assertFalse(result.buffer)\n  result.buffer=True\n  self.assertIs(real_out,sys.stdout)\n  self.assertIs(real_err,sys.stderr)\n  result.startTest(self)\n  self.assertIsNot(real_out,sys.stdout)\n  self.assertIsNot(real_err,sys.stderr)\n  self.assertIsInstance(sys.stdout,io.StringIO)\n  self.assertIsInstance(sys.stderr,io.StringIO)\n  self.assertIsNot(sys.stdout,sys.stderr)\n  out_stream=sys.stdout\n  err_stream=sys.stderr\n  result._original_stdout=io.StringIO()\n  result._original_stderr=io.StringIO()\n  print('foo')\n  print('bar',file=sys.stderr)\n  self.assertEqual(out_stream.getvalue(),'foo\\n')\n  self.assertEqual(err_stream.getvalue(),'bar\\n')\n  self.assertEqual(result._original_stdout.getvalue(),'')\n  self.assertEqual(result._original_stderr.getvalue(),'')\n  result.addSuccess(self)\n  result.stopTest(self)\n  self.assertIs(sys.stdout,result._original_stdout)\n  self.assertIs(sys.stderr,result._original_stderr)\n  self.assertEqual(result._original_stdout.getvalue(),'')\n  self.assertEqual(result._original_stderr.getvalue(),'')\n  self.assertEqual(out_stream.getvalue(),'')\n  self.assertEqual(err_stream.getvalue(),'')\n def getStartedResult(self):\n  result=unittest.TestResult()\n  result.buffer=True\n  result.startTest(self)\n  return result\n def testBufferOutputAddErrorOrFailure(self):\n  unittest.result.traceback=MockTraceback\n  self.addCleanup(restore_traceback)\n  for message_attr,add_attr,include_error in[\n  ('errors','addError',True),\n  ('failures','addFailure',False),\n  ('errors','addError',True),\n  ('failures','addFailure',False)\n  ]:\n   result=self.getStartedResult()\n   buffered_out=sys.stdout\n   buffered_err=sys.stderr\n   result._original_stdout=io.StringIO()\n   result._original_stderr=io.StringIO()\n   print('foo',file=sys.stdout)\n   if include_error:\n    print('bar',file=sys.stderr)\n   addFunction=getattr(result,add_attr)\n   addFunction(self,(None,None,None))\n   result.stopTest(self)\n   result_list=getattr(result,message_attr)\n   self.assertEqual(len(result_list),1)\n   test,message=result_list[0]\n   expectedOutMessage=textwrap.dedent(\"\"\"\n                Stdout:\n                foo\n            \"\"\")\n   expectedErrMessage=''\n   if include_error:\n    expectedErrMessage=textwrap.dedent(\"\"\"\n                Stderr:\n                bar\n            \"\"\")\n   expectedFullMessage='A traceback%s%s'%(expectedOutMessage,expectedErrMessage)\n   self.assertIs(test,self)\n   self.assertEqual(result._original_stdout.getvalue(),expectedOutMessage)\n   self.assertEqual(result._original_stderr.getvalue(),expectedErrMessage)\n   self.assertMultiLineEqual(message,expectedFullMessage)\n def testBufferSetupClass(self):\n  result=unittest.TestResult()\n  result.buffer=True\n  class Foo(unittest.TestCase):\n   @classmethod\n   def setUpClass(cls):\n    1/0\n   def test_foo(self):\n    pass\n  suite=unittest.TestSuite([Foo('test_foo')])\n  suite(result)\n  self.assertEqual(len(result.errors),1)\n def testBufferTearDownClass(self):\n  result=unittest.TestResult()\n  result.buffer=True\n  class Foo(unittest.TestCase):\n   @classmethod\n   def tearDownClass(cls):\n    1/0\n   def test_foo(self):\n    pass\n  suite=unittest.TestSuite([Foo('test_foo')])\n  suite(result)\n  self.assertEqual(len(result.errors),1)\n def testBufferSetUpModule(self):\n  result=unittest.TestResult()\n  result.buffer=True\n  class Foo(unittest.TestCase):\n   def test_foo(self):\n    pass\n  class Module(object):\n   @staticmethod\n   def setUpModule():\n    1/0\n  Foo.__module__='Module'\n  sys.modules['Module']=Module\n  self.addCleanup(sys.modules.pop,'Module')\n  suite=unittest.TestSuite([Foo('test_foo')])\n  suite(result)\n  self.assertEqual(len(result.errors),1)\n def testBufferTearDownModule(self):\n  result=unittest.TestResult()\n  result.buffer=True\n  class Foo(unittest.TestCase):\n   def test_foo(self):\n    pass\n  class Module(object):\n   @staticmethod\n   def tearDownModule():\n    1/0\n  Foo.__module__='Module'\n  sys.modules['Module']=Module\n  self.addCleanup(sys.modules.pop,'Module')\n  suite=unittest.TestSuite([Foo('test_foo')])\n  suite(result)\n  self.assertEqual(len(result.errors),1)\nif __name__=='__main__':\n unittest.main()\n"], "unittest.test.test_assertions": ["import datetime\nimport warnings\nimport unittest\nfrom itertools import product\nclass Test_Assertions(unittest.TestCase):\n def test_AlmostEqual(self):\n  self.assertAlmostEqual(1.00000001,1.0)\n  self.assertNotAlmostEqual(1.0000001,1.0)\n  self.assertRaises(self.failureException,\n  self.assertAlmostEqual,1.0000001,1.0)\n  self.assertRaises(self.failureException,\n  self.assertNotAlmostEqual,1.00000001,1.0)\n  self.assertAlmostEqual(1.1,1.0,places=0)\n  self.assertRaises(self.failureException,\n  self.assertAlmostEqual,1.1,1.0,places=1)\n  self.assertAlmostEqual(0,.1+.1j,places=0)\n  self.assertNotAlmostEqual(0,.1+.1j,places=1)\n  self.assertRaises(self.failureException,\n  self.assertAlmostEqual,0,.1+.1j,places=1)\n  self.assertRaises(self.failureException,\n  self.assertNotAlmostEqual,0,.1+.1j,places=0)\n  self.assertAlmostEqual(float('inf'),float('inf'))\n  self.assertRaises(self.failureException,self.assertNotAlmostEqual,\n  float('inf'),float('inf'))\n def test_AmostEqualWithDelta(self):\n  self.assertAlmostEqual(1.1,1.0,delta=0.5)\n  self.assertAlmostEqual(1.0,1.1,delta=0.5)\n  self.assertNotAlmostEqual(1.1,1.0,delta=0.05)\n  self.assertNotAlmostEqual(1.0,1.1,delta=0.05)\n  self.assertRaises(self.failureException,self.assertAlmostEqual,\n  1.1,1.0,delta=0.05)\n  self.assertRaises(self.failureException,self.assertNotAlmostEqual,\n  1.1,1.0,delta=0.5)\n  self.assertRaises(TypeError,self.assertAlmostEqual,\n  1.1,1.0,places=2,delta=2)\n  self.assertRaises(TypeError,self.assertNotAlmostEqual,\n  1.1,1.0,places=2,delta=2)\n  first=datetime.datetime.now()\n  second=first+datetime.timedelta(seconds=10)\n  self.assertAlmostEqual(first,second,\n  delta=datetime.timedelta(seconds=20))\n  self.assertNotAlmostEqual(first,second,\n  delta=datetime.timedelta(seconds=5))\n def test_assertRaises(self):\n  def _raise(e):\n   raise e\n  self.assertRaises(KeyError,_raise,KeyError)\n  self.assertRaises(KeyError,_raise,KeyError(\"key\"))\n  try:\n   self.assertRaises(KeyError,lambda:None)\n  except self.failureException as e:\n   self.assertIn(\"KeyError not raised\",str(e))\n  else:\n   self.fail(\"assertRaises() didn't fail\")\n  try:\n   self.assertRaises(KeyError,_raise,ValueError)\n  except ValueError:\n   pass\n  else:\n   self.fail(\"assertRaises() didn't let exception pass through\")\n  with self.assertRaises(KeyError)as cm:\n   try:\n    raise KeyError\n   except Exception as e:\n    exc=e\n    raise\n  self.assertIs(cm.exception,exc)\n  with self.assertRaises(KeyError):\n   raise KeyError(\"key\")\n  try:\n   with self.assertRaises(KeyError):\n    pass\n  except self.failureException as e:\n   self.assertIn(\"KeyError not raised\",str(e))\n  else:\n   self.fail(\"assertRaises() didn't fail\")\n  try:\n   with self.assertRaises(KeyError):\n    raise ValueError\n  except ValueError:\n   pass\n  else:\n   self.fail(\"assertRaises() didn't let exception pass through\")\n def testAssertNotRegex(self):\n  self.assertNotRegex('Ala ma kota',r'r+')\n  try:\n   self.assertNotRegex('Ala ma kota',r'k.t','Message')\n  except self.failureException as e:\n   self.assertIn(\"'kot'\",e.args[0])\n   self.assertIn('Message',e.args[0])\n  else:\n   self.fail('assertNotRegex should have failed.')\nclass TestLongMessage(unittest.TestCase):\n '' \n def setUp(self):\n  class TestableTestFalse(unittest.TestCase):\n   longMessage=False\n   failureException=self.failureException\n   def testTest(self):\n    pass\n  class TestableTestTrue(unittest.TestCase):\n   longMessage=True\n   failureException=self.failureException\n   def testTest(self):\n    pass\n  self.testableTrue=TestableTestTrue('testTest')\n  self.testableFalse=TestableTestFalse('testTest')\n def testDefault(self):\n  self.assertTrue(unittest.TestCase.longMessage)\n def test_formatMsg(self):\n  self.assertEqual(self.testableFalse._formatMessage(None,\"foo\"),\"foo\")\n  self.assertEqual(self.testableFalse._formatMessage(\"foo\",\"bar\"),\"foo\")\n  self.assertEqual(self.testableTrue._formatMessage(None,\"foo\"),\"foo\")\n  self.assertEqual(self.testableTrue._formatMessage(\"foo\",\"bar\"),\"bar : foo\")\n  self.testableTrue._formatMessage(object(),'foo')\n def test_formatMessage_unicode_error(self):\n  one=''.join(chr(i)for i in range(255))\n  self.testableTrue._formatMessage(one,'\\uFFFD')\n def assertMessages(self,methodName,args,errors):\n  ''  \n  def getMethod(i):\n   useTestableFalse=i<2\n   if useTestableFalse:\n    test=self.testableFalse\n   else:\n    test=self.testableTrue\n   return getattr(test,methodName)\n  for i,expected_regex in enumerate(errors):\n   testMethod=getMethod(i)\n   kwargs={}\n   withMsg=i%2\n   if withMsg:\n    kwargs={\"msg\":\"oops\"}\n   with self.assertRaisesRegex(self.failureException,\n   expected_regex=expected_regex):\n    testMethod(*args,**kwargs)\n def testAssertTrue(self):\n  self.assertMessages('assertTrue',(False,),\n  [\"^False is not true$\",\"^oops$\",\"^False is not true$\",\n  \"^False is not true : oops$\"])\n def testAssertFalse(self):\n  self.assertMessages('assertFalse',(True,),\n  [\"^True is not false$\",\"^oops$\",\"^True is not false$\",\n  \"^True is not false : oops$\"])\n def testNotEqual(self):\n  self.assertMessages('assertNotEqual',(1,1),\n  [\"^1 == 1$\",\"^oops$\",\"^1 == 1$\",\n  \"^1 == 1 : oops$\"])\n def testAlmostEqual(self):\n  self.assertMessages('assertAlmostEqual',(1,2),\n  [\"^1 != 2 within 7 places$\",\"^oops$\",\n  \"^1 != 2 within 7 places$\",\"^1 != 2 within 7 places : oops$\"])\n def testNotAlmostEqual(self):\n  self.assertMessages('assertNotAlmostEqual',(1,1),\n  [\"^1 == 1 within 7 places$\",\"^oops$\",\n  \"^1 == 1 within 7 places$\",\"^1 == 1 within 7 places : oops$\"])\n def test_baseAssertEqual(self):\n  self.assertMessages('_baseAssertEqual',(1,2),\n  [\"^1 != 2$\",\"^oops$\",\"^1 != 2$\",\"^1 != 2 : oops$\"])\n def testAssertSequenceEqual(self):\n  self.assertMessages('assertSequenceEqual',([],[None]),\n  [\"\\+ \\[None\\]$\",\"^oops$\",r\"\\+ \\[None\\]$\",\n  r\"\\+ \\[None\\] : oops$\"])\n def testAssertSetEqual(self):\n  self.assertMessages('assertSetEqual',(set(),set([None])),\n  [\"None$\",\"^oops$\",\"None$\",\n  \"None : oops$\"])\n def testAssertIn(self):\n  self.assertMessages('assertIn',(None,[]),\n  ['^None not found in \\[\\]$',\"^oops$\",\n  '^None not found in \\[\\]$',\n  '^None not found in \\[\\] : oops$'])\n def testAssertNotIn(self):\n  self.assertMessages('assertNotIn',(None,[None]),\n  ['^None unexpectedly found in \\[None\\]$',\"^oops$\",\n  '^None unexpectedly found in \\[None\\]$',\n  '^None unexpectedly found in \\[None\\] : oops$'])\n def testAssertDictEqual(self):\n  self.assertMessages('assertDictEqual',({},{'key':'value'}),\n  [r\"\\+ \\{'key': 'value'\\}$\",\"^oops$\",\n  \"\\+ \\{'key': 'value'\\}$\",\n  \"\\+ \\{'key': 'value'\\} : oops$\"])\n def testAssertDictContainsSubset(self):\n  with warnings.catch_warnings():\n   warnings.simplefilter(\"ignore\",DeprecationWarning)\n   self.assertMessages('assertDictContainsSubset',({'key':'value'},{}),\n   [\"^Missing: 'key'$\",\"^oops$\",\n   \"^Missing: 'key'$\",\n   \"^Missing: 'key' : oops$\"])\n def testAssertMultiLineEqual(self):\n  self.assertMessages('assertMultiLineEqual',(\"\",\"foo\"),\n  [r\"\\+ foo$\",\"^oops$\",\n  r\"\\+ foo$\",\n  r\"\\+ foo : oops$\"])\n def testAssertLess(self):\n  self.assertMessages('assertLess',(2,1),\n  [\"^2 not less than 1$\",\"^oops$\",\n  \"^2 not less than 1$\",\"^2 not less than 1 : oops$\"])\n def testAssertLessEqual(self):\n  self.assertMessages('assertLessEqual',(2,1),\n  [\"^2 not less than or equal to 1$\",\"^oops$\",\n  \"^2 not less than or equal to 1$\",\n  \"^2 not less than or equal to 1 : oops$\"])\n def testAssertGreater(self):\n  self.assertMessages('assertGreater',(1,2),\n  [\"^1 not greater than 2$\",\"^oops$\",\n  \"^1 not greater than 2$\",\n  \"^1 not greater than 2 : oops$\"])\n def testAssertGreaterEqual(self):\n  self.assertMessages('assertGreaterEqual',(1,2),\n  [\"^1 not greater than or equal to 2$\",\"^oops$\",\n  \"^1 not greater than or equal to 2$\",\n  \"^1 not greater than or equal to 2 : oops$\"])\n def testAssertIsNone(self):\n  self.assertMessages('assertIsNone',('not None',),\n  [\"^'not None' is not None$\",\"^oops$\",\n  \"^'not None' is not None$\",\n  \"^'not None' is not None : oops$\"])\n def testAssertIsNotNone(self):\n  self.assertMessages('assertIsNotNone',(None,),\n  [\"^unexpectedly None$\",\"^oops$\",\n  \"^unexpectedly None$\",\n  \"^unexpectedly None : oops$\"])\n def testAssertIs(self):\n  self.assertMessages('assertIs',(None,'foo'),\n  [\"^None is not 'foo'$\",\"^oops$\",\n  \"^None is not 'foo'$\",\n  \"^None is not 'foo' : oops$\"])\n def testAssertIsNot(self):\n  self.assertMessages('assertIsNot',(None,None),\n  [\"^unexpectedly identical: None$\",\"^oops$\",\n  \"^unexpectedly identical: None$\",\n  \"^unexpectedly identical: None : oops$\"])\n def assertMessagesCM(self,methodName,args,func,errors):\n  ''  \n  p=product((self.testableFalse,self.testableTrue),\n  ({},{\"msg\":\"oops\"}))\n  for(cls,kwargs),err in zip(p,errors):\n   method=getattr(cls,methodName)\n   with self.assertRaisesRegex(cls.failureException,err):\n    with method(*args,**kwargs)as cm:\n     func()\n def testAssertRaises(self):\n  self.assertMessagesCM('assertRaises',(TypeError,),lambda:None,\n  ['^TypeError not raised$','^oops$',\n  '^TypeError not raised$',\n  '^TypeError not raised : oops$'])\n def testAssertRaisesRegex(self):\n  self.assertMessagesCM('assertRaisesRegex',(TypeError,'unused regex'),\n  lambda:None,\n  ['^TypeError not raised$','^oops$',\n  '^TypeError not raised$',\n  '^TypeError not raised : oops$'])\n  def raise_wrong_message():\n   raise TypeError('foo')\n  self.assertMessagesCM('assertRaisesRegex',(TypeError,'regex'),\n  raise_wrong_message,\n  ['^\"regex\" does not match \"foo\"$','^oops$',\n  '^\"regex\" does not match \"foo\"$',\n  '^\"regex\" does not match \"foo\" : oops$'])\n def testAssertWarns(self):\n  self.assertMessagesCM('assertWarns',(UserWarning,),lambda:None,\n  ['^UserWarning not triggered$','^oops$',\n  '^UserWarning not triggered$',\n  '^UserWarning not triggered : oops$'])\n def testAssertWarnsRegex(self):\n  self.assertMessagesCM('assertWarnsRegex',(UserWarning,'unused regex'),\n  lambda:None,\n  ['^UserWarning not triggered$','^oops$',\n  '^UserWarning not triggered$',\n  '^UserWarning not triggered : oops$'])\n  def raise_wrong_message():\n   warnings.warn('foo')\n  self.assertMessagesCM('assertWarnsRegex',(UserWarning,'regex'),\n  raise_wrong_message,\n  ['^\"regex\" does not match \"foo\"$','^oops$',\n  '^\"regex\" does not match \"foo\"$',\n  '^\"regex\" does not match \"foo\" : oops$'])\n"], "unittest.test.testmock.testwith": ["import unittest\nfrom warnings import catch_warnings\nfrom unittest.test.testmock.support import is_instance\nfrom unittest.mock import MagicMock,Mock,patch,sentinel,mock_open,call\nsomething=sentinel.Something\nsomething_else=sentinel.SomethingElse\nclass WithTest(unittest.TestCase):\n def test_with_statement(self):\n  with patch('%s.something'%__name__,sentinel.Something2):\n   self.assertEqual(something,sentinel.Something2,\"unpatched\")\n  self.assertEqual(something,sentinel.Something)\n def test_with_statement_exception(self):\n  try:\n   with patch('%s.something'%__name__,sentinel.Something2):\n    self.assertEqual(something,sentinel.Something2,\"unpatched\")\n    raise Exception('pow')\n  except Exception:\n   pass\n  else:\n   self.fail(\"patch swallowed exception\")\n  self.assertEqual(something,sentinel.Something)\n def test_with_statement_as(self):\n  with patch('%s.something'%__name__)as mock_something:\n   self.assertEqual(something,mock_something,\"unpatched\")\n   self.assertTrue(is_instance(mock_something,MagicMock),\n   \"patching wrong type\")\n  self.assertEqual(something,sentinel.Something)\n def test_patch_object_with_statement(self):\n  class Foo(object):\n   something='foo'\n  original=Foo.something\n  with patch.object(Foo,'something'):\n   self.assertNotEqual(Foo.something,original,\"unpatched\")\n  self.assertEqual(Foo.something,original)\n def test_with_statement_nested(self):\n  with catch_warnings(record=True):\n   with patch('%s.something'%__name__)as mock_something,patch('%s.something_else'%__name__)as mock_something_else:\n    self.assertEqual(something,mock_something,\"unpatched\")\n    self.assertEqual(something_else,mock_something_else,\n    \"unpatched\")\n  self.assertEqual(something,sentinel.Something)\n  self.assertEqual(something_else,sentinel.SomethingElse)\n def test_with_statement_specified(self):\n  with patch('%s.something'%__name__,sentinel.Patched)as mock_something:\n   self.assertEqual(something,mock_something,\"unpatched\")\n   self.assertEqual(mock_something,sentinel.Patched,\"wrong patch\")\n  self.assertEqual(something,sentinel.Something)\n def testContextManagerMocking(self):\n  mock=Mock()\n  mock.__enter__=Mock()\n  mock.__exit__=Mock()\n  mock.__exit__.return_value=False\n  with mock as m:\n   self.assertEqual(m,mock.__enter__.return_value)\n  mock.__enter__.assert_called_with()\n  mock.__exit__.assert_called_with(None,None,None)\n def test_context_manager_with_magic_mock(self):\n  mock=MagicMock()\n  with self.assertRaises(TypeError):\n   with mock:\n    ''+3\n  mock.__enter__.assert_called_with()\n  self.assertTrue(mock.__exit__.called)\n def test_with_statement_same_attribute(self):\n  with patch('%s.something'%__name__,sentinel.Patched)as mock_something:\n   self.assertEqual(something,mock_something,\"unpatched\")\n   with patch('%s.something'%__name__)as mock_again:\n    self.assertEqual(something,mock_again,\"unpatched\")\n   self.assertEqual(something,mock_something,\n   \"restored with wrong instance\")\n  self.assertEqual(something,sentinel.Something,\"not restored\")\n def test_with_statement_imbricated(self):\n  with patch('%s.something'%__name__)as mock_something:\n   self.assertEqual(something,mock_something,\"unpatched\")\n   with patch('%s.something_else'%__name__)as mock_something_else:\n    self.assertEqual(something_else,mock_something_else,\n    \"unpatched\")\n  self.assertEqual(something,sentinel.Something)\n  self.assertEqual(something_else,sentinel.SomethingElse)\n def test_dict_context_manager(self):\n  foo={}\n  with patch.dict(foo,{'a':'b'}):\n   self.assertEqual(foo,{'a':'b'})\n  self.assertEqual(foo,{})\n  with self.assertRaises(NameError):\n   with patch.dict(foo,{'a':'b'}):\n    self.assertEqual(foo,{'a':'b'})\n    raise NameError('Konrad')\n  self.assertEqual(foo,{})\nclass TestMockOpen(unittest.TestCase):\n def test_mock_open(self):\n  mock=mock_open()\n  with patch('%s.open'%__name__,mock,create=True)as patched:\n   self.assertIs(patched,mock)\n   open('foo')\n  mock.assert_called_once_with('foo')\n def test_mock_open_context_manager(self):\n  mock=mock_open()\n  handle=mock.return_value\n  with patch('%s.open'%__name__,mock,create=True):\n   with open('foo')as f:\n    f.read()\n  expected_calls=[call('foo'),call().__enter__(),call().read(),\n  call().__exit__(None,None,None)]\n  self.assertEqual(mock.mock_calls,expected_calls)\n  self.assertIs(f,handle)\n def test_explicit_mock(self):\n  mock=MagicMock()\n  mock_open(mock)\n  with patch('%s.open'%__name__,mock,create=True)as patched:\n   self.assertIs(patched,mock)\n   open('foo')\n  mock.assert_called_once_with('foo')\n def test_read_data(self):\n  mock=mock_open(read_data='foo')\n  with patch('%s.open'%__name__,mock,create=True):\n   h=open('bar')\n   result=h.read()\n  self.assertEqual(result,'foo')\nif __name__=='__main__':\n unittest.main()\n"], "unittest.test.test_break": ["import gc\nimport io\nimport os\nimport sys\nimport signal\nimport weakref\nimport unittest\n@unittest.skipUnless(hasattr(os,'kill'),\"Test requires os.kill\")\n@unittest.skipIf(sys.platform==\"win32\",\"Test cannot run on Windows\")\n@unittest.skipIf(sys.platform=='freebsd6',\"Test kills regrtest on freebsd6 \"\n\"if threads have been used\")\nclass TestBreak(unittest.TestCase):\n def setUp(self):\n  self._default_handler=signal.getsignal(signal.SIGINT)\n def tearDown(self):\n  signal.signal(signal.SIGINT,self._default_handler)\n  unittest.signals._results=weakref.WeakKeyDictionary()\n  unittest.signals._interrupt_handler=None\n def testInstallHandler(self):\n  default_handler=signal.getsignal(signal.SIGINT)\n  unittest.installHandler()\n  self.assertNotEqual(signal.getsignal(signal.SIGINT),default_handler)\n  try:\n   pid=os.getpid()\n   os.kill(pid,signal.SIGINT)\n  except KeyboardInterrupt:\n   self.fail(\"KeyboardInterrupt not handled\")\n  self.assertTrue(unittest.signals._interrupt_handler.called)\n def testRegisterResult(self):\n  result=unittest.TestResult()\n  unittest.registerResult(result)\n  for ref in unittest.signals._results:\n   if ref is result:\n    break\n   elif ref is not result:\n    self.fail(\"odd object in result set\")\n  else:\n   self.fail(\"result not found\")\n def testInterruptCaught(self):\n  default_handler=signal.getsignal(signal.SIGINT)\n  result=unittest.TestResult()\n  unittest.installHandler()\n  unittest.registerResult(result)\n  self.assertNotEqual(signal.getsignal(signal.SIGINT),default_handler)\n  def test(result):\n   pid=os.getpid()\n   os.kill(pid,signal.SIGINT)\n   result.breakCaught=True\n   self.assertTrue(result.shouldStop)\n  try:\n   test(result)\n  except KeyboardInterrupt:\n   self.fail(\"KeyboardInterrupt not handled\")\n  self.assertTrue(result.breakCaught)\n def testSecondInterrupt(self):\n  result=unittest.TestResult()\n  unittest.installHandler()\n  unittest.registerResult(result)\n  def test(result):\n   pid=os.getpid()\n   os.kill(pid,signal.SIGINT)\n   result.breakCaught=True\n   self.assertTrue(result.shouldStop)\n   os.kill(pid,signal.SIGINT)\n   self.fail(\"Second KeyboardInterrupt not raised\")\n  try:\n   test(result)\n  except KeyboardInterrupt:\n   pass\n  else:\n   self.fail(\"Second KeyboardInterrupt not raised\")\n  self.assertTrue(result.breakCaught)\n def testTwoResults(self):\n  unittest.installHandler()\n  result=unittest.TestResult()\n  unittest.registerResult(result)\n  new_handler=signal.getsignal(signal.SIGINT)\n  result2=unittest.TestResult()\n  unittest.registerResult(result2)\n  self.assertEqual(signal.getsignal(signal.SIGINT),new_handler)\n  result3=unittest.TestResult()\n  def test(result):\n   pid=os.getpid()\n   os.kill(pid,signal.SIGINT)\n  try:\n   test(result)\n  except KeyboardInterrupt:\n   self.fail(\"KeyboardInterrupt not handled\")\n  self.assertTrue(result.shouldStop)\n  self.assertTrue(result2.shouldStop)\n  self.assertFalse(result3.shouldStop)\n def testHandlerReplacedButCalled(self):\n  unittest.installHandler()\n  handler=signal.getsignal(signal.SIGINT)\n  def new_handler(frame,signum):\n   handler(frame,signum)\n  signal.signal(signal.SIGINT,new_handler)\n  try:\n   pid=os.getpid()\n   os.kill(pid,signal.SIGINT)\n  except KeyboardInterrupt:\n   pass\n  else:\n   self.fail(\"replaced but delegated handler doesn't raise interrupt\")\n def testRunner(self):\n  runner=unittest.TextTestRunner(stream=io.StringIO())\n  result=runner.run(unittest.TestSuite())\n  self.assertIn(result,unittest.signals._results)\n def testWeakReferences(self):\n  result=unittest.TestResult()\n  unittest.registerResult(result)\n  ref=weakref.ref(result)\n  del result\n  gc.collect();gc.collect()\n  self.assertIsNone(ref())\n def testRemoveResult(self):\n  result=unittest.TestResult()\n  unittest.registerResult(result)\n  unittest.installHandler()\n  self.assertTrue(unittest.removeResult(result))\n  self.assertFalse(unittest.removeResult(unittest.TestResult()))\n  try:\n   pid=os.getpid()\n   os.kill(pid,signal.SIGINT)\n  except KeyboardInterrupt:\n   pass\n  self.assertFalse(result.shouldStop)\n def testMainInstallsHandler(self):\n  failfast=object()\n  test=object()\n  verbosity=object()\n  result=object()\n  default_handler=signal.getsignal(signal.SIGINT)\n  class FakeRunner(object):\n   initArgs=[]\n   runArgs=[]\n   def __init__(self,*args,**kwargs):\n    self.initArgs.append((args,kwargs))\n   def run(self,test):\n    self.runArgs.append(test)\n    return result\n  class Program(unittest.TestProgram):\n   def __init__(self,catchbreak):\n    self.exit=False\n    self.verbosity=verbosity\n    self.failfast=failfast\n    self.catchbreak=catchbreak\n    self.testRunner=FakeRunner\n    self.test=test\n    self.result=None\n  p=Program(False)\n  p.runTests()\n  self.assertEqual(FakeRunner.initArgs,[((),{'buffer':None,\n  'verbosity':verbosity,\n  'failfast':failfast,\n  'warnings':None})])\n  self.assertEqual(FakeRunner.runArgs,[test])\n  self.assertEqual(p.result,result)\n  self.assertEqual(signal.getsignal(signal.SIGINT),default_handler)\n  FakeRunner.initArgs=[]\n  FakeRunner.runArgs=[]\n  p=Program(True)\n  p.runTests()\n  self.assertEqual(FakeRunner.initArgs,[((),{'buffer':None,\n  'verbosity':verbosity,\n  'failfast':failfast,\n  'warnings':None})])\n  self.assertEqual(FakeRunner.runArgs,[test])\n  self.assertEqual(p.result,result)\n  self.assertNotEqual(signal.getsignal(signal.SIGINT),default_handler)\n def testRemoveHandler(self):\n  default_handler=signal.getsignal(signal.SIGINT)\n  unittest.installHandler()\n  unittest.removeHandler()\n  self.assertEqual(signal.getsignal(signal.SIGINT),default_handler)\n  unittest.removeHandler()\n  self.assertEqual(signal.getsignal(signal.SIGINT),default_handler)\n def testRemoveHandlerAsDecorator(self):\n  default_handler=signal.getsignal(signal.SIGINT)\n  unittest.installHandler()\n  @unittest.removeHandler\n  def test():\n   self.assertEqual(signal.getsignal(signal.SIGINT),default_handler)\n  test()\n  self.assertNotEqual(signal.getsignal(signal.SIGINT),default_handler)\n"], "unittest.test.test_case": ["import difflib\nimport pprint\nimport pickle\nimport re\nimport sys\nimport warnings\nimport weakref\nimport inspect\nfrom copy import deepcopy\nfrom test import support\nimport unittest\nfrom.support import(\nTestEquality,TestHashing,LoggingResult,\nResultWithNoStartTestRunStopTestRun\n)\nclass Test(object):\n class Foo(unittest.TestCase):\n  def runTest(self):pass\n  def test1(self):pass\n class Bar(Foo):\n  def test2(self):pass\n class LoggingTestCase(unittest.TestCase):\n  def __init__(self,events):\n   super(Test.LoggingTestCase,self).__init__('test')\n   self.events=events\n  def setUp(self):\n   self.events.append('setUp')\n  def test(self):\n   self.events.append('test')\n  def tearDown(self):\n   self.events.append('tearDown')\nclass Test_TestCase(unittest.TestCase,TestEquality,TestHashing):\n eq_pairs=[(Test.Foo('test1'),Test.Foo('test1'))]\n ne_pairs=[(Test.Foo('test1'),Test.Foo('runTest')),\n (Test.Foo('test1'),Test.Bar('test1')),\n (Test.Foo('test1'),Test.Bar('test2'))]\n def test_init__no_test_name(self):\n  class Test(unittest.TestCase):\n   def runTest(self):raise MyException()\n   def test(self):pass\n  self.assertEqual(Test().id()[-13:],'.Test.runTest')\n  test=unittest.TestCase()\n  test.assertEqual(3,3)\n  with test.assertRaises(test.failureException):\n   test.assertEqual(3,2)\n  with self.assertRaises(AttributeError):\n   test.run()\n def test_init__test_name__valid(self):\n  class Test(unittest.TestCase):\n   def runTest(self):raise MyException()\n   def test(self):pass\n  self.assertEqual(Test('test').id()[-10:],'.Test.test')\n def test_init__test_name__invalid(self):\n  class Test(unittest.TestCase):\n   def runTest(self):raise MyException()\n   def test(self):pass\n  try:\n   Test('testfoo')\n  except ValueError:\n   pass\n  else:\n   self.fail(\"Failed to raise ValueError\")\n def test_countTestCases(self):\n  class Foo(unittest.TestCase):\n   def test(self):pass\n  self.assertEqual(Foo('test').countTestCases(),1)\n def test_defaultTestResult(self):\n  class Foo(unittest.TestCase):\n   def runTest(self):\n    pass\n  result=Foo().defaultTestResult()\n  self.assertEqual(type(result),unittest.TestResult)\n def test_run_call_order__error_in_setUp(self):\n  events=[]\n  result=LoggingResult(events)\n  class Foo(Test.LoggingTestCase):\n   def setUp(self):\n    super(Foo,self).setUp()\n    raise RuntimeError('raised by Foo.setUp')\n  Foo(events).run(result)\n  expected=['startTest','setUp','addError','stopTest']\n  self.assertEqual(events,expected)\n def test_run_call_order__error_in_setUp_default_result(self):\n  events=[]\n  class Foo(Test.LoggingTestCase):\n   def defaultTestResult(self):\n    return LoggingResult(self.events)\n   def setUp(self):\n    super(Foo,self).setUp()\n    raise RuntimeError('raised by Foo.setUp')\n  Foo(events).run()\n  expected=['startTestRun','startTest','setUp','addError',\n  'stopTest','stopTestRun']\n  self.assertEqual(events,expected)\n def test_run_call_order__error_in_test(self):\n  events=[]\n  result=LoggingResult(events)\n  class Foo(Test.LoggingTestCase):\n   def test(self):\n    super(Foo,self).test()\n    raise RuntimeError('raised by Foo.test')\n  expected=['startTest','setUp','test','tearDown',\n  'addError','stopTest']\n  Foo(events).run(result)\n  self.assertEqual(events,expected)\n def test_run_call_order__error_in_test_default_result(self):\n  events=[]\n  class Foo(Test.LoggingTestCase):\n   def defaultTestResult(self):\n    return LoggingResult(self.events)\n   def test(self):\n    super(Foo,self).test()\n    raise RuntimeError('raised by Foo.test')\n  expected=['startTestRun','startTest','setUp','test',\n  'tearDown','addError','stopTest','stopTestRun']\n  Foo(events).run()\n  self.assertEqual(events,expected)\n def test_run_call_order__failure_in_test(self):\n  events=[]\n  result=LoggingResult(events)\n  class Foo(Test.LoggingTestCase):\n   def test(self):\n    super(Foo,self).test()\n    self.fail('raised by Foo.test')\n  expected=['startTest','setUp','test','tearDown',\n  'addFailure','stopTest']\n  Foo(events).run(result)\n  self.assertEqual(events,expected)\n def test_run_call_order__failure_in_test_default_result(self):\n  class Foo(Test.LoggingTestCase):\n   def defaultTestResult(self):\n    return LoggingResult(self.events)\n   def test(self):\n    super(Foo,self).test()\n    self.fail('raised by Foo.test')\n  expected=['startTestRun','startTest','setUp','test',\n  'tearDown','addFailure','stopTest','stopTestRun']\n  events=[]\n  Foo(events).run()\n  self.assertEqual(events,expected)\n def test_run_call_order__error_in_tearDown(self):\n  events=[]\n  result=LoggingResult(events)\n  class Foo(Test.LoggingTestCase):\n   def tearDown(self):\n    super(Foo,self).tearDown()\n    raise RuntimeError('raised by Foo.tearDown')\n  Foo(events).run(result)\n  expected=['startTest','setUp','test','tearDown','addError',\n  'stopTest']\n  self.assertEqual(events,expected)\n def test_run_call_order__error_in_tearDown_default_result(self):\n  class Foo(Test.LoggingTestCase):\n   def defaultTestResult(self):\n    return LoggingResult(self.events)\n   def tearDown(self):\n    super(Foo,self).tearDown()\n    raise RuntimeError('raised by Foo.tearDown')\n  events=[]\n  Foo(events).run()\n  expected=['startTestRun','startTest','setUp','test','tearDown',\n  'addError','stopTest','stopTestRun']\n  self.assertEqual(events,expected)\n def test_run_call_order_default_result(self):\n  class Foo(unittest.TestCase):\n   def defaultTestResult(self):\n    return ResultWithNoStartTestRunStopTestRun()\n   def test(self):\n    pass\n  Foo('test').run()\n def test_failureException__default(self):\n  class Foo(unittest.TestCase):\n   def test(self):\n    pass\n  self.assertTrue(Foo('test').failureException is AssertionError)\n def test_failureException__subclassing__explicit_raise(self):\n  events=[]\n  result=LoggingResult(events)\n  class Foo(unittest.TestCase):\n   def test(self):\n    raise RuntimeError()\n   failureException=RuntimeError\n  self.assertTrue(Foo('test').failureException is RuntimeError)\n  Foo('test').run(result)\n  expected=['startTest','addFailure','stopTest']\n  self.assertEqual(events,expected)\n def test_failureException__subclassing__implicit_raise(self):\n  events=[]\n  result=LoggingResult(events)\n  class Foo(unittest.TestCase):\n   def test(self):\n    self.fail(\"foo\")\n   failureException=RuntimeError\n  self.assertTrue(Foo('test').failureException is RuntimeError)\n  Foo('test').run(result)\n  expected=['startTest','addFailure','stopTest']\n  self.assertEqual(events,expected)\n def test_setUp(self):\n  class Foo(unittest.TestCase):\n   def runTest(self):\n    pass\n  Foo().setUp()\n def test_tearDown(self):\n  class Foo(unittest.TestCase):\n   def runTest(self):\n    pass\n  Foo().tearDown()\n def test_id(self):\n  class Foo(unittest.TestCase):\n   def runTest(self):\n    pass\n  self.assertIsInstance(Foo().id(),str)\n def test_run__uses_defaultTestResult(self):\n  events=[]\n  defaultResult=LoggingResult(events)\n  class Foo(unittest.TestCase):\n   def test(self):\n    events.append('test')\n   def defaultTestResult(self):\n    return defaultResult\n  result=Foo('test').run()\n  self.assertIs(result,defaultResult)\n  expected=['startTestRun','startTest','test','addSuccess',\n  'stopTest','stopTestRun']\n  self.assertEqual(events,expected)\n def test_run__returns_given_result(self):\n  class Foo(unittest.TestCase):\n   def test(self):\n    pass\n  result=unittest.TestResult()\n  retval=Foo('test').run(result)\n  self.assertIs(retval,result)\n def test_call__invoking_an_instance_delegates_to_run(self):\n  resultIn=unittest.TestResult()\n  resultOut=unittest.TestResult()\n  class Foo(unittest.TestCase):\n   def test(self):\n    pass\n   def run(self,result):\n    self.assertIs(result,resultIn)\n    return resultOut\n  retval=Foo('test')(resultIn)\n  self.assertIs(retval,resultOut)\n def testShortDescriptionWithoutDocstring(self):\n  self.assertIsNone(self.shortDescription())\n @unittest.skipIf(sys.flags.optimize>=2,\n \"Docstrings are omitted with -O2 and above\")\n def testShortDescriptionWithOneLineDocstring(self):\n  self.assertEqual(\n  self.shortDescription(),\n  'Tests shortDescription() for a method with a docstring.')\n @unittest.skipIf(sys.flags.optimize>=2,\n \"Docstrings are omitted with -O2 and above\")\n def testShortDescriptionWithMultiLineDocstring(self):\n  ''  \n  self.assertEqual(\n  self.shortDescription(),\n  'Tests shortDescription() for a method with a longer '\n  'docstring.')\n def testAddTypeEqualityFunc(self):\n  class SadSnake(object):\n   ''\n  s1,s2=SadSnake(),SadSnake()\n  self.assertFalse(s1==s2)\n  def AllSnakesCreatedEqual(a,b,msg=None):\n   return type(a)==type(b)==SadSnake\n  self.addTypeEqualityFunc(SadSnake,AllSnakesCreatedEqual)\n  self.assertEqual(s1,s2)\n def testAssertIs(self):\n  thing=object()\n  self.assertIs(thing,thing)\n  self.assertRaises(self.failureException,self.assertIs,thing,object())\n def testAssertIsNot(self):\n  thing=object()\n  self.assertIsNot(thing,object())\n  self.assertRaises(self.failureException,self.assertIsNot,thing,thing)\n def testAssertIsInstance(self):\n  thing=[]\n  self.assertIsInstance(thing,list)\n  self.assertRaises(self.failureException,self.assertIsInstance,\n  thing,dict)\n def testAssertNotIsInstance(self):\n  thing=[]\n  self.assertNotIsInstance(thing,dict)\n  self.assertRaises(self.failureException,self.assertNotIsInstance,\n  thing,list)\n def testAssertIn(self):\n  animals={'monkey':'banana','cow':'grass','seal':'fish'}\n  self.assertIn('a','abc')\n  self.assertIn(2,[1,2,3])\n  self.assertIn('monkey',animals)\n  self.assertNotIn('d','abc')\n  self.assertNotIn(0,[1,2,3])\n  self.assertNotIn('otter',animals)\n  self.assertRaises(self.failureException,self.assertIn,'x','abc')\n  self.assertRaises(self.failureException,self.assertIn,4,[1,2,3])\n  self.assertRaises(self.failureException,self.assertIn,'elephant',\n  animals)\n  self.assertRaises(self.failureException,self.assertNotIn,'c','abc')\n  self.assertRaises(self.failureException,self.assertNotIn,1,[1,2,3])\n  self.assertRaises(self.failureException,self.assertNotIn,'cow',\n  animals)\n def testAssertDictContainsSubset(self):\n  with warnings.catch_warnings():\n   warnings.simplefilter(\"ignore\",DeprecationWarning)\n   self.assertDictContainsSubset({},{})\n   self.assertDictContainsSubset({},{'a':1})\n   self.assertDictContainsSubset({'a':1},{'a':1})\n   self.assertDictContainsSubset({'a':1},{'a':1,'b':2})\n   self.assertDictContainsSubset({'a':1,'b':2},{'a':1,'b':2})\n   with self.assertRaises(self.failureException):\n    self.assertDictContainsSubset({1:\"one\"},{})\n   with self.assertRaises(self.failureException):\n    self.assertDictContainsSubset({'a':2},{'a':1})\n   with self.assertRaises(self.failureException):\n    self.assertDictContainsSubset({'c':1},{'a':1})\n   with self.assertRaises(self.failureException):\n    self.assertDictContainsSubset({'a':1,'c':1},{'a':1})\n   with self.assertRaises(self.failureException):\n    self.assertDictContainsSubset({'a':1,'c':1},{'a':1})\n   one=''.join(chr(i)for i in range(255))\n   with self.assertRaises(self.failureException):\n    self.assertDictContainsSubset({'foo':one},{'foo':'\\uFFFD'})\n def testAssertEqual(self):\n  equal_pairs=[\n  ((),()),\n  ({},{}),\n  ([],[]),\n  (set(),set()),\n  (frozenset(),frozenset())]\n  for a,b in equal_pairs:\n   try:\n    self.assertEqual(a,b)\n   except self.failureException:\n    self.fail('assertEqual(%r, %r) failed'%(a,b))\n   try:\n    self.assertEqual(a,b,msg='foo')\n   except self.failureException:\n    self.fail('assertEqual(%r, %r) with msg= failed'%(a,b))\n   try:\n    self.assertEqual(a,b,'foo')\n   except self.failureException:\n    self.fail('assertEqual(%r, %r) with third parameter failed'%\n    (a,b))\n  unequal_pairs=[\n  ((),[]),\n  ({},set()),\n  (set([4,1]),frozenset([4,2])),\n  (frozenset([4,5]),set([2,3])),\n  (set([3,4]),set([5,4]))]\n  for a,b in unequal_pairs:\n   self.assertRaises(self.failureException,self.assertEqual,a,b)\n   self.assertRaises(self.failureException,self.assertEqual,a,b,\n   'foo')\n   self.assertRaises(self.failureException,self.assertEqual,a,b,\n   msg='foo')\n def testEquality(self):\n  self.assertListEqual([],[])\n  self.assertTupleEqual((),())\n  self.assertSequenceEqual([],())\n  a=[0,'a',[]]\n  b=[]\n  self.assertRaises(unittest.TestCase.failureException,\n  self.assertListEqual,a,b)\n  self.assertRaises(unittest.TestCase.failureException,\n  self.assertListEqual,tuple(a),tuple(b))\n  self.assertRaises(unittest.TestCase.failureException,\n  self.assertSequenceEqual,a,tuple(b))\n  b.extend(a)\n  self.assertListEqual(a,b)\n  self.assertTupleEqual(tuple(a),tuple(b))\n  self.assertSequenceEqual(a,tuple(b))\n  self.assertSequenceEqual(tuple(a),b)\n  self.assertRaises(self.failureException,self.assertListEqual,\n  a,tuple(b))\n  self.assertRaises(self.failureException,self.assertTupleEqual,\n  tuple(a),b)\n  self.assertRaises(self.failureException,self.assertListEqual,None,b)\n  self.assertRaises(self.failureException,self.assertTupleEqual,None,\n  tuple(b))\n  self.assertRaises(self.failureException,self.assertSequenceEqual,\n  None,tuple(b))\n  self.assertRaises(self.failureException,self.assertListEqual,1,1)\n  self.assertRaises(self.failureException,self.assertTupleEqual,1,1)\n  self.assertRaises(self.failureException,self.assertSequenceEqual,\n  1,1)\n  self.assertDictEqual({},{})\n  c={'x':1}\n  d={}\n  self.assertRaises(unittest.TestCase.failureException,\n  self.assertDictEqual,c,d)\n  d.update(c)\n  self.assertDictEqual(c,d)\n  d['x']=0\n  self.assertRaises(unittest.TestCase.failureException,\n  self.assertDictEqual,c,d,'These are unequal')\n  self.assertRaises(self.failureException,self.assertDictEqual,None,d)\n  self.assertRaises(self.failureException,self.assertDictEqual,[],d)\n  self.assertRaises(self.failureException,self.assertDictEqual,1,1)\n def testAssertSequenceEqualMaxDiff(self):\n  self.assertEqual(self.maxDiff,80*8)\n  seq1='a'+'x'*80**2\n  seq2='b'+'x'*80**2\n  diff='\\n'.join(difflib.ndiff(pprint.pformat(seq1).splitlines(),\n  pprint.pformat(seq2).splitlines()))\n  omitted=unittest.case.DIFF_OMITTED%(len(diff)+1,)\n  self.maxDiff=len(diff)//2\n  try:\n   self.assertSequenceEqual(seq1,seq2)\n  except self.failureException as e:\n   msg=e.args[0]\n  else:\n   self.fail('assertSequenceEqual did not fail.')\n  self.assertTrue(len(msg)<len(diff))\n  self.assertIn(omitted,msg)\n  self.maxDiff=len(diff)*2\n  try:\n   self.assertSequenceEqual(seq1,seq2)\n  except self.failureException as e:\n   msg=e.args[0]\n  else:\n   self.fail('assertSequenceEqual did not fail.')\n  self.assertTrue(len(msg)>len(diff))\n  self.assertNotIn(omitted,msg)\n  self.maxDiff=None\n  try:\n   self.assertSequenceEqual(seq1,seq2)\n  except self.failureException as e:\n   msg=e.args[0]\n  else:\n   self.fail('assertSequenceEqual did not fail.')\n  self.assertTrue(len(msg)>len(diff))\n  self.assertNotIn(omitted,msg)\n def testTruncateMessage(self):\n  self.maxDiff=1\n  message=self._truncateMessage('foo','bar')\n  omitted=unittest.case.DIFF_OMITTED%len('bar')\n  self.assertEqual(message,'foo'+omitted)\n  self.maxDiff=None\n  message=self._truncateMessage('foo','bar')\n  self.assertEqual(message,'foobar')\n  self.maxDiff=4\n  message=self._truncateMessage('foo','bar')\n  self.assertEqual(message,'foobar')\n def testAssertDictEqualTruncates(self):\n  test=unittest.TestCase('assertEqual')\n  def truncate(msg,diff):\n   return'foo'\n  test._truncateMessage=truncate\n  try:\n   test.assertDictEqual({},{1:0})\n  except self.failureException as e:\n   self.assertEqual(str(e),'foo')\n  else:\n   self.fail('assertDictEqual did not fail')\n def testAssertMultiLineEqualTruncates(self):\n  test=unittest.TestCase('assertEqual')\n  def truncate(msg,diff):\n   return'foo'\n  test._truncateMessage=truncate\n  try:\n   test.assertMultiLineEqual('foo','bar')\n  except self.failureException as e:\n   self.assertEqual(str(e),'foo')\n  else:\n   self.fail('assertMultiLineEqual did not fail')\n def testAssertEqual_diffThreshold(self):\n  self.assertEqual(self._diffThreshold,2**16)\n  self.maxDiff=None\n  old_threshold=self._diffThreshold\n  self._diffThreshold=2**8\n  self.addCleanup(lambda:setattr(self,'_diffThreshold',old_threshold))\n  s='x'*(2**7)\n  with self.assertRaises(self.failureException)as cm:\n   self.assertEqual(s+'a',s+'b')\n  self.assertIn('^',str(cm.exception))\n  self.assertEqual(s+'a',s+'a')\n  s='x'*(2**9)\n  def explodingTruncation(message,diff):\n   raise SystemError('this should not be raised')\n  old_truncate=self._truncateMessage\n  self._truncateMessage=explodingTruncation\n  self.addCleanup(lambda:setattr(self,'_truncateMessage',old_truncate))\n  s1,s2=s+'a',s+'b'\n  with self.assertRaises(self.failureException)as cm:\n   self.assertEqual(s1,s2)\n  self.assertNotIn('^',str(cm.exception))\n  self.assertEqual(str(cm.exception),'%r != %r'%(s1,s2))\n  self.assertEqual(s+'a',s+'a')\n def testAssertCountEqual(self):\n  a=object()\n  self.assertCountEqual([1,2,3],[3,2,1])\n  self.assertCountEqual(['foo','bar','baz'],['bar','baz','foo'])\n  self.assertCountEqual([a,a,2,2,3],(a,2,3,a,2))\n  self.assertCountEqual([1,\"2\",\"a\",\"a\"],[\"a\",\"2\",True,\"a\"])\n  self.assertRaises(self.failureException,self.assertCountEqual,\n  [1,2]+[3]*100,[1]*100+[2,3])\n  self.assertRaises(self.failureException,self.assertCountEqual,\n  [1,\"2\",\"a\",\"a\"],[\"a\",\"2\",True,1])\n  self.assertRaises(self.failureException,self.assertCountEqual,\n  [10],[10,11])\n  self.assertRaises(self.failureException,self.assertCountEqual,\n  [10,11],[10])\n  self.assertRaises(self.failureException,self.assertCountEqual,\n  [10,11,10],[10,11])\n  self.assertCountEqual([[1,2],[3,4],0],[False,[3,4],[1,2]])\n  self.assertCountEqual(iter([1,2,[],3,4]),\n  iter([1,2,[],3,4]))\n  self.assertRaises(self.failureException,self.assertCountEqual,\n  [],[divmod,'x',1,5j,2j,frozenset()])\n  self.assertCountEqual([{'a':1},{'b':2}],[{'b':2},{'a':1}])\n  self.assertCountEqual([1,'x',divmod,[]],[divmod,[],'x',1])\n  self.assertRaises(self.failureException,self.assertCountEqual,\n  [],[divmod,[],'x',1,5j,2j,set()])\n  self.assertRaises(self.failureException,self.assertCountEqual,\n  [[1]],[[2]])\n  self.assertRaises(self.failureException,self.assertCountEqual,\n  [1,1,2],[2,1])\n  self.assertRaises(self.failureException,self.assertCountEqual,\n  [1,1,\"2\",\"a\",\"a\"],[\"2\",\"2\",True,\"a\"])\n  self.assertRaises(self.failureException,self.assertCountEqual,\n  [1,{'b':2},None,True],[{'b':2},True,None])\n  a=[{2,4},{1,2}]\n  b=a[::-1]\n  self.assertCountEqual(a,b)\n  diffs=set(unittest.util._count_diff_all_purpose('aaabccd','abbbcce'))\n  expected={(3,1,'a'),(1,3,'b'),(1,0,'d'),(0,1,'e')}\n  self.assertEqual(diffs,expected)\n  diffs=unittest.util._count_diff_all_purpose([[]],[])\n  self.assertEqual(diffs,[(1,0,[])])\n  diffs=set(unittest.util._count_diff_hashable('aaabccd','abbbcce'))\n  expected={(3,1,'a'),(1,3,'b'),(1,0,'d'),(0,1,'e')}\n  self.assertEqual(diffs,expected)\n def testAssertSetEqual(self):\n  set1=set()\n  set2=set()\n  self.assertSetEqual(set1,set2)\n  self.assertRaises(self.failureException,self.assertSetEqual,None,set2)\n  self.assertRaises(self.failureException,self.assertSetEqual,[],set2)\n  self.assertRaises(self.failureException,self.assertSetEqual,set1,None)\n  self.assertRaises(self.failureException,self.assertSetEqual,set1,[])\n  set1=set(['a'])\n  set2=set()\n  self.assertRaises(self.failureException,self.assertSetEqual,set1,set2)\n  set1=set(['a'])\n  set2=set(['a'])\n  self.assertSetEqual(set1,set2)\n  set1=set(['a'])\n  set2=set(['a','b'])\n  self.assertRaises(self.failureException,self.assertSetEqual,set1,set2)\n  set1=set(['a'])\n  set2=frozenset(['a','b'])\n  self.assertRaises(self.failureException,self.assertSetEqual,set1,set2)\n  set1=set(['a','b'])\n  set2=frozenset(['a','b'])\n  self.assertSetEqual(set1,set2)\n  set1=set()\n  set2=\"foo\"\n  self.assertRaises(self.failureException,self.assertSetEqual,set1,set2)\n  self.assertRaises(self.failureException,self.assertSetEqual,set2,set1)\n  set1=set([(0,1),(2,3)])\n  set2=set([(4,5)])\n  self.assertRaises(self.failureException,self.assertSetEqual,set1,set2)\n def testInequality(self):\n  self.assertGreater(2,1)\n  self.assertGreaterEqual(2,1)\n  self.assertGreaterEqual(1,1)\n  self.assertLess(1,2)\n  self.assertLessEqual(1,2)\n  self.assertLessEqual(1,1)\n  self.assertRaises(self.failureException,self.assertGreater,1,2)\n  self.assertRaises(self.failureException,self.assertGreater,1,1)\n  self.assertRaises(self.failureException,self.assertGreaterEqual,1,2)\n  self.assertRaises(self.failureException,self.assertLess,2,1)\n  self.assertRaises(self.failureException,self.assertLess,1,1)\n  self.assertRaises(self.failureException,self.assertLessEqual,2,1)\n  self.assertGreater(1.1,1.0)\n  self.assertGreaterEqual(1.1,1.0)\n  self.assertGreaterEqual(1.0,1.0)\n  self.assertLess(1.0,1.1)\n  self.assertLessEqual(1.0,1.1)\n  self.assertLessEqual(1.0,1.0)\n  self.assertRaises(self.failureException,self.assertGreater,1.0,1.1)\n  self.assertRaises(self.failureException,self.assertGreater,1.0,1.0)\n  self.assertRaises(self.failureException,self.assertGreaterEqual,1.0,1.1)\n  self.assertRaises(self.failureException,self.assertLess,1.1,1.0)\n  self.assertRaises(self.failureException,self.assertLess,1.0,1.0)\n  self.assertRaises(self.failureException,self.assertLessEqual,1.1,1.0)\n  self.assertGreater('bug','ant')\n  self.assertGreaterEqual('bug','ant')\n  self.assertGreaterEqual('ant','ant')\n  self.assertLess('ant','bug')\n  self.assertLessEqual('ant','bug')\n  self.assertLessEqual('ant','ant')\n  self.assertRaises(self.failureException,self.assertGreater,'ant','bug')\n  self.assertRaises(self.failureException,self.assertGreater,'ant','ant')\n  self.assertRaises(self.failureException,self.assertGreaterEqual,'ant','bug')\n  self.assertRaises(self.failureException,self.assertLess,'bug','ant')\n  self.assertRaises(self.failureException,self.assertLess,'ant','ant')\n  self.assertRaises(self.failureException,self.assertLessEqual,'bug','ant')\n  self.assertGreater(b'bug',b'ant')\n  self.assertGreaterEqual(b'bug',b'ant')\n  self.assertGreaterEqual(b'ant',b'ant')\n  self.assertLess(b'ant',b'bug')\n  self.assertLessEqual(b'ant',b'bug')\n  self.assertLessEqual(b'ant',b'ant')\n  self.assertRaises(self.failureException,self.assertGreater,b'ant',b'bug')\n  self.assertRaises(self.failureException,self.assertGreater,b'ant',b'ant')\n  self.assertRaises(self.failureException,self.assertGreaterEqual,b'ant',\n  b'bug')\n  self.assertRaises(self.failureException,self.assertLess,b'bug',b'ant')\n  self.assertRaises(self.failureException,self.assertLess,b'ant',b'ant')\n  self.assertRaises(self.failureException,self.assertLessEqual,b'bug',b'ant')\n def testAssertMultiLineEqual(self):\n  sample_text=\"\"\"\\\nhttp://www.python.org/doc/2.3/lib/module-unittest.html\ntest case\n    A test case is the smallest unit of testing. [...]\n\"\"\"\n  revised_sample_text=\"\"\"\\\nhttp://www.python.org/doc/2.4.1/lib/module-unittest.html\ntest case\n    A test case is the smallest unit of testing. [...] You may provide your\n    own implementation that does not subclass from TestCase, of course.\n\"\"\"\n  sample_text_error=\"\"\"\\\n- http://www.python.org/doc/2.3/lib/module-unittest.html\n?                             ^\n+ http://www.python.org/doc/2.4.1/lib/module-unittest.html\n?                             ^^^\n  test case\n-     A test case is the smallest unit of testing. [...]\n+     A test case is the smallest unit of testing. [...] You may provide your\n?                                                       +++++++++++++++++++++\n+     own implementation that does not subclass from TestCase, of course.\n\"\"\"\n  self.maxDiff=None\n  try:\n   self.assertMultiLineEqual(sample_text,revised_sample_text)\n  except self.failureException as e:\n   error=str(e).split('\\n',1)[1]\n   self.assertTrue(sample_text_error==error)\n def testAsertEqualSingleLine(self):\n  sample_text=\"laden swallows fly slowly\"\n  revised_sample_text=\"unladen swallows fly quickly\"\n  sample_text_error=\"\"\"\\\n- laden swallows fly slowly\n?                    ^^^^\n+ unladen swallows fly quickly\n? ++                   ^^^^^\n\"\"\"\n  try:\n   self.assertEqual(sample_text,revised_sample_text)\n  except self.failureException as e:\n   error=str(e).split('\\n',1)[1]\n   self.assertTrue(sample_text_error==error)\n def testAssertIsNone(self):\n  self.assertIsNone(None)\n  self.assertRaises(self.failureException,self.assertIsNone,False)\n  self.assertIsNotNone('DjZoPloGears on Rails')\n  self.assertRaises(self.failureException,self.assertIsNotNone,None)\n def testAssertRegex(self):\n  self.assertRegex('asdfabasdf',r'ab+')\n  self.assertRaises(self.failureException,self.assertRegex,\n  'saaas',r'aaaa')\n def testAssertRaisesRegex(self):\n  class ExceptionMock(Exception):\n   pass\n  def Stub():\n   raise ExceptionMock('We expect')\n  self.assertRaisesRegex(ExceptionMock,re.compile('expect$'),Stub)\n  self.assertRaisesRegex(ExceptionMock,'expect$',Stub)\n def testAssertNotRaisesRegex(self):\n  self.assertRaisesRegex(\n  self.failureException,'^Exception not raised by <lambda>$',\n  self.assertRaisesRegex,Exception,re.compile('x'),\n  lambda:None)\n  self.assertRaisesRegex(\n  self.failureException,'^Exception not raised by <lambda>$',\n  self.assertRaisesRegex,Exception,'x',\n  lambda:None)\n def testAssertRaisesRegexMismatch(self):\n  def Stub():\n   raise Exception('Unexpected')\n  self.assertRaisesRegex(\n  self.failureException,\n  r'\"\\^Expected\\$\" does not match \"Unexpected\"',\n  self.assertRaisesRegex,Exception,'^Expected$',\n  Stub)\n  self.assertRaisesRegex(\n  self.failureException,\n  r'\"\\^Expected\\$\" does not match \"Unexpected\"',\n  self.assertRaisesRegex,Exception,\n  re.compile('^Expected$'),Stub)\n def testAssertRaisesExcValue(self):\n  class ExceptionMock(Exception):\n   pass\n  def Stub(foo):\n   raise ExceptionMock(foo)\n  v=\"particular value\"\n  ctx=self.assertRaises(ExceptionMock)\n  with ctx:\n   Stub(v)\n  e=ctx.exception\n  self.assertIsInstance(e,ExceptionMock)\n  self.assertEqual(e.args[0],v)\n def testAssertWarnsCallable(self):\n  def _runtime_warn():\n   warnings.warn(\"foo\",RuntimeWarning)\n  self.assertWarns(RuntimeWarning,_runtime_warn)\n  self.assertWarns(RuntimeWarning,_runtime_warn)\n  self.assertWarns((DeprecationWarning,RuntimeWarning),_runtime_warn)\n  self.assertWarns(RuntimeWarning,\n  warnings.warn,\"foo\",category=RuntimeWarning)\n  with self.assertRaises(self.failureException):\n   self.assertWarns(RuntimeWarning,lambda:0)\n  with warnings.catch_warnings():\n   warnings.simplefilter(\"default\",RuntimeWarning)\n   with self.assertRaises(self.failureException):\n    self.assertWarns(DeprecationWarning,_runtime_warn)\n  with warnings.catch_warnings():\n   warnings.simplefilter(\"error\",RuntimeWarning)\n   with self.assertRaises(RuntimeWarning):\n    self.assertWarns(DeprecationWarning,_runtime_warn)\n def testAssertWarnsContext(self):\n  def _runtime_warn():\n   warnings.warn(\"foo\",RuntimeWarning)\n  _runtime_warn_lineno=inspect.getsourcelines(_runtime_warn)[1]\n  with self.assertWarns(RuntimeWarning)as cm:\n   _runtime_warn()\n  with self.assertWarns((DeprecationWarning,RuntimeWarning))as cm:\n   _runtime_warn()\n  self.assertIsInstance(cm.warning,RuntimeWarning)\n  self.assertEqual(cm.warning.args[0],\"foo\")\n  self.assertIn(\"test_case.py\",cm.filename)\n  self.assertEqual(cm.lineno,_runtime_warn_lineno+1)\n  with self.assertWarns(RuntimeWarning):\n   _runtime_warn()\n   _runtime_warn()\n  with self.assertWarns(RuntimeWarning):\n   warnings.warn(\"foo\",category=RuntimeWarning)\n  with self.assertRaises(self.failureException):\n   with self.assertWarns(RuntimeWarning):\n    pass\n  with warnings.catch_warnings():\n   warnings.simplefilter(\"default\",RuntimeWarning)\n   with self.assertRaises(self.failureException):\n    with self.assertWarns(DeprecationWarning):\n     _runtime_warn()\n  with warnings.catch_warnings():\n   warnings.simplefilter(\"error\",RuntimeWarning)\n   with self.assertRaises(RuntimeWarning):\n    with self.assertWarns(DeprecationWarning):\n     _runtime_warn()\n def testAssertWarnsRegexCallable(self):\n  def _runtime_warn(msg):\n   warnings.warn(msg,RuntimeWarning)\n  self.assertWarnsRegex(RuntimeWarning,\"o+\",\n  _runtime_warn,\"foox\")\n  with self.assertRaises(self.failureException):\n   self.assertWarnsRegex(RuntimeWarning,\"o+\",\n   lambda:0)\n  with warnings.catch_warnings():\n   warnings.simplefilter(\"default\",RuntimeWarning)\n   with self.assertRaises(self.failureException):\n    self.assertWarnsRegex(DeprecationWarning,\"o+\",\n    _runtime_warn,\"foox\")\n  with self.assertRaises(self.failureException):\n   self.assertWarnsRegex(RuntimeWarning,\"o+\",\n   _runtime_warn,\"barz\")\n  with warnings.catch_warnings():\n   warnings.simplefilter(\"error\",RuntimeWarning)\n   with self.assertRaises((RuntimeWarning,self.failureException)):\n    self.assertWarnsRegex(RuntimeWarning,\"o+\",\n    _runtime_warn,\"barz\")\n def testAssertWarnsRegexContext(self):\n  def _runtime_warn(msg):\n   warnings.warn(msg,RuntimeWarning)\n  _runtime_warn_lineno=inspect.getsourcelines(_runtime_warn)[1]\n  with self.assertWarnsRegex(RuntimeWarning,\"o+\")as cm:\n   _runtime_warn(\"foox\")\n  self.assertIsInstance(cm.warning,RuntimeWarning)\n  self.assertEqual(cm.warning.args[0],\"foox\")\n  self.assertIn(\"test_case.py\",cm.filename)\n  self.assertEqual(cm.lineno,_runtime_warn_lineno+1)\n  with self.assertRaises(self.failureException):\n   with self.assertWarnsRegex(RuntimeWarning,\"o+\"):\n    pass\n  with warnings.catch_warnings():\n   warnings.simplefilter(\"default\",RuntimeWarning)\n   with self.assertRaises(self.failureException):\n    with self.assertWarnsRegex(DeprecationWarning,\"o+\"):\n     _runtime_warn(\"foox\")\n  with self.assertRaises(self.failureException):\n   with self.assertWarnsRegex(RuntimeWarning,\"o+\"):\n    _runtime_warn(\"barz\")\n  with warnings.catch_warnings():\n   warnings.simplefilter(\"error\",RuntimeWarning)\n   with self.assertRaises((RuntimeWarning,self.failureException)):\n    with self.assertWarnsRegex(RuntimeWarning,\"o+\"):\n     _runtime_warn(\"barz\")\n def testDeprecatedMethodNames(self):\n  ''  \n  old=(\n  (self.failIfEqual,(3,5)),\n  (self.assertNotEquals,(3,5)),\n  (self.failUnlessEqual,(3,3)),\n  (self.assertEquals,(3,3)),\n  (self.failUnlessAlmostEqual,(2.0,2.0)),\n  (self.assertAlmostEquals,(2.0,2.0)),\n  (self.failIfAlmostEqual,(3.0,5.0)),\n  (self.assertNotAlmostEquals,(3.0,5.0)),\n  (self.failUnless,(True,)),\n  (self.assert_,(True,)),\n  (self.failUnlessRaises,(TypeError,lambda _:3.14+'spam')),\n  (self.failIf,(False,)),\n  (self.assertDictContainsSubset,(dict(a=1,b=2),dict(a=1,b=2,c=3))),\n  (self.assertRaisesRegexp,(KeyError,'foo',lambda:{}['foo'])),\n  (self.assertRegexpMatches,('bar','bar')),\n  )\n  for meth,args in old:\n   with self.assertWarns(DeprecationWarning):\n    meth(*args)\n def _testDeprecatedFailMethods(self):\n  if sys.version_info[:2]<(3,3):\n   return\n  deprecated_names=[\n  'failIfEqual','failUnlessEqual','failUnlessAlmostEqual',\n  'failIfAlmostEqual','failUnless','failUnlessRaises','failIf',\n  'assertDictContainsSubset',\n  ]\n  for deprecated_name in deprecated_names:\n   with self.assertRaises(AttributeError):\n    getattr(self,deprecated_name)\n def testDeepcopy(self):\n  class TestableTest(unittest.TestCase):\n   def testNothing(self):\n    pass\n  test=TestableTest('testNothing')\n  deepcopy(test)\n def testPickle(self):\n  test=unittest.TestCase('run')\n  for protocol in range(pickle.HIGHEST_PROTOCOL+1):\n   pickled_test=pickle.dumps(test,protocol=protocol)\n   unpickled_test=pickle.loads(pickled_test)\n   self.assertEqual(test,unpickled_test)\n   unpickled_test.assertEqual(set(),set())\n def testKeyboardInterrupt(self):\n  def _raise(self=None):\n   raise KeyboardInterrupt\n  def nothing(self):\n   pass\n  class Test1(unittest.TestCase):\n   test_something=_raise\n  class Test2(unittest.TestCase):\n   setUp=_raise\n   test_something=nothing\n  class Test3(unittest.TestCase):\n   test_something=nothing\n   tearDown=_raise\n  class Test4(unittest.TestCase):\n   def test_something(self):\n    self.addCleanup(_raise)\n  for klass in(Test1,Test2,Test3,Test4):\n   with self.assertRaises(KeyboardInterrupt):\n    klass('test_something').run()\n def testSkippingEverywhere(self):\n  def _skip(self=None):\n   raise unittest.SkipTest('some reason')\n  def nothing(self):\n   pass\n  class Test1(unittest.TestCase):\n   test_something=_skip\n  class Test2(unittest.TestCase):\n   setUp=_skip\n   test_something=nothing\n  class Test3(unittest.TestCase):\n   test_something=nothing\n   tearDown=_skip\n  class Test4(unittest.TestCase):\n   def test_something(self):\n    self.addCleanup(_skip)\n  for klass in(Test1,Test2,Test3,Test4):\n   result=unittest.TestResult()\n   klass('test_something').run(result)\n   self.assertEqual(len(result.skipped),1)\n   self.assertEqual(result.testsRun,1)\n def testSystemExit(self):\n  def _raise(self=None):\n   raise SystemExit\n  def nothing(self):\n   pass\n  class Test1(unittest.TestCase):\n   test_something=_raise\n  class Test2(unittest.TestCase):\n   setUp=_raise\n   test_something=nothing\n  class Test3(unittest.TestCase):\n   test_something=nothing\n   tearDown=_raise\n  class Test4(unittest.TestCase):\n   def test_something(self):\n    self.addCleanup(_raise)\n  for klass in(Test1,Test2,Test3,Test4):\n   result=unittest.TestResult()\n   klass('test_something').run(result)\n   self.assertEqual(len(result.errors),1)\n   self.assertEqual(result.testsRun,1)\n @support.cpython_only\n def testNoCycles(self):\n  case=unittest.TestCase()\n  wr=weakref.ref(case)\n  with support.disable_gc():\n   del case\n   self.assertFalse(wr())\n"], "unittest.test.testmock.testpatch": ["\nimport os\nimport sys\nimport unittest\nfrom unittest.test.testmock import support\nfrom unittest.test.testmock.support import SomeClass,is_instance\nfrom unittest.mock import(\nNonCallableMock,CallableMixin,patch,sentinel,\nMagicMock,Mock,NonCallableMagicMock,patch,_patch,\nDEFAULT,call,_get_target\n)\nbuiltin_string='builtins'\nPTModule=sys.modules[__name__]\nMODNAME='%s.PTModule'%__name__\ndef _get_proxy(obj,get_only=True):\n class Proxy(object):\n  def __getattr__(self,name):\n   return getattr(obj,name)\n if not get_only:\n  def __setattr__(self,name,value):\n   setattr(obj,name,value)\n  def __delattr__(self,name):\n   delattr(obj,name)\n  Proxy.__setattr__=__setattr__\n  Proxy.__delattr__=__delattr__\n return Proxy()\nsomething=sentinel.Something\nsomething_else=sentinel.SomethingElse\nclass Foo(object):\n def __init__(self,a):\n  pass\n def f(self,a):\n  pass\n def g(self):\n  pass\n foo='bar'\n class Bar(object):\n  def a(self):\n   pass\nfoo_name='%s.Foo'%__name__\ndef function(a,b=Foo):\n pass\nclass Container(object):\n def __init__(self):\n  self.values={}\n def __getitem__(self,name):\n  return self.values[name]\n def __setitem__(self,name,value):\n  self.values[name]=value\n def __delitem__(self,name):\n  del self.values[name]\n def __iter__(self):\n  return iter(self.values)\nclass PatchTest(unittest.TestCase):\n def assertNotCallable(self,obj,magic=True):\n  MockClass=NonCallableMagicMock\n  if not magic:\n   MockClass=NonCallableMock\n  self.assertRaises(TypeError,obj)\n  self.assertTrue(is_instance(obj,MockClass))\n  self.assertFalse(is_instance(obj,CallableMixin))\n def test_single_patchobject(self):\n  class Something(object):\n   attribute=sentinel.Original\n  @patch.object(Something,'attribute',sentinel.Patched)\n  def test():\n   self.assertEqual(Something.attribute,sentinel.Patched,\"unpatched\")\n  test()\n  self.assertEqual(Something.attribute,sentinel.Original,\n  \"patch not restored\")\n def test_patchobject_with_none(self):\n  class Something(object):\n   attribute=sentinel.Original\n  @patch.object(Something,'attribute',None)\n  def test():\n   self.assertIsNone(Something.attribute,\"unpatched\")\n  test()\n  self.assertEqual(Something.attribute,sentinel.Original,\n  \"patch not restored\")\n def test_multiple_patchobject(self):\n  class Something(object):\n   attribute=sentinel.Original\n   next_attribute=sentinel.Original2\n  @patch.object(Something,'attribute',sentinel.Patched)\n  @patch.object(Something,'next_attribute',sentinel.Patched2)\n  def test():\n   self.assertEqual(Something.attribute,sentinel.Patched,\n   \"unpatched\")\n   self.assertEqual(Something.next_attribute,sentinel.Patched2,\n   \"unpatched\")\n  test()\n  self.assertEqual(Something.attribute,sentinel.Original,\n  \"patch not restored\")\n  self.assertEqual(Something.next_attribute,sentinel.Original2,\n  \"patch not restored\")\n def test_object_lookup_is_quite_lazy(self):\n  global something\n  original=something\n  @patch('%s.something'%__name__,sentinel.Something2)\n  def test():\n   pass\n  try:\n   something=sentinel.replacement_value\n   test()\n   self.assertEqual(something,sentinel.replacement_value)\n  finally:\n   something=original\n def test_patch(self):\n  @patch('%s.something'%__name__,sentinel.Something2)\n  def test():\n   self.assertEqual(PTModule.something,sentinel.Something2,\n   \"unpatched\")\n  test()\n  self.assertEqual(PTModule.something,sentinel.Something,\n  \"patch not restored\")\n  @patch('%s.something'%__name__,sentinel.Something2)\n  @patch('%s.something_else'%__name__,sentinel.SomethingElse)\n  def test():\n   self.assertEqual(PTModule.something,sentinel.Something2,\n   \"unpatched\")\n   self.assertEqual(PTModule.something_else,sentinel.SomethingElse,\n   \"unpatched\")\n  self.assertEqual(PTModule.something,sentinel.Something,\n  \"patch not restored\")\n  self.assertEqual(PTModule.something_else,sentinel.SomethingElse,\n  \"patch not restored\")\n  test()\n  self.assertEqual(PTModule.something,sentinel.Something,\n  \"patch not restored\")\n  self.assertEqual(PTModule.something_else,sentinel.SomethingElse,\n  \"patch not restored\")\n  mock=Mock()\n  mock.return_value=sentinel.Handle\n  @patch('%s.open'%builtin_string,mock)\n  def test():\n   self.assertEqual(open('filename','r'),sentinel.Handle,\n   \"open not patched\")\n  test()\n  test()\n  self.assertNotEqual(open,mock,\"patch not restored\")\n def test_patch_class_attribute(self):\n  @patch('%s.SomeClass.class_attribute'%__name__,\n  sentinel.ClassAttribute)\n  def test():\n   self.assertEqual(PTModule.SomeClass.class_attribute,\n   sentinel.ClassAttribute,\"unpatched\")\n  test()\n  self.assertIsNone(PTModule.SomeClass.class_attribute,\n  \"patch not restored\")\n def test_patchobject_with_default_mock(self):\n  class Test(object):\n   something=sentinel.Original\n   something2=sentinel.Original2\n  @patch.object(Test,'something')\n  def test(mock):\n   self.assertEqual(mock,Test.something,\n   \"Mock not passed into test function\")\n   self.assertIsInstance(mock,MagicMock,\n   \"patch with two arguments did not create a mock\")\n  test()\n  @patch.object(Test,'something')\n  @patch.object(Test,'something2')\n  def test(this1,this2,mock1,mock2):\n   self.assertEqual(this1,sentinel.this1,\n   \"Patched function didn't receive initial argument\")\n   self.assertEqual(this2,sentinel.this2,\n   \"Patched function didn't receive second argument\")\n   self.assertEqual(mock1,Test.something2,\n   \"Mock not passed into test function\")\n   self.assertEqual(mock2,Test.something,\n   \"Second Mock not passed into test function\")\n   self.assertIsInstance(mock2,MagicMock,\n   \"patch with two arguments did not create a mock\")\n   self.assertIsInstance(mock2,MagicMock,\n   \"patch with two arguments did not create a mock\")\n   self.assertNotEqual(outerMock1,mock1,\"unexpected value for mock1\")\n   self.assertNotEqual(outerMock2,mock2,\"unexpected value for mock1\")\n   return mock1,mock2\n  outerMock1=outerMock2=None\n  outerMock1,outerMock2=test(sentinel.this1,sentinel.this2)\n  test(sentinel.this1,sentinel.this2)\n def test_patch_with_spec(self):\n  @patch('%s.SomeClass'%__name__,spec=SomeClass)\n  def test(MockSomeClass):\n   self.assertEqual(SomeClass,MockSomeClass)\n   self.assertTrue(is_instance(SomeClass.wibble,MagicMock))\n   self.assertRaises(AttributeError,lambda:SomeClass.not_wibble)\n  test()\n def test_patchobject_with_spec(self):\n  @patch.object(SomeClass,'class_attribute',spec=SomeClass)\n  def test(MockAttribute):\n   self.assertEqual(SomeClass.class_attribute,MockAttribute)\n   self.assertTrue(is_instance(SomeClass.class_attribute.wibble,\n   MagicMock))\n   self.assertRaises(AttributeError,\n   lambda:SomeClass.class_attribute.not_wibble)\n  test()\n def test_patch_with_spec_as_list(self):\n  @patch('%s.SomeClass'%__name__,spec=['wibble'])\n  def test(MockSomeClass):\n   self.assertEqual(SomeClass,MockSomeClass)\n   self.assertTrue(is_instance(SomeClass.wibble,MagicMock))\n   self.assertRaises(AttributeError,lambda:SomeClass.not_wibble)\n  test()\n def test_patchobject_with_spec_as_list(self):\n  @patch.object(SomeClass,'class_attribute',spec=['wibble'])\n  def test(MockAttribute):\n   self.assertEqual(SomeClass.class_attribute,MockAttribute)\n   self.assertTrue(is_instance(SomeClass.class_attribute.wibble,\n   MagicMock))\n   self.assertRaises(AttributeError,\n   lambda:SomeClass.class_attribute.not_wibble)\n  test()\n def test_nested_patch_with_spec_as_list(self):\n  @patch('%s.open'%builtin_string)\n  @patch('%s.SomeClass'%__name__,spec=['wibble'])\n  def test(MockSomeClass,MockOpen):\n   self.assertEqual(SomeClass,MockSomeClass)\n   self.assertTrue(is_instance(SomeClass.wibble,MagicMock))\n   self.assertRaises(AttributeError,lambda:SomeClass.not_wibble)\n  test()\n def test_patch_with_spec_as_boolean(self):\n  @patch('%s.SomeClass'%__name__,spec=True)\n  def test(MockSomeClass):\n   self.assertEqual(SomeClass,MockSomeClass)\n   MockSomeClass.wibble\n   self.assertRaises(AttributeError,lambda:MockSomeClass.not_wibble)\n  test()\n def test_patch_object_with_spec_as_boolean(self):\n  @patch.object(PTModule,'SomeClass',spec=True)\n  def test(MockSomeClass):\n   self.assertEqual(SomeClass,MockSomeClass)\n   MockSomeClass.wibble\n   self.assertRaises(AttributeError,lambda:MockSomeClass.not_wibble)\n  test()\n def test_patch_class_acts_with_spec_is_inherited(self):\n  @patch('%s.SomeClass'%__name__,spec=True)\n  def test(MockSomeClass):\n   self.assertTrue(is_instance(MockSomeClass,MagicMock))\n   instance=MockSomeClass()\n   self.assertNotCallable(instance)\n   instance.wibble\n   self.assertRaises(AttributeError,lambda:instance.not_wibble)\n  test()\n def test_patch_with_create_mocks_non_existent_attributes(self):\n  @patch('%s.frooble'%builtin_string,sentinel.Frooble,create=True)\n  def test():\n   self.assertEqual(frooble,sentinel.Frooble)\n  test()\n  self.assertRaises(NameError,lambda:frooble)\n def test_patchobject_with_create_mocks_non_existent_attributes(self):\n  @patch.object(SomeClass,'frooble',sentinel.Frooble,create=True)\n  def test():\n   self.assertEqual(SomeClass.frooble,sentinel.Frooble)\n  test()\n  self.assertFalse(hasattr(SomeClass,'frooble'))\n def test_patch_wont_create_by_default(self):\n  try:\n   @patch('%s.frooble'%builtin_string,sentinel.Frooble)\n   def test():\n    self.assertEqual(frooble,sentinel.Frooble)\n   test()\n  except AttributeError:\n   pass\n  else:\n   self.fail('Patching non existent attributes should fail')\n  self.assertRaises(NameError,lambda:frooble)\n def test_patchobject_wont_create_by_default(self):\n  try:\n   @patch.object(SomeClass,'frooble',sentinel.Frooble)\n   def test():\n    self.fail('Patching non existent attributes should fail')\n   test()\n  except AttributeError:\n   pass\n  else:\n   self.fail('Patching non existent attributes should fail')\n  self.assertFalse(hasattr(SomeClass,'frooble'))\n def test_patch_with_static_methods(self):\n  class Foo(object):\n   @staticmethod\n   def woot():\n    return sentinel.Static\n  @patch.object(Foo,'woot',staticmethod(lambda:sentinel.Patched))\n  def anonymous():\n   self.assertEqual(Foo.woot(),sentinel.Patched)\n  anonymous()\n  self.assertEqual(Foo.woot(),sentinel.Static)\n def test_patch_local(self):\n  foo=sentinel.Foo\n  @patch.object(sentinel,'Foo','Foo')\n  def anonymous():\n   self.assertEqual(sentinel.Foo,'Foo')\n  anonymous()\n  self.assertEqual(sentinel.Foo,foo)\n def test_patch_slots(self):\n  class Foo(object):\n   __slots__=('Foo',)\n  foo=Foo()\n  foo.Foo=sentinel.Foo\n  @patch.object(foo,'Foo','Foo')\n  def anonymous():\n   self.assertEqual(foo.Foo,'Foo')\n  anonymous()\n  self.assertEqual(foo.Foo,sentinel.Foo)\n def test_patchobject_class_decorator(self):\n  class Something(object):\n   attribute=sentinel.Original\n  class Foo(object):\n   def test_method(other_self):\n    self.assertEqual(Something.attribute,sentinel.Patched,\n    \"unpatched\")\n   def not_test_method(other_self):\n    self.assertEqual(Something.attribute,sentinel.Original,\n    \"non-test method patched\")\n  Foo=patch.object(Something,'attribute',sentinel.Patched)(Foo)\n  f=Foo()\n  f.test_method()\n  f.not_test_method()\n  self.assertEqual(Something.attribute,sentinel.Original,\n  \"patch not restored\")\n def test_patch_class_decorator(self):\n  class Something(object):\n   attribute=sentinel.Original\n  class Foo(object):\n   def test_method(other_self,mock_something):\n    self.assertEqual(PTModule.something,mock_something,\n    \"unpatched\")\n   def not_test_method(other_self):\n    self.assertEqual(PTModule.something,sentinel.Something,\n    \"non-test method patched\")\n  Foo=patch('%s.something'%__name__)(Foo)\n  f=Foo()\n  f.test_method()\n  f.not_test_method()\n  self.assertEqual(Something.attribute,sentinel.Original,\n  \"patch not restored\")\n  self.assertEqual(PTModule.something,sentinel.Something,\n  \"patch not restored\")\n def test_patchobject_twice(self):\n  class Something(object):\n   attribute=sentinel.Original\n   next_attribute=sentinel.Original2\n  @patch.object(Something,'attribute',sentinel.Patched)\n  @patch.object(Something,'attribute',sentinel.Patched)\n  def test():\n   self.assertEqual(Something.attribute,sentinel.Patched,\"unpatched\")\n  test()\n  self.assertEqual(Something.attribute,sentinel.Original,\n  \"patch not restored\")\n def test_patch_dict(self):\n  foo={'initial':object(),'other':'something'}\n  original=foo.copy()\n  @patch.dict(foo)\n  def test():\n   foo['a']=3\n   del foo['initial']\n   foo['other']='something else'\n  test()\n  self.assertEqual(foo,original)\n  @patch.dict(foo,{'a':'b'})\n  def test():\n   self.assertEqual(len(foo),3)\n   self.assertEqual(foo['a'],'b')\n  test()\n  self.assertEqual(foo,original)\n  @patch.dict(foo,[('a','b')])\n  def test():\n   self.assertEqual(len(foo),3)\n   self.assertEqual(foo['a'],'b')\n  test()\n  self.assertEqual(foo,original)\n def test_patch_dict_with_container_object(self):\n  foo=Container()\n  foo['initial']=object()\n  foo['other']='something'\n  original=foo.values.copy()\n  @patch.dict(foo)\n  def test():\n   foo['a']=3\n   del foo['initial']\n   foo['other']='something else'\n  test()\n  self.assertEqual(foo.values,original)\n  @patch.dict(foo,{'a':'b'})\n  def test():\n   self.assertEqual(len(foo.values),3)\n   self.assertEqual(foo['a'],'b')\n  test()\n  self.assertEqual(foo.values,original)\n def test_patch_dict_with_clear(self):\n  foo={'initial':object(),'other':'something'}\n  original=foo.copy()\n  @patch.dict(foo,clear=True)\n  def test():\n   self.assertEqual(foo,{})\n   foo['a']=3\n   foo['other']='something else'\n  test()\n  self.assertEqual(foo,original)\n  @patch.dict(foo,{'a':'b'},clear=True)\n  def test():\n   self.assertEqual(foo,{'a':'b'})\n  test()\n  self.assertEqual(foo,original)\n  @patch.dict(foo,[('a','b')],clear=True)\n  def test():\n   self.assertEqual(foo,{'a':'b'})\n  test()\n  self.assertEqual(foo,original)\n def test_patch_dict_with_container_object_and_clear(self):\n  foo=Container()\n  foo['initial']=object()\n  foo['other']='something'\n  original=foo.values.copy()\n  @patch.dict(foo,clear=True)\n  def test():\n   self.assertEqual(foo.values,{})\n   foo['a']=3\n   foo['other']='something else'\n  test()\n  self.assertEqual(foo.values,original)\n  @patch.dict(foo,{'a':'b'},clear=True)\n  def test():\n   self.assertEqual(foo.values,{'a':'b'})\n  test()\n  self.assertEqual(foo.values,original)\n def test_name_preserved(self):\n  foo={}\n  @patch('%s.SomeClass'%__name__,object())\n  @patch('%s.SomeClass'%__name__,object(),autospec=True)\n  @patch.object(SomeClass,object())\n  @patch.dict(foo)\n  def some_name():\n   pass\n  self.assertEqual(some_name.__name__,'some_name')\n def test_patch_with_exception(self):\n  foo={}\n  @patch.dict(foo,{'a':'b'})\n  def test():\n   raise NameError('Konrad')\n  try:\n   test()\n  except NameError:\n   pass\n  else:\n   self.fail('NameError not raised by test')\n  self.assertEqual(foo,{})\n def test_patch_dict_with_string(self):\n  @patch.dict('os.environ',{'konrad_delong':'some value'})\n  def test():\n   self.assertIn('konrad_delong',os.environ)\n  test()\n def test_patch_descriptor(self):\n  return\n  class Nothing(object):\n   foo=None\n  class Something(object):\n   foo={}\n   @patch.object(Nothing,'foo',2)\n   @classmethod\n   def klass(cls):\n    self.assertIs(cls,Something)\n   @patch.object(Nothing,'foo',2)\n   @staticmethod\n   def static(arg):\n    return arg\n   @patch.dict(foo)\n   @classmethod\n   def klass_dict(cls):\n    self.assertIs(cls,Something)\n   @patch.dict(foo)\n   @staticmethod\n   def static_dict(arg):\n    return arg\n  self.assertEqual(Something.static('f00'),'f00')\n  Something.klass()\n  self.assertEqual(Something.static_dict('f00'),'f00')\n  Something.klass_dict()\n  something=Something()\n  self.assertEqual(something.static('f00'),'f00')\n  something.klass()\n  self.assertEqual(something.static_dict('f00'),'f00')\n  something.klass_dict()\n def test_patch_spec_set(self):\n  @patch('%s.SomeClass'%__name__,spec=SomeClass,spec_set=True)\n  def test(MockClass):\n   MockClass.z='foo'\n  self.assertRaises(AttributeError,test)\n  @patch.object(support,'SomeClass',spec=SomeClass,spec_set=True)\n  def test(MockClass):\n   MockClass.z='foo'\n  self.assertRaises(AttributeError,test)\n  @patch('%s.SomeClass'%__name__,spec_set=True)\n  def test(MockClass):\n   MockClass.z='foo'\n  self.assertRaises(AttributeError,test)\n  @patch.object(support,'SomeClass',spec_set=True)\n  def test(MockClass):\n   MockClass.z='foo'\n  self.assertRaises(AttributeError,test)\n def test_spec_set_inherit(self):\n  @patch('%s.SomeClass'%__name__,spec_set=True)\n  def test(MockClass):\n   instance=MockClass()\n   instance.z='foo'\n  self.assertRaises(AttributeError,test)\n def test_patch_start_stop(self):\n  original=something\n  patcher=patch('%s.something'%__name__)\n  self.assertIs(something,original)\n  mock=patcher.start()\n  try:\n   self.assertIsNot(mock,original)\n   self.assertIs(something,mock)\n  finally:\n   patcher.stop()\n  self.assertIs(something,original)\n def test_stop_without_start(self):\n  patcher=patch(foo_name,'bar',3)\n  self.assertRaises(RuntimeError,patcher.stop)\n def test_patchobject_start_stop(self):\n  original=something\n  patcher=patch.object(PTModule,'something','foo')\n  self.assertIs(something,original)\n  replaced=patcher.start()\n  try:\n   self.assertEqual(replaced,'foo')\n   self.assertIs(something,replaced)\n  finally:\n   patcher.stop()\n  self.assertIs(something,original)\n def test_patch_dict_start_stop(self):\n  d={'foo':'bar'}\n  original=d.copy()\n  patcher=patch.dict(d,[('spam','eggs')],clear=True)\n  self.assertEqual(d,original)\n  patcher.start()\n  try:\n   self.assertEqual(d,{'spam':'eggs'})\n  finally:\n   patcher.stop()\n  self.assertEqual(d,original)\n def test_patch_dict_class_decorator(self):\n  this=self\n  d={'spam':'eggs'}\n  original=d.copy()\n  class Test(object):\n   def test_first(self):\n    this.assertEqual(d,{'foo':'bar'})\n   def test_second(self):\n    this.assertEqual(d,{'foo':'bar'})\n  Test=patch.dict(d,{'foo':'bar'},clear=True)(Test)\n  self.assertEqual(d,original)\n  test=Test()\n  test.test_first()\n  self.assertEqual(d,original)\n  test.test_second()\n  self.assertEqual(d,original)\n  test=Test()\n  test.test_first()\n  self.assertEqual(d,original)\n  test.test_second()\n  self.assertEqual(d,original)\n def test_get_only_proxy(self):\n  class Something(object):\n   foo='foo'\n  class SomethingElse:\n   foo='foo'\n  for thing in Something,SomethingElse,Something(),SomethingElse:\n   proxy=_get_proxy(thing)\n   @patch.object(proxy,'foo','bar')\n   def test():\n    self.assertEqual(proxy.foo,'bar')\n   test()\n   self.assertEqual(proxy.foo,'foo')\n   self.assertEqual(thing.foo,'foo')\n   self.assertNotIn('foo',proxy.__dict__)\n def test_get_set_delete_proxy(self):\n  class Something(object):\n   foo='foo'\n  class SomethingElse:\n   foo='foo'\n  for thing in Something,SomethingElse,Something(),SomethingElse:\n   proxy=_get_proxy(Something,get_only=False)\n   @patch.object(proxy,'foo','bar')\n   def test():\n    self.assertEqual(proxy.foo,'bar')\n   test()\n   self.assertEqual(proxy.foo,'foo')\n   self.assertEqual(thing.foo,'foo')\n   self.assertNotIn('foo',proxy.__dict__)\n def test_patch_keyword_args(self):\n  kwargs={'side_effect':KeyError,'foo.bar.return_value':33,\n  'foo':MagicMock()}\n  patcher=patch(foo_name,**kwargs)\n  mock=patcher.start()\n  patcher.stop()\n  self.assertRaises(KeyError,mock)\n  self.assertEqual(mock.foo.bar(),33)\n  self.assertIsInstance(mock.foo,MagicMock)\n def test_patch_object_keyword_args(self):\n  kwargs={'side_effect':KeyError,'foo.bar.return_value':33,\n  'foo':MagicMock()}\n  patcher=patch.object(Foo,'f',**kwargs)\n  mock=patcher.start()\n  patcher.stop()\n  self.assertRaises(KeyError,mock)\n  self.assertEqual(mock.foo.bar(),33)\n  self.assertIsInstance(mock.foo,MagicMock)\n def test_patch_dict_keyword_args(self):\n  original={'foo':'bar'}\n  copy=original.copy()\n  patcher=patch.dict(original,foo=3,bar=4,baz=5)\n  patcher.start()\n  try:\n   self.assertEqual(original,dict(foo=3,bar=4,baz=5))\n  finally:\n   patcher.stop()\n  self.assertEqual(original,copy)\n def test_autospec(self):\n  class Boo(object):\n   def __init__(self,a):\n    pass\n   def f(self,a):\n    pass\n   def g(self):\n    pass\n   foo='bar'\n   class Bar(object):\n    def a(self):\n     pass\n  def _test(mock):\n   mock(1)\n   mock.assert_called_with(1)\n   self.assertRaises(TypeError,mock)\n  def _test2(mock):\n   mock.f(1)\n   mock.f.assert_called_with(1)\n   self.assertRaises(TypeError,mock.f)\n   mock.g()\n   mock.g.assert_called_with()\n   self.assertRaises(TypeError,mock.g,1)\n   self.assertRaises(AttributeError,getattr,mock,'h')\n   mock.foo.lower()\n   mock.foo.lower.assert_called_with()\n   self.assertRaises(AttributeError,getattr,mock.foo,'bar')\n   mock.Bar()\n   mock.Bar.assert_called_with()\n   mock.Bar.a()\n   mock.Bar.a.assert_called_with()\n   self.assertRaises(TypeError,mock.Bar.a,1)\n   mock.Bar().a()\n   mock.Bar().a.assert_called_with()\n   self.assertRaises(TypeError,mock.Bar().a,1)\n   self.assertRaises(AttributeError,getattr,mock.Bar,'b')\n   self.assertRaises(AttributeError,getattr,mock.Bar(),'b')\n  def function(mock):\n   _test(mock)\n   _test2(mock)\n   _test2(mock(1))\n   self.assertIs(mock,Foo)\n   return mock\n  test=patch(foo_name,autospec=True)(function)\n  mock=test()\n  self.assertIsNot(Foo,mock)\n  test()\n  module=sys.modules[__name__]\n  test=patch.object(module,'Foo',autospec=True)(function)\n  mock=test()\n  self.assertIsNot(Foo,mock)\n  test()\n def test_autospec_function(self):\n  @patch('%s.function'%__name__,autospec=True)\n  def test(mock):\n   function(1)\n   function.assert_called_with(1)\n   function(2,3)\n   function.assert_called_with(2,3)\n   self.assertRaises(TypeError,function)\n   self.assertRaises(AttributeError,getattr,function,'foo')\n  test()\n def test_autospec_keywords(self):\n  @patch('%s.function'%__name__,autospec=True,\n  return_value=3)\n  def test(mock_function):\n   return function(1,2)\n  result=test()\n  self.assertEqual(result,3)\n def test_autospec_with_new(self):\n  patcher=patch('%s.function'%__name__,new=3,autospec=True)\n  self.assertRaises(TypeError,patcher.start)\n  module=sys.modules[__name__]\n  patcher=patch.object(module,'function',new=3,autospec=True)\n  self.assertRaises(TypeError,patcher.start)\n def test_autospec_with_object(self):\n  class Bar(Foo):\n   extra=[]\n  patcher=patch(foo_name,autospec=Bar)\n  mock=patcher.start()\n  try:\n   self.assertIsInstance(mock,Bar)\n   self.assertIsInstance(mock.extra,list)\n  finally:\n   patcher.stop()\n def test_autospec_inherits(self):\n  FooClass=Foo\n  patcher=patch(foo_name,autospec=True)\n  mock=patcher.start()\n  try:\n   self.assertIsInstance(mock,FooClass)\n   self.assertIsInstance(mock(3),FooClass)\n  finally:\n   patcher.stop()\n def test_autospec_name(self):\n  patcher=patch(foo_name,autospec=True)\n  mock=patcher.start()\n  try:\n   self.assertIn(\" name='Foo'\",repr(mock))\n   self.assertIn(\" name='Foo.f'\",repr(mock.f))\n   self.assertIn(\" name='Foo()'\",repr(mock(None)))\n   self.assertIn(\" name='Foo().f'\",repr(mock(None).f))\n  finally:\n   patcher.stop()\n def test_tracebacks(self):\n  @patch.object(Foo,'f',object())\n  def test():\n   raise AssertionError\n  try:\n   test()\n  except:\n   err=sys.exc_info()\n  result=unittest.TextTestResult(None,None,0)\n  traceback=result._exc_info_to_string(err,self)\n  self.assertIn('raise AssertionError',traceback)\n def test_new_callable_patch(self):\n  patcher=patch(foo_name,new_callable=NonCallableMagicMock)\n  m1=patcher.start()\n  patcher.stop()\n  m2=patcher.start()\n  patcher.stop()\n  self.assertIsNot(m1,m2)\n  for mock in m1,m2:\n   self.assertNotCallable(m1)\n def test_new_callable_patch_object(self):\n  patcher=patch.object(Foo,'f',new_callable=NonCallableMagicMock)\n  m1=patcher.start()\n  patcher.stop()\n  m2=patcher.start()\n  patcher.stop()\n  self.assertIsNot(m1,m2)\n  for mock in m1,m2:\n   self.assertNotCallable(m1)\n def test_new_callable_keyword_arguments(self):\n  class Bar(object):\n   kwargs=None\n   def __init__(self,**kwargs):\n    Bar.kwargs=kwargs\n  patcher=patch(foo_name,new_callable=Bar,arg1=1,arg2=2)\n  m=patcher.start()\n  try:\n   self.assertIs(type(m),Bar)\n   self.assertEqual(Bar.kwargs,dict(arg1=1,arg2=2))\n  finally:\n   patcher.stop()\n def test_new_callable_spec(self):\n  class Bar(object):\n   kwargs=None\n   def __init__(self,**kwargs):\n    Bar.kwargs=kwargs\n  patcher=patch(foo_name,new_callable=Bar,spec=Bar)\n  patcher.start()\n  try:\n   self.assertEqual(Bar.kwargs,dict(spec=Bar))\n  finally:\n   patcher.stop()\n  patcher=patch(foo_name,new_callable=Bar,spec_set=Bar)\n  patcher.start()\n  try:\n   self.assertEqual(Bar.kwargs,dict(spec_set=Bar))\n  finally:\n   patcher.stop()\n def test_new_callable_create(self):\n  non_existent_attr='%s.weeeee'%foo_name\n  p=patch(non_existent_attr,new_callable=NonCallableMock)\n  self.assertRaises(AttributeError,p.start)\n  p=patch(non_existent_attr,new_callable=NonCallableMock,\n  create=True)\n  m=p.start()\n  try:\n   self.assertNotCallable(m,magic=False)\n  finally:\n   p.stop()\n def test_new_callable_incompatible_with_new(self):\n  self.assertRaises(\n  ValueError,patch,foo_name,new=object(),new_callable=MagicMock\n  )\n  self.assertRaises(\n  ValueError,patch.object,Foo,'f',new=object(),\n  new_callable=MagicMock\n  )\n def test_new_callable_incompatible_with_autospec(self):\n  self.assertRaises(\n  ValueError,patch,foo_name,new_callable=MagicMock,\n  autospec=True\n  )\n  self.assertRaises(\n  ValueError,patch.object,Foo,'f',new_callable=MagicMock,\n  autospec=True\n  )\n def test_new_callable_inherit_for_mocks(self):\n  class MockSub(Mock):\n   pass\n  MockClasses=(\n  NonCallableMock,NonCallableMagicMock,MagicMock,Mock,MockSub\n  )\n  for Klass in MockClasses:\n   for arg in'spec','spec_set':\n    kwargs={arg:True}\n    p=patch(foo_name,new_callable=Klass,**kwargs)\n    m=p.start()\n    try:\n     instance=m.return_value\n     self.assertRaises(AttributeError,getattr,instance,'x')\n    finally:\n     p.stop()\n def test_new_callable_inherit_non_mock(self):\n  class NotAMock(object):\n   def __init__(self,spec):\n    self.spec=spec\n  p=patch(foo_name,new_callable=NotAMock,spec=True)\n  m=p.start()\n  try:\n   self.assertTrue(is_instance(m,NotAMock))\n   self.assertRaises(AttributeError,getattr,m,'return_value')\n  finally:\n   p.stop()\n  self.assertEqual(m.spec,Foo)\n def test_new_callable_class_decorating(self):\n  test=self\n  original=Foo\n  class SomeTest(object):\n   def _test(self,mock_foo):\n    test.assertIsNot(Foo,original)\n    test.assertIs(Foo,mock_foo)\n    test.assertIsInstance(Foo,SomeClass)\n   def test_two(self,mock_foo):\n    self._test(mock_foo)\n   def test_one(self,mock_foo):\n    self._test(mock_foo)\n  SomeTest=patch(foo_name,new_callable=SomeClass)(SomeTest)\n  SomeTest().test_one()\n  SomeTest().test_two()\n  self.assertIs(Foo,original)\n def test_patch_multiple(self):\n  original_foo=Foo\n  original_f=Foo.f\n  original_g=Foo.g\n  patcher1=patch.multiple(foo_name,f=1,g=2)\n  patcher2=patch.multiple(Foo,f=1,g=2)\n  for patcher in patcher1,patcher2:\n   patcher.start()\n   try:\n    self.assertIs(Foo,original_foo)\n    self.assertEqual(Foo.f,1)\n    self.assertEqual(Foo.g,2)\n   finally:\n    patcher.stop()\n   self.assertIs(Foo,original_foo)\n   self.assertEqual(Foo.f,original_f)\n   self.assertEqual(Foo.g,original_g)\n  @patch.multiple(foo_name,f=3,g=4)\n  def test():\n   self.assertIs(Foo,original_foo)\n   self.assertEqual(Foo.f,3)\n   self.assertEqual(Foo.g,4)\n  test()\n def test_patch_multiple_no_kwargs(self):\n  self.assertRaises(ValueError,patch.multiple,foo_name)\n  self.assertRaises(ValueError,patch.multiple,Foo)\n def test_patch_multiple_create_mocks(self):\n  original_foo=Foo\n  original_f=Foo.f\n  original_g=Foo.g\n  @patch.multiple(foo_name,f=DEFAULT,g=3,foo=DEFAULT)\n  def test(f,foo):\n   self.assertIs(Foo,original_foo)\n   self.assertIs(Foo.f,f)\n   self.assertEqual(Foo.g,3)\n   self.assertIs(Foo.foo,foo)\n   self.assertTrue(is_instance(f,MagicMock))\n   self.assertTrue(is_instance(foo,MagicMock))\n  test()\n  self.assertEqual(Foo.f,original_f)\n  self.assertEqual(Foo.g,original_g)\n def test_patch_multiple_create_mocks_different_order(self):\n  original_f=Foo.f\n  original_g=Foo.g\n  patcher=patch.object(Foo,'f',3)\n  patcher.attribute_name='f'\n  other=patch.object(Foo,'g',DEFAULT)\n  other.attribute_name='g'\n  patcher.additional_patchers=[other]\n  @patcher\n  def test(g):\n   self.assertIs(Foo.g,g)\n   self.assertEqual(Foo.f,3)\n  test()\n  self.assertEqual(Foo.f,original_f)\n  self.assertEqual(Foo.g,original_g)\n def test_patch_multiple_stacked_decorators(self):\n  original_foo=Foo\n  original_f=Foo.f\n  original_g=Foo.g\n  @patch.multiple(foo_name,f=DEFAULT)\n  @patch.multiple(foo_name,foo=DEFAULT)\n  @patch(foo_name+'.g')\n  def test1(g,**kwargs):\n   _test(g,**kwargs)\n  @patch.multiple(foo_name,f=DEFAULT)\n  @patch(foo_name+'.g')\n  @patch.multiple(foo_name,foo=DEFAULT)\n  def test2(g,**kwargs):\n   _test(g,**kwargs)\n  @patch(foo_name+'.g')\n  @patch.multiple(foo_name,f=DEFAULT)\n  @patch.multiple(foo_name,foo=DEFAULT)\n  def test3(g,**kwargs):\n   _test(g,**kwargs)\n  def _test(g,**kwargs):\n   f=kwargs.pop('f')\n   foo=kwargs.pop('foo')\n   self.assertFalse(kwargs)\n   self.assertIs(Foo,original_foo)\n   self.assertIs(Foo.f,f)\n   self.assertIs(Foo.g,g)\n   self.assertIs(Foo.foo,foo)\n   self.assertTrue(is_instance(f,MagicMock))\n   self.assertTrue(is_instance(g,MagicMock))\n   self.assertTrue(is_instance(foo,MagicMock))\n  test1()\n  test2()\n  test3()\n  self.assertEqual(Foo.f,original_f)\n  self.assertEqual(Foo.g,original_g)\n def test_patch_multiple_create_mocks_patcher(self):\n  original_foo=Foo\n  original_f=Foo.f\n  original_g=Foo.g\n  patcher=patch.multiple(foo_name,f=DEFAULT,g=3,foo=DEFAULT)\n  result=patcher.start()\n  try:\n   f=result['f']\n   foo=result['foo']\n   self.assertEqual(set(result),set(['f','foo']))\n   self.assertIs(Foo,original_foo)\n   self.assertIs(Foo.f,f)\n   self.assertIs(Foo.foo,foo)\n   self.assertTrue(is_instance(f,MagicMock))\n   self.assertTrue(is_instance(foo,MagicMock))\n  finally:\n   patcher.stop()\n  self.assertEqual(Foo.f,original_f)\n  self.assertEqual(Foo.g,original_g)\n def test_patch_multiple_decorating_class(self):\n  test=self\n  original_foo=Foo\n  original_f=Foo.f\n  original_g=Foo.g\n  class SomeTest(object):\n   def _test(self,f,foo):\n    test.assertIs(Foo,original_foo)\n    test.assertIs(Foo.f,f)\n    test.assertEqual(Foo.g,3)\n    test.assertIs(Foo.foo,foo)\n    test.assertTrue(is_instance(f,MagicMock))\n    test.assertTrue(is_instance(foo,MagicMock))\n   def test_two(self,f,foo):\n    self._test(f,foo)\n   def test_one(self,f,foo):\n    self._test(f,foo)\n  SomeTest=patch.multiple(\n  foo_name,f=DEFAULT,g=3,foo=DEFAULT\n  )(SomeTest)\n  thing=SomeTest()\n  thing.test_one()\n  thing.test_two()\n  self.assertEqual(Foo.f,original_f)\n  self.assertEqual(Foo.g,original_g)\n def test_patch_multiple_create(self):\n  patcher=patch.multiple(Foo,blam='blam')\n  self.assertRaises(AttributeError,patcher.start)\n  patcher=patch.multiple(Foo,blam='blam',create=True)\n  patcher.start()\n  try:\n   self.assertEqual(Foo.blam,'blam')\n  finally:\n   patcher.stop()\n  self.assertFalse(hasattr(Foo,'blam'))\n def test_patch_multiple_spec_set(self):\n  patcher=patch.multiple(Foo,foo=DEFAULT,spec_set=['a','b'])\n  result=patcher.start()\n  try:\n   self.assertEqual(Foo.foo,result['foo'])\n   Foo.foo.a(1)\n   Foo.foo.b(2)\n   Foo.foo.a.assert_called_with(1)\n   Foo.foo.b.assert_called_with(2)\n   self.assertRaises(AttributeError,setattr,Foo.foo,'c',None)\n  finally:\n   patcher.stop()\n def test_patch_multiple_new_callable(self):\n  class Thing(object):\n   pass\n  patcher=patch.multiple(\n  Foo,f=DEFAULT,g=DEFAULT,new_callable=Thing\n  )\n  result=patcher.start()\n  try:\n   self.assertIs(Foo.f,result['f'])\n   self.assertIs(Foo.g,result['g'])\n   self.assertIsInstance(Foo.f,Thing)\n   self.assertIsInstance(Foo.g,Thing)\n   self.assertIsNot(Foo.f,Foo.g)\n  finally:\n   patcher.stop()\n def test_nested_patch_failure(self):\n  original_f=Foo.f\n  original_g=Foo.g\n  @patch.object(Foo,'g',1)\n  @patch.object(Foo,'missing',1)\n  @patch.object(Foo,'f',1)\n  def thing1():\n   pass\n  @patch.object(Foo,'missing',1)\n  @patch.object(Foo,'g',1)\n  @patch.object(Foo,'f',1)\n  def thing2():\n   pass\n  @patch.object(Foo,'g',1)\n  @patch.object(Foo,'f',1)\n  @patch.object(Foo,'missing',1)\n  def thing3():\n   pass\n  for func in thing1,thing2,thing3:\n   self.assertRaises(AttributeError,func)\n   self.assertEqual(Foo.f,original_f)\n   self.assertEqual(Foo.g,original_g)\n def test_new_callable_failure(self):\n  original_f=Foo.f\n  original_g=Foo.g\n  original_foo=Foo.foo\n  def crasher():\n   raise NameError('crasher')\n  @patch.object(Foo,'g',1)\n  @patch.object(Foo,'foo',new_callable=crasher)\n  @patch.object(Foo,'f',1)\n  def thing1():\n   pass\n  @patch.object(Foo,'foo',new_callable=crasher)\n  @patch.object(Foo,'g',1)\n  @patch.object(Foo,'f',1)\n  def thing2():\n   pass\n  @patch.object(Foo,'g',1)\n  @patch.object(Foo,'f',1)\n  @patch.object(Foo,'foo',new_callable=crasher)\n  def thing3():\n   pass\n  for func in thing1,thing2,thing3:\n   self.assertRaises(NameError,func)\n   self.assertEqual(Foo.f,original_f)\n   self.assertEqual(Foo.g,original_g)\n   self.assertEqual(Foo.foo,original_foo)\n def test_patch_multiple_failure(self):\n  original_f=Foo.f\n  original_g=Foo.g\n  patcher=patch.object(Foo,'f',1)\n  patcher.attribute_name='f'\n  good=patch.object(Foo,'g',1)\n  good.attribute_name='g'\n  bad=patch.object(Foo,'missing',1)\n  bad.attribute_name='missing'\n  for additionals in[good,bad],[bad,good]:\n   patcher.additional_patchers=additionals\n   @patcher\n   def func():\n    pass\n   self.assertRaises(AttributeError,func)\n   self.assertEqual(Foo.f,original_f)\n   self.assertEqual(Foo.g,original_g)\n def test_patch_multiple_new_callable_failure(self):\n  original_f=Foo.f\n  original_g=Foo.g\n  original_foo=Foo.foo\n  def crasher():\n   raise NameError('crasher')\n  patcher=patch.object(Foo,'f',1)\n  patcher.attribute_name='f'\n  good=patch.object(Foo,'g',1)\n  good.attribute_name='g'\n  bad=patch.object(Foo,'foo',new_callable=crasher)\n  bad.attribute_name='foo'\n  for additionals in[good,bad],[bad,good]:\n   patcher.additional_patchers=additionals\n   @patcher\n   def func():\n    pass\n   self.assertRaises(NameError,func)\n   self.assertEqual(Foo.f,original_f)\n   self.assertEqual(Foo.g,original_g)\n   self.assertEqual(Foo.foo,original_foo)\n def test_patch_multiple_string_subclasses(self):\n  Foo=type('Foo',(str,),{'fish':'tasty'})\n  foo=Foo()\n  @patch.multiple(foo,fish='nearly gone')\n  def test():\n   self.assertEqual(foo.fish,'nearly gone')\n  test()\n  self.assertEqual(foo.fish,'tasty')\n @patch('unittest.mock.patch.TEST_PREFIX','foo')\n def test_patch_test_prefix(self):\n  class Foo(object):\n   thing='original'\n   def foo_one(self):\n    return self.thing\n   def foo_two(self):\n    return self.thing\n   def test_one(self):\n    return self.thing\n   def test_two(self):\n    return self.thing\n  Foo=patch.object(Foo,'thing','changed')(Foo)\n  foo=Foo()\n  self.assertEqual(foo.foo_one(),'changed')\n  self.assertEqual(foo.foo_two(),'changed')\n  self.assertEqual(foo.test_one(),'original')\n  self.assertEqual(foo.test_two(),'original')\n @patch('unittest.mock.patch.TEST_PREFIX','bar')\n def test_patch_dict_test_prefix(self):\n  class Foo(object):\n   def bar_one(self):\n    return dict(the_dict)\n   def bar_two(self):\n    return dict(the_dict)\n   def test_one(self):\n    return dict(the_dict)\n   def test_two(self):\n    return dict(the_dict)\n  the_dict={'key':'original'}\n  Foo=patch.dict(the_dict,key='changed')(Foo)\n  foo=Foo()\n  self.assertEqual(foo.bar_one(),{'key':'changed'})\n  self.assertEqual(foo.bar_two(),{'key':'changed'})\n  self.assertEqual(foo.test_one(),{'key':'original'})\n  self.assertEqual(foo.test_two(),{'key':'original'})\n def test_patch_with_spec_mock_repr(self):\n  for arg in('spec','autospec','spec_set'):\n   p=patch('%s.SomeClass'%__name__,**{arg:True})\n   m=p.start()\n   try:\n    self.assertIn(\" name='SomeClass'\",repr(m))\n    self.assertIn(\" name='SomeClass.class_attribute'\",\n    repr(m.class_attribute))\n    self.assertIn(\" name='SomeClass()'\",repr(m()))\n    self.assertIn(\" name='SomeClass().class_attribute'\",\n    repr(m().class_attribute))\n   finally:\n    p.stop()\n def test_patch_nested_autospec_repr(self):\n  with patch('unittest.test.testmock.support',autospec=True)as m:\n   self.assertIn(\" name='support.SomeClass.wibble()'\",\n   repr(m.SomeClass.wibble()))\n   self.assertIn(\" name='support.SomeClass().wibble()'\",\n   repr(m.SomeClass().wibble()))\n def test_mock_calls_with_patch(self):\n  for arg in('spec','autospec','spec_set'):\n   p=patch('%s.SomeClass'%__name__,**{arg:True})\n   m=p.start()\n   try:\n    m.wibble()\n    kalls=[call.wibble()]\n    self.assertEqual(m.mock_calls,kalls)\n    self.assertEqual(m.method_calls,kalls)\n    self.assertEqual(m.wibble.mock_calls,[call()])\n    result=m()\n    kalls.append(call())\n    self.assertEqual(m.mock_calls,kalls)\n    result.wibble()\n    kalls.append(call().wibble())\n    self.assertEqual(m.mock_calls,kalls)\n    self.assertEqual(result.mock_calls,[call.wibble()])\n    self.assertEqual(result.wibble.mock_calls,[call()])\n    self.assertEqual(result.method_calls,[call.wibble()])\n   finally:\n    p.stop()\n def test_patch_imports_lazily(self):\n  sys.modules.pop('squizz',None)\n  p1=patch('squizz.squozz')\n  self.assertRaises(ImportError,p1.start)\n  squizz=Mock()\n  squizz.squozz=6\n  sys.modules['squizz']=squizz\n  p1=patch('squizz.squozz')\n  squizz.squozz=3\n  p1.start()\n  p1.stop()\n  self.assertEqual(squizz.squozz,3)\n def test_patch_propogrates_exc_on_exit(self):\n  class holder:\n   exc_info=None,None,None\n  class custom_patch(_patch):\n   def __exit__(self,etype=None,val=None,tb=None):\n    _patch.__exit__(self,etype,val,tb)\n    holder.exc_info=etype,val,tb\n   stop=__exit__\n  def with_custom_patch(target):\n   getter,attribute=_get_target(target)\n   return custom_patch(\n   getter,attribute,DEFAULT,None,False,None,\n   None,None,{}\n   )\n  @with_custom_patch('squizz.squozz')\n  def test(mock):\n   raise RuntimeError\n  self.assertRaises(RuntimeError,test)\n  self.assertIs(holder.exc_info[0],RuntimeError)\n  self.assertIsNotNone(holder.exc_info[1],\n  'exception value not propgated')\n  self.assertIsNotNone(holder.exc_info[2],\n  'exception traceback not propgated')\n def test_create_and_specs(self):\n  for kwarg in('spec','spec_set','autospec'):\n   p=patch('%s.doesnotexist'%__name__,create=True,\n   **{kwarg:True})\n   self.assertRaises(TypeError,p.start)\n   self.assertRaises(NameError,lambda:doesnotexist)\n   p=patch(MODNAME,create=True,**{kwarg:True})\n   p.start()\n   p.stop()\n def test_multiple_specs(self):\n  original=PTModule\n  for kwarg in('spec','spec_set'):\n   p=patch(MODNAME,autospec=0,**{kwarg:0})\n   self.assertRaises(TypeError,p.start)\n   self.assertIs(PTModule,original)\n  for kwarg in('spec','autospec'):\n   p=patch(MODNAME,spec_set=0,**{kwarg:0})\n   self.assertRaises(TypeError,p.start)\n   self.assertIs(PTModule,original)\n  for kwarg in('spec_set','autospec'):\n   p=patch(MODNAME,spec=0,**{kwarg:0})\n   self.assertRaises(TypeError,p.start)\n   self.assertIs(PTModule,original)\n def test_specs_false_instead_of_none(self):\n  p=patch(MODNAME,spec=False,spec_set=False,autospec=False)\n  mock=p.start()\n  try:\n   mock.does_not_exist\n   mock.does_not_exist=3\n  finally:\n   p.stop()\n def test_falsey_spec(self):\n  for kwarg in('spec','autospec','spec_set'):\n   p=patch(MODNAME,**{kwarg:0})\n   m=p.start()\n   try:\n    self.assertRaises(AttributeError,getattr,m,'doesnotexit')\n   finally:\n    p.stop()\n def test_spec_set_true(self):\n  for kwarg in('spec','autospec'):\n   p=patch(MODNAME,spec_set=True,**{kwarg:True})\n   m=p.start()\n   try:\n    self.assertRaises(AttributeError,setattr,m,\n    'doesnotexist','something')\n    self.assertRaises(AttributeError,getattr,m,'doesnotexist')\n   finally:\n    p.stop()\n def test_callable_spec_as_list(self):\n  spec=('__call__',)\n  p=patch(MODNAME,spec=spec)\n  m=p.start()\n  try:\n   self.assertTrue(callable(m))\n  finally:\n   p.stop()\n def test_not_callable_spec_as_list(self):\n  spec=('foo','bar')\n  p=patch(MODNAME,spec=spec)\n  m=p.start()\n  try:\n   self.assertFalse(callable(m))\n  finally:\n   p.stop()\n def test_patch_stopall(self):\n  unlink=os.unlink\n  chdir=os.chdir\n  path=os.path\n  patch('os.unlink',something).start()\n  patch('os.chdir',something_else).start()\n  @patch('os.path')\n  def patched(mock_path):\n   patch.stopall()\n   self.assertIs(os.path,mock_path)\n   self.assertIs(os.unlink,unlink)\n   self.assertIs(os.chdir,chdir)\n  patched()\n  self.assertIs(os.path,path)\nif __name__=='__main__':\n unittest.main()\n"], "unittest.test.testmock.testmagicmethods": ["import unittest\nimport inspect\nimport sys\nfrom unittest.mock import Mock,MagicMock,_magics\nclass TestMockingMagicMethods(unittest.TestCase):\n def test_deleting_magic_methods(self):\n  mock=Mock()\n  self.assertFalse(hasattr(mock,'__getitem__'))\n  mock.__getitem__=Mock()\n  self.assertTrue(hasattr(mock,'__getitem__'))\n  del mock.__getitem__\n  self.assertFalse(hasattr(mock,'__getitem__'))\n def test_magicmock_del(self):\n  mock=MagicMock()\n  del mock.__getitem__\n  self.assertRaises(TypeError,lambda:mock['foo'])\n  mock=MagicMock()\n  mock['foo']\n  del mock.__getitem__\n  self.assertRaises(TypeError,lambda:mock['foo'])\n def test_magic_method_wrapping(self):\n  mock=Mock()\n  def f(self,name):\n   return self,'fish'\n  mock.__getitem__=f\n  self.assertFalse(mock.__getitem__ is f)\n  self.assertEqual(mock['foo'],(mock,'fish'))\n  self.assertEqual(mock.__getitem__('foo'),(mock,'fish'))\n  mock.__getitem__=mock\n  self.assertTrue(mock.__getitem__ is mock)\n def test_magic_methods_isolated_between_mocks(self):\n  mock1=Mock()\n  mock2=Mock()\n  mock1.__iter__=Mock(return_value=iter([]))\n  self.assertEqual(list(mock1),[])\n  self.assertRaises(TypeError,lambda:list(mock2))\n def test_repr(self):\n  mock=Mock()\n  self.assertEqual(repr(mock),\"<Mock id='%s'>\"%id(mock))\n  mock.__repr__=lambda s:'foo'\n  self.assertEqual(repr(mock),'foo')\n def test_str(self):\n  mock=Mock()\n  self.assertEqual(str(mock),object.__str__(mock))\n  mock.__str__=lambda s:'foo'\n  self.assertEqual(str(mock),'foo')\n def test_dict_methods(self):\n  mock=Mock()\n  self.assertRaises(TypeError,lambda:mock['foo'])\n  def _del():\n   del mock['foo']\n  def _set():\n   mock['foo']=3\n  self.assertRaises(TypeError,_del)\n  self.assertRaises(TypeError,_set)\n  _dict={}\n  def getitem(s,name):\n   return _dict[name]\n  def setitem(s,name,value):\n   _dict[name]=value\n  def delitem(s,name):\n   del _dict[name]\n  mock.__setitem__=setitem\n  mock.__getitem__=getitem\n  mock.__delitem__=delitem\n  self.assertRaises(KeyError,lambda:mock['foo'])\n  mock['foo']='bar'\n  self.assertEqual(_dict,{'foo':'bar'})\n  self.assertEqual(mock['foo'],'bar')\n  del mock['foo']\n  self.assertEqual(_dict,{})\n def test_numeric(self):\n  original=mock=Mock()\n  mock.value=0\n  self.assertRaises(TypeError,lambda:mock+3)\n  def add(self,other):\n   mock.value+=other\n   return self\n  mock.__add__=add\n  self.assertEqual(mock+3,mock)\n  self.assertEqual(mock.value,3)\n  del mock.__add__\n  def iadd(mock):\n   mock+=3\n  self.assertRaises(TypeError,iadd,mock)\n  mock.__iadd__=add\n  mock+=6\n  self.assertEqual(mock,original)\n  self.assertEqual(mock.value,9)\n  self.assertRaises(TypeError,lambda:3+mock)\n  mock.__radd__=add\n  self.assertEqual(7+mock,mock)\n  self.assertEqual(mock.value,16)\n def test_hash(self):\n  mock=Mock()\n  self.assertEqual(hash(mock),Mock.__hash__(mock))\n  def _hash(s):\n   return 3\n  mock.__hash__=_hash\n  self.assertEqual(hash(mock),3)\n def test_nonzero(self):\n  m=Mock()\n  self.assertTrue(bool(m))\n  m.__bool__=lambda s:False\n  self.assertFalse(bool(m))\n def test_comparison(self):\n  mock=Mock()\n  def comp(s,o):\n   return True\n  mock.__lt__=mock.__gt__=mock.__le__=mock.__ge__=comp\n  self.assertTrue(mock<3)\n  self.assertTrue(mock>3)\n  self.assertTrue(mock<=3)\n  self.assertTrue(mock>=3)\n  self.assertRaises(TypeError,lambda:MagicMock()<object())\n  self.assertRaises(TypeError,lambda:object()<MagicMock())\n  self.assertRaises(TypeError,lambda:MagicMock()<MagicMock())\n  self.assertRaises(TypeError,lambda:MagicMock()>object())\n  self.assertRaises(TypeError,lambda:object()>MagicMock())\n  self.assertRaises(TypeError,lambda:MagicMock()>MagicMock())\n  self.assertRaises(TypeError,lambda:MagicMock()<=object())\n  self.assertRaises(TypeError,lambda:object()<=MagicMock())\n  self.assertRaises(TypeError,lambda:MagicMock()<=MagicMock())\n  self.assertRaises(TypeError,lambda:MagicMock()>=object())\n  self.assertRaises(TypeError,lambda:object()>=MagicMock())\n  self.assertRaises(TypeError,lambda:MagicMock()>=MagicMock())\n def test_equality(self):\n  for mock in Mock(),MagicMock():\n   self.assertEqual(mock==mock,True)\n   self.assertIsInstance(mock==mock,bool)\n   self.assertEqual(mock!=mock,False)\n   self.assertIsInstance(mock!=mock,bool)\n   self.assertEqual(mock==object(),False)\n   self.assertEqual(mock!=object(),True)\n   def eq(self,other):\n    return other==3\n   mock.__eq__=eq\n   self.assertTrue(mock==3)\n   self.assertFalse(mock==4)\n   def ne(self,other):\n    return other==3\n   mock.__ne__=ne\n   self.assertTrue(mock!=3)\n   self.assertFalse(mock!=4)\n  mock=MagicMock()\n  mock.__eq__.return_value=True\n  self.assertIsInstance(mock==3,bool)\n  self.assertEqual(mock==3,True)\n  mock.__ne__.return_value=False\n  self.assertIsInstance(mock!=3,bool)\n  self.assertEqual(mock!=3,False)\n def test_len_contains_iter(self):\n  mock=Mock()\n  self.assertRaises(TypeError,len,mock)\n  self.assertRaises(TypeError,iter,mock)\n  self.assertRaises(TypeError,lambda:'foo'in mock)\n  mock.__len__=lambda s:6\n  self.assertEqual(len(mock),6)\n  mock.__contains__=lambda s,o:o==3\n  self.assertTrue(3 in mock)\n  self.assertFalse(6 in mock)\n  mock.__iter__=lambda s:iter('foobarbaz')\n  self.assertEqual(list(mock),list('foobarbaz'))\n def test_magicmock(self):\n  mock=MagicMock()\n  mock.__iter__.return_value=iter([1,2,3])\n  self.assertEqual(list(mock),[1,2,3])\n  getattr(mock,'__bool__').return_value=False\n  self.assertFalse(hasattr(mock,'__nonzero__'))\n  self.assertFalse(bool(mock))\n  for entry in _magics:\n   self.assertTrue(hasattr(mock,entry))\n  self.assertFalse(hasattr(mock,'__imaginery__'))\n def test_magic_mock_equality(self):\n  mock=MagicMock()\n  self.assertIsInstance(mock==object(),bool)\n  self.assertIsInstance(mock!=object(),bool)\n  self.assertEqual(mock==object(),False)\n  self.assertEqual(mock!=object(),True)\n  self.assertEqual(mock==mock,True)\n  self.assertEqual(mock!=mock,False)\n def test_magicmock_defaults(self):\n  mock=MagicMock()\n  self.assertEqual(int(mock),1)\n  self.assertEqual(complex(mock),1j)\n  self.assertEqual(float(mock),1.0)\n  self.assertNotIn(object(),mock)\n  self.assertEqual(len(mock),0)\n  self.assertEqual(list(mock),[])\n  self.assertEqual(hash(mock),object.__hash__(mock))\n  self.assertEqual(str(mock),object.__str__(mock))\n  self.assertTrue(bool(mock))\n  self.assertEqual(oct(mock),'0o1')\n  self.assertEqual(hex(mock),'0x1')\n def test_magic_methods_and_spec(self):\n  class Iterable(object):\n   def __iter__(self):\n    pass\n  mock=Mock(spec=Iterable)\n  self.assertRaises(AttributeError,lambda:mock.__iter__)\n  mock.__iter__=Mock(return_value=iter([]))\n  self.assertEqual(list(mock),[])\n  class NonIterable(object):\n   pass\n  mock=Mock(spec=NonIterable)\n  self.assertRaises(AttributeError,lambda:mock.__iter__)\n  def set_int():\n   mock.__int__=Mock(return_value=iter([]))\n  self.assertRaises(AttributeError,set_int)\n  mock=MagicMock(spec=Iterable)\n  self.assertEqual(list(mock),[])\n  self.assertRaises(AttributeError,set_int)\n def test_magic_methods_and_spec_set(self):\n  class Iterable(object):\n   def __iter__(self):\n    pass\n  mock=Mock(spec_set=Iterable)\n  self.assertRaises(AttributeError,lambda:mock.__iter__)\n  mock.__iter__=Mock(return_value=iter([]))\n  self.assertEqual(list(mock),[])\n  class NonIterable(object):\n   pass\n  mock=Mock(spec_set=NonIterable)\n  self.assertRaises(AttributeError,lambda:mock.__iter__)\n  def set_int():\n   mock.__int__=Mock(return_value=iter([]))\n  self.assertRaises(AttributeError,set_int)\n  mock=MagicMock(spec_set=Iterable)\n  self.assertEqual(list(mock),[])\n  self.assertRaises(AttributeError,set_int)\n def test_setting_unsupported_magic_method(self):\n  mock=MagicMock()\n  def set_setattr():\n   mock.__setattr__=lambda self,name:None\n  self.assertRaisesRegex(AttributeError,\n  \"Attempting to set unsupported magic method '__setattr__'.\",\n  set_setattr\n  )\n def test_attributes_and_return_value(self):\n  mock=MagicMock()\n  attr=mock.foo\n  def _get_type(obj):\n   return type(obj).__mro__[1]\n  self.assertEqual(_get_type(attr),MagicMock)\n  returned=mock()\n  self.assertEqual(_get_type(returned),MagicMock)\n def test_magic_methods_are_magic_mocks(self):\n  mock=MagicMock()\n  self.assertIsInstance(mock.__getitem__,MagicMock)\n  mock[1][2].__getitem__.return_value=3\n  self.assertEqual(mock[1][2][3],3)\n def test_magic_method_reset_mock(self):\n  mock=MagicMock()\n  str(mock)\n  self.assertTrue(mock.__str__.called)\n  mock.reset_mock()\n  self.assertFalse(mock.__str__.called)\n def test_dir(self):\n  for mock in Mock(),MagicMock():\n   def _dir(self):\n    return['foo']\n   mock.__dir__=_dir\n   self.assertEqual(dir(mock),['foo'])\n @unittest.skipIf('PyPy'in sys.version,\"This fails differently on pypy\")\n def test_bound_methods(self):\n  m=Mock()\n  m.__iter__=[3].__iter__\n  self.assertRaises(TypeError,iter,m)\n def test_magic_method_type(self):\n  class Foo(MagicMock):\n   pass\n  foo=Foo()\n  self.assertIsInstance(foo.__int__,Foo)\n def test_descriptor_from_class(self):\n  m=MagicMock()\n  type(m).__str__.return_value='foo'\n  self.assertEqual(str(m),'foo')\n def test_iterable_as_iter_return_value(self):\n  m=MagicMock()\n  m.__iter__.return_value=[1,2,3]\n  self.assertEqual(list(m),[1,2,3])\n  self.assertEqual(list(m),[1,2,3])\n  m.__iter__.return_value=iter([4,5,6])\n  self.assertEqual(list(m),[4,5,6])\n  self.assertEqual(list(m),[])\nif __name__=='__main__':\n unittest.main()\n"], "unittest.signals": ["import signal\nimport weakref\nfrom functools import wraps\n__unittest=True\nclass _InterruptHandler(object):\n def __init__(self,default_handler):\n  self.called=False\n  self.original_handler=default_handler\n  if isinstance(default_handler,int):\n   if default_handler==signal.SIG_DFL:\n    default_handler=signal.default_int_handler\n   elif default_handler==signal.SIG_IGN:\n    def default_handler(unused_signum,unused_frame):\n     pass\n   else:\n    raise TypeError(\"expected SIGINT signal handler to be \"\n    \"signal.SIG_IGN, signal.SIG_DFL, or a \"\n    \"callable object\")\n  self.default_handler=default_handler\n def __call__(self,signum,frame):\n  installed_handler=signal.getsignal(signal.SIGINT)\n  if installed_handler is not self:\n   self.default_handler(signum,frame)\n  if self.called:\n   self.default_handler(signum,frame)\n  self.called=True\n  for result in _results.keys():\n   result.stop()\n_results=weakref.WeakKeyDictionary()\ndef registerResult(result):\n _results[result]=1\ndef removeResult(result):\n return bool(_results.pop(result,None))\n_interrupt_handler=None\ndef installHandler():\n global _interrupt_handler\n if _interrupt_handler is None:\n  default_handler=signal.getsignal(signal.SIGINT)\n  _interrupt_handler=_InterruptHandler(default_handler)\n  signal.signal(signal.SIGINT,_interrupt_handler)\ndef removeHandler(method=None):\n if method is not None:\n  @wraps(method)\n  def inner(*args,**kwargs):\n   initial=signal.getsignal(signal.SIGINT)\n   removeHandler()\n   try:\n    return method(*args,**kwargs)\n   finally:\n    signal.signal(signal.SIGINT,initial)\n  return inner\n global _interrupt_handler\n if _interrupt_handler is not None:\n  signal.signal(signal.SIGINT,_interrupt_handler.original_handler)\n"], "unittest.test.support": ["import unittest\nclass TestEquality(object):\n def test_eq(self):\n  for obj_1,obj_2 in self.eq_pairs:\n   self.assertEqual(obj_1,obj_2)\n   self.assertEqual(obj_2,obj_1)\n def test_ne(self):\n  for obj_1,obj_2 in self.ne_pairs:\n   self.assertNotEqual(obj_1,obj_2)\n   self.assertNotEqual(obj_2,obj_1)\nclass TestHashing(object):\n def test_hash(self):\n  for obj_1,obj_2 in self.eq_pairs:\n   try:\n    if not hash(obj_1)==hash(obj_2):\n     self.fail(\"%r and %r do not hash equal\"%(obj_1,obj_2))\n   except KeyboardInterrupt:\n    raise\n   except Exception as e:\n    self.fail(\"Problem hashing %r and %r: %s\"%(obj_1,obj_2,e))\n  for obj_1,obj_2 in self.ne_pairs:\n   try:\n    if hash(obj_1)==hash(obj_2):\n     self.fail(\"%s and %s hash equal, but shouldn't\"%\n     (obj_1,obj_2))\n   except KeyboardInterrupt:\n    raise\n   except Exception as e:\n    self.fail(\"Problem hashing %s and %s: %s\"%(obj_1,obj_2,e))\nclass LoggingResult(unittest.TestResult):\n def __init__(self,log):\n  self._events=log\n  super().__init__()\n def startTest(self,test):\n  self._events.append('startTest')\n  super().startTest(test)\n def startTestRun(self):\n  self._events.append('startTestRun')\n  super(LoggingResult,self).startTestRun()\n def stopTest(self,test):\n  self._events.append('stopTest')\n  super().stopTest(test)\n def stopTestRun(self):\n  self._events.append('stopTestRun')\n  super(LoggingResult,self).stopTestRun()\n def addFailure(self,*args):\n  self._events.append('addFailure')\n  super().addFailure(*args)\n def addSuccess(self,*args):\n  self._events.append('addSuccess')\n  super(LoggingResult,self).addSuccess(*args)\n def addError(self,*args):\n  self._events.append('addError')\n  super().addError(*args)\n def addSkip(self,*args):\n  self._events.append('addSkip')\n  super(LoggingResult,self).addSkip(*args)\n def addExpectedFailure(self,*args):\n  self._events.append('addExpectedFailure')\n  super(LoggingResult,self).addExpectedFailure(*args)\n def addUnexpectedSuccess(self,*args):\n  self._events.append('addUnexpectedSuccess')\n  super(LoggingResult,self).addUnexpectedSuccess(*args)\nclass ResultWithNoStartTestRunStopTestRun(object):\n def __init__(self):\n  self.failures=[]\n  self.errors=[]\n  self.testsRun=0\n  self.skipped=[]\n  self.expectedFailures=[]\n  self.unexpectedSuccesses=[]\n  self.shouldStop=False\n def startTest(self,test):\n  pass\n def stopTest(self,test):\n  pass\n def addError(self,test):\n  pass\n def addFailure(self,test):\n  pass\n def addSuccess(self,test):\n  pass\n def wasSuccessful(self):\n  return True\n"], "unittest.test.test_program": ["import io\nimport os\nimport sys\nimport unittest\nclass Test_TestProgram(unittest.TestCase):\n def test_discovery_from_dotted_path(self):\n  loader=unittest.TestLoader()\n  tests=[self]\n  expectedPath=os.path.abspath(os.path.dirname(unittest.test.__file__))\n  self.wasRun=False\n  def _find_tests(start_dir,pattern):\n   self.wasRun=True\n   self.assertEqual(start_dir,expectedPath)\n   return tests\n  loader._find_tests=_find_tests\n  suite=loader.discover('unittest.test')\n  self.assertTrue(self.wasRun)\n  self.assertEqual(suite._tests,tests)\n def testNoExit(self):\n  result=object()\n  test=object()\n  class FakeRunner(object):\n   def run(self,test):\n    self.test=test\n    return result\n  runner=FakeRunner()\n  oldParseArgs=unittest.TestProgram.parseArgs\n  def restoreParseArgs():\n   unittest.TestProgram.parseArgs=oldParseArgs\n  unittest.TestProgram.parseArgs=lambda*args:None\n  self.addCleanup(restoreParseArgs)\n  def removeTest():\n   del unittest.TestProgram.test\n  unittest.TestProgram.test=test\n  self.addCleanup(removeTest)\n  program=unittest.TestProgram(testRunner=runner,exit=False,verbosity=2)\n  self.assertEqual(program.result,result)\n  self.assertEqual(runner.test,test)\n  self.assertEqual(program.verbosity,2)\n class FooBar(unittest.TestCase):\n  def testPass(self):\n   assert True\n  def testFail(self):\n   assert False\n class FooBarLoader(unittest.TestLoader):\n  def loadTestsFromModule(self,module):\n   return self.suiteClass(\n   [self.loadTestsFromTestCase(Test_TestProgram.FooBar)])\n def test_NonExit(self):\n  program=unittest.main(exit=False,\n  argv=[\"foobar\"],\n  testRunner=unittest.TextTestRunner(stream=io.StringIO()),\n  testLoader=self.FooBarLoader())\n  self.assertTrue(hasattr(program,'result'))\n def test_Exit(self):\n  self.assertRaises(\n  SystemExit,\n  unittest.main,\n  argv=[\"foobar\"],\n  testRunner=unittest.TextTestRunner(stream=io.StringIO()),\n  exit=True,\n  testLoader=self.FooBarLoader())\n def test_ExitAsDefault(self):\n  self.assertRaises(\n  SystemExit,\n  unittest.main,\n  argv=[\"foobar\"],\n  testRunner=unittest.TextTestRunner(stream=io.StringIO()),\n  testLoader=self.FooBarLoader())\nclass InitialisableProgram(unittest.TestProgram):\n exit=False\n result=None\n verbosity=1\n defaultTest=None\n testRunner=None\n testLoader=unittest.defaultTestLoader\n module='__main__'\n progName='test'\n test='test'\n def __init__(self,*args):\n  pass\nRESULT=object()\nclass FakeRunner(object):\n initArgs=None\n test=None\n raiseError=False\n def __init__(self,**kwargs):\n  FakeRunner.initArgs=kwargs\n  if FakeRunner.raiseError:\n   FakeRunner.raiseError=False\n   raise TypeError\n def run(self,test):\n  FakeRunner.test=test\n  return RESULT\nclass TestCommandLineArgs(unittest.TestCase):\n def setUp(self):\n  self.program=InitialisableProgram()\n  self.program.createTests=lambda:None\n  FakeRunner.initArgs=None\n  FakeRunner.test=None\n  FakeRunner.raiseError=False\n def testVerbosity(self):\n  program=self.program\n  for opt in'-q','--quiet':\n   program.verbosity=1\n   program.parseArgs([None,opt])\n   self.assertEqual(program.verbosity,0)\n  for opt in'-v','--verbose':\n   program.verbosity=1\n   program.parseArgs([None,opt])\n   self.assertEqual(program.verbosity,2)\n def testBufferCatchFailfast(self):\n  program=self.program\n  for arg,attr in(('buffer','buffer'),('failfast','failfast'),\n  ('catch','catchbreak')):\n   if attr=='catch'and not hasInstallHandler:\n    continue\n   short_opt='-%s'%arg[0]\n   long_opt='--%s'%arg\n   for opt in short_opt,long_opt:\n    setattr(program,attr,None)\n    program.parseArgs([None,opt])\n    self.assertTrue(getattr(program,attr))\n   for opt in short_opt,long_opt:\n    not_none=object()\n    setattr(program,attr,not_none)\n    program.parseArgs([None,opt])\n    self.assertEqual(getattr(program,attr),not_none)\n def testWarning(self):\n  class FakeTP(unittest.TestProgram):\n   def parseArgs(self,*args,**kw):pass\n   def runTests(self,*args,**kw):pass\n  warnoptions=sys.warnoptions[:]\n  try:\n   sys.warnoptions[:]=[]\n   self.assertEqual(FakeTP().warnings,'default')\n   self.assertEqual(FakeTP(warnings='ignore').warnings,'ignore')\n   sys.warnoptions[:]=['somevalue']\n   self.assertEqual(FakeTP().warnings,None)\n   self.assertEqual(FakeTP(warnings='ignore').warnings,'ignore')\n  finally:\n   sys.warnoptions[:]=warnoptions\n def testRunTestsRunnerClass(self):\n  program=self.program\n  program.testRunner=FakeRunner\n  program.verbosity='verbosity'\n  program.failfast='failfast'\n  program.buffer='buffer'\n  program.warnings='warnings'\n  program.runTests()\n  self.assertEqual(FakeRunner.initArgs,{'verbosity':'verbosity',\n  'failfast':'failfast',\n  'buffer':'buffer',\n  'warnings':'warnings'})\n  self.assertEqual(FakeRunner.test,'test')\n  self.assertIs(program.result,RESULT)\n def testRunTestsRunnerInstance(self):\n  program=self.program\n  program.testRunner=FakeRunner()\n  FakeRunner.initArgs=None\n  program.runTests()\n  self.assertIsNone(FakeRunner.initArgs)\n  self.assertEqual(FakeRunner.test,'test')\n  self.assertIs(program.result,RESULT)\n def testRunTestsOldRunnerClass(self):\n  program=self.program\n  FakeRunner.raiseError=True\n  program.testRunner=FakeRunner\n  program.verbosity='verbosity'\n  program.failfast='failfast'\n  program.buffer='buffer'\n  program.test='test'\n  program.runTests()\n  self.assertEqual(FakeRunner.initArgs,{})\n  self.assertEqual(FakeRunner.test,'test')\n  self.assertIs(program.result,RESULT)\n def testCatchBreakInstallsHandler(self):\n  module=sys.modules['unittest.main']\n  original=module.installHandler\n  def restore():\n   module.installHandler=original\n  self.addCleanup(restore)\n  self.installed=False\n  def fakeInstallHandler():\n   self.installed=True\n  module.installHandler=fakeInstallHandler\n  program=self.program\n  program.catchbreak=True\n  program.testRunner=FakeRunner\n  program.runTests()\n  self.assertTrue(self.installed)\n def _patch_isfile(self,names,exists=True):\n  def isfile(path):\n   return path in names\n  original=os.path.isfile\n  os.path.isfile=isfile\n  def restore():\n   os.path.isfile=original\n  self.addCleanup(restore)\n def testParseArgsFileNames(self):\n  program=self.program\n  argv=['progname','foo.py','bar.Py','baz.PY','wing.txt']\n  self._patch_isfile(argv)\n  program.createTests=lambda:None\n  program.parseArgs(argv)\n  expected=['foo','bar','baz','wing.txt']\n  self.assertEqual(program.testNames,expected)\n def testParseArgsFilePaths(self):\n  program=self.program\n  argv=['progname','foo/bar/baz.py','green\\\\red.py']\n  self._patch_isfile(argv)\n  program.createTests=lambda:None\n  program.parseArgs(argv)\n  expected=['foo.bar.baz','green.red']\n  self.assertEqual(program.testNames,expected)\n def testParseArgsNonExistentFiles(self):\n  program=self.program\n  argv=['progname','foo/bar/baz.py','green\\\\red.py']\n  self._patch_isfile([])\n  program.createTests=lambda:None\n  program.parseArgs(argv)\n  self.assertEqual(program.testNames,argv[1:])\n def testParseArgsAbsolutePathsThatCanBeConverted(self):\n  cur_dir=os.getcwd()\n  program=self.program\n  def _join(name):\n   return os.path.join(cur_dir,name)\n  argv=['progname',_join('foo/bar/baz.py'),_join('green\\\\red.py')]\n  self._patch_isfile(argv)\n  program.createTests=lambda:None\n  program.parseArgs(argv)\n  expected=['foo.bar.baz','green.red']\n  self.assertEqual(program.testNames,expected)\n def testParseArgsAbsolutePathsThatCannotBeConverted(self):\n  program=self.program\n  argv=['progname','/foo/bar/baz.py','/green/red.py']\n  self._patch_isfile(argv)\n  program.createTests=lambda:None\n  program.parseArgs(argv)\n  self.assertEqual(program.testNames,argv[1:])\nif __name__=='__main__':\n unittest.main()\n"], "unittest.test.dummy": ["\n"], "unittest.test.test_discovery": ["import os\nimport re\nimport sys\nimport unittest\nclass TestableTestProgram(unittest.TestProgram):\n module='__main__'\n exit=True\n defaultTest=failfast=catchbreak=buffer=None\n verbosity=1\n progName=''\n testRunner=testLoader=None\n def __init__(self):\n  pass\nclass TestDiscovery(unittest.TestCase):\n def test_get_name_from_path(self):\n  loader=unittest.TestLoader()\n  loader._top_level_dir='/foo'\n  name=loader._get_name_from_path('/foo/bar/baz.py')\n  self.assertEqual(name,'bar.baz')\n  if not __debug__:\n   return\n  with self.assertRaises(AssertionError):\n   loader._get_name_from_path('/bar/baz.py')\n def test_find_tests(self):\n  loader=unittest.TestLoader()\n  original_listdir=os.listdir\n  def restore_listdir():\n   os.listdir=original_listdir\n  original_isfile=os.path.isfile\n  def restore_isfile():\n   os.path.isfile=original_isfile\n  original_isdir=os.path.isdir\n  def restore_isdir():\n   os.path.isdir=original_isdir\n  path_lists=[['test1.py','test2.py','not_a_test.py','test_dir',\n  'test.foo','test-not-a-module.py','another_dir'],\n  ['test3.py','test4.py',]]\n  os.listdir=lambda path:path_lists.pop(0)\n  self.addCleanup(restore_listdir)\n  def isdir(path):\n   return path.endswith('dir')\n  os.path.isdir=isdir\n  self.addCleanup(restore_isdir)\n  def isfile(path):\n   return not path.endswith('dir')and not'another_dir'in path\n  os.path.isfile=isfile\n  self.addCleanup(restore_isfile)\n  loader._get_module_from_name=lambda path:path+' module'\n  loader.loadTestsFromModule=lambda module:module+' tests'\n  top_level=os.path.abspath('/foo')\n  loader._top_level_dir=top_level\n  suite=list(loader._find_tests(top_level,'test*.py'))\n  expected=[name+' module tests'for name in\n  ('test1','test2')]\n  expected.extend([('test_dir.%s'%name)+' module tests'for name in\n  ('test3','test4')])\n  self.assertEqual(suite,expected)\n def test_find_tests_with_package(self):\n  loader=unittest.TestLoader()\n  original_listdir=os.listdir\n  def restore_listdir():\n   os.listdir=original_listdir\n  original_isfile=os.path.isfile\n  def restore_isfile():\n   os.path.isfile=original_isfile\n  original_isdir=os.path.isdir\n  def restore_isdir():\n   os.path.isdir=original_isdir\n  directories=['a_directory','test_directory','test_directory2']\n  path_lists=[directories,[],[],[]]\n  os.listdir=lambda path:path_lists.pop(0)\n  self.addCleanup(restore_listdir)\n  os.path.isdir=lambda path:True\n  self.addCleanup(restore_isdir)\n  os.path.isfile=lambda path:os.path.basename(path)not in directories\n  self.addCleanup(restore_isfile)\n  class Module(object):\n   paths=[]\n   load_tests_args=[]\n   def __init__(self,path):\n    self.path=path\n    self.paths.append(path)\n    if os.path.basename(path)=='test_directory':\n     def load_tests(loader,tests,pattern):\n      self.load_tests_args.append((loader,tests,pattern))\n      return'load_tests'\n     self.load_tests=load_tests\n   def __eq__(self,other):\n    return self.path==other.path\n  loader._get_module_from_name=lambda name:Module(name)\n  def loadTestsFromModule(module,use_load_tests):\n   if use_load_tests:\n    raise self.failureException('use_load_tests should be False for packages')\n   return module.path+' module tests'\n  loader.loadTestsFromModule=loadTestsFromModule\n  loader._top_level_dir='/foo'\n  suite=list(loader._find_tests('/foo','test*'))\n  self.assertEqual(suite,\n  ['load_tests','test_directory2'+' module tests'])\n  self.assertEqual(Module.paths,['test_directory','test_directory2'])\n  self.assertEqual(Module.load_tests_args,\n  [(loader,'test_directory'+' module tests','test*')])\n def test_discover(self):\n  loader=unittest.TestLoader()\n  original_isfile=os.path.isfile\n  original_isdir=os.path.isdir\n  def restore_isfile():\n   os.path.isfile=original_isfile\n  os.path.isfile=lambda path:False\n  self.addCleanup(restore_isfile)\n  orig_sys_path=sys.path[:]\n  def restore_path():\n   sys.path[:]=orig_sys_path\n  self.addCleanup(restore_path)\n  full_path=os.path.abspath(os.path.normpath('/foo'))\n  with self.assertRaises(ImportError):\n   loader.discover('/foo/bar',top_level_dir='/foo')\n  self.assertEqual(loader._top_level_dir,full_path)\n  self.assertIn(full_path,sys.path)\n  os.path.isfile=lambda path:True\n  os.path.isdir=lambda path:True\n  def restore_isdir():\n   os.path.isdir=original_isdir\n  self.addCleanup(restore_isdir)\n  _find_tests_args=[]\n  def _find_tests(start_dir,pattern):\n   _find_tests_args.append((start_dir,pattern))\n   return['tests']\n  loader._find_tests=_find_tests\n  loader.suiteClass=str\n  suite=loader.discover('/foo/bar/baz','pattern','/foo/bar')\n  top_level_dir=os.path.abspath('/foo/bar')\n  start_dir=os.path.abspath('/foo/bar/baz')\n  self.assertEqual(suite,\"['tests']\")\n  self.assertEqual(loader._top_level_dir,top_level_dir)\n  self.assertEqual(_find_tests_args,[(start_dir,'pattern')])\n  self.assertIn(top_level_dir,sys.path)\n def test_discover_with_modules_that_fail_to_import(self):\n  loader=unittest.TestLoader()\n  listdir=os.listdir\n  os.listdir=lambda _:['test_this_does_not_exist.py']\n  isfile=os.path.isfile\n  os.path.isfile=lambda _:True\n  orig_sys_path=sys.path[:]\n  def restore():\n   os.path.isfile=isfile\n   os.listdir=listdir\n   sys.path[:]=orig_sys_path\n  self.addCleanup(restore)\n  suite=loader.discover('.')\n  self.assertIn(os.getcwd(),sys.path)\n  self.assertEqual(suite.countTestCases(),1)\n  test=list(list(suite)[0])[0]\n  with self.assertRaises(ImportError):\n   test.test_this_does_not_exist()\n def test_command_line_handling_parseArgs(self):\n  program=TestableTestProgram()\n  args=[]\n  def do_discovery(argv):\n   args.extend(argv)\n  program._do_discovery=do_discovery\n  program.parseArgs(['something','discover'])\n  self.assertEqual(args,[])\n  program.parseArgs(['something','discover','foo','bar'])\n  self.assertEqual(args,['foo','bar'])\n def test_command_line_handling_discover_by_default(self):\n  program=TestableTestProgram()\n  program.module=None\n  self.called=False\n  def do_discovery(argv):\n   self.called=True\n   self.assertEqual(argv,[])\n  program._do_discovery=do_discovery\n  program.parseArgs(['something'])\n  self.assertTrue(self.called)\n def test_command_line_handling_discover_by_default_with_options(self):\n  program=TestableTestProgram()\n  program.module=None\n  args=['something','-v','-b','-v','-c','-f']\n  self.called=False\n  def do_discovery(argv):\n   self.called=True\n   self.assertEqual(argv,args[1:])\n  program._do_discovery=do_discovery\n  program.parseArgs(args)\n  self.assertTrue(self.called)\n def test_command_line_handling_do_discovery_too_many_arguments(self):\n  class Stop(Exception):\n   pass\n  def usageExit():\n   raise Stop\n  program=TestableTestProgram()\n  program.usageExit=usageExit\n  with self.assertRaises(Stop):\n   program._do_discovery(['one','two','three','four'])\n def test_command_line_handling_do_discovery_calls_loader(self):\n  program=TestableTestProgram()\n  class Loader(object):\n   args=[]\n   def discover(self,start_dir,pattern,top_level_dir):\n    self.args.append((start_dir,pattern,top_level_dir))\n    return'tests'\n  program._do_discovery(['-v'],Loader=Loader)\n  self.assertEqual(program.verbosity,2)\n  self.assertEqual(program.test,'tests')\n  self.assertEqual(Loader.args,[('.','test*.py',None)])\n  Loader.args=[]\n  program=TestableTestProgram()\n  program._do_discovery(['--verbose'],Loader=Loader)\n  self.assertEqual(program.test,'tests')\n  self.assertEqual(Loader.args,[('.','test*.py',None)])\n  Loader.args=[]\n  program=TestableTestProgram()\n  program._do_discovery([],Loader=Loader)\n  self.assertEqual(program.test,'tests')\n  self.assertEqual(Loader.args,[('.','test*.py',None)])\n  Loader.args=[]\n  program=TestableTestProgram()\n  program._do_discovery(['fish'],Loader=Loader)\n  self.assertEqual(program.test,'tests')\n  self.assertEqual(Loader.args,[('fish','test*.py',None)])\n  Loader.args=[]\n  program=TestableTestProgram()\n  program._do_discovery(['fish','eggs'],Loader=Loader)\n  self.assertEqual(program.test,'tests')\n  self.assertEqual(Loader.args,[('fish','eggs',None)])\n  Loader.args=[]\n  program=TestableTestProgram()\n  program._do_discovery(['fish','eggs','ham'],Loader=Loader)\n  self.assertEqual(program.test,'tests')\n  self.assertEqual(Loader.args,[('fish','eggs','ham')])\n  Loader.args=[]\n  program=TestableTestProgram()\n  program._do_discovery(['-s','fish'],Loader=Loader)\n  self.assertEqual(program.test,'tests')\n  self.assertEqual(Loader.args,[('fish','test*.py',None)])\n  Loader.args=[]\n  program=TestableTestProgram()\n  program._do_discovery(['-t','fish'],Loader=Loader)\n  self.assertEqual(program.test,'tests')\n  self.assertEqual(Loader.args,[('.','test*.py','fish')])\n  Loader.args=[]\n  program=TestableTestProgram()\n  program._do_discovery(['-p','fish'],Loader=Loader)\n  self.assertEqual(program.test,'tests')\n  self.assertEqual(Loader.args,[('.','fish',None)])\n  self.assertFalse(program.failfast)\n  self.assertFalse(program.catchbreak)\n  Loader.args=[]\n  program=TestableTestProgram()\n  program._do_discovery(['-p','eggs','-s','fish','-v','-f','-c'],\n  Loader=Loader)\n  self.assertEqual(program.test,'tests')\n  self.assertEqual(Loader.args,[('fish','eggs',None)])\n  self.assertEqual(program.verbosity,2)\n  self.assertTrue(program.failfast)\n  self.assertTrue(program.catchbreak)\n def test_detect_module_clash(self):\n  class Module(object):\n   __file__='bar/foo.py'\n  sys.modules['foo']=Module\n  full_path=os.path.abspath('foo')\n  original_listdir=os.listdir\n  original_isfile=os.path.isfile\n  original_isdir=os.path.isdir\n  def cleanup():\n   os.listdir=original_listdir\n   os.path.isfile=original_isfile\n   os.path.isdir=original_isdir\n   del sys.modules['foo']\n   if full_path in sys.path:\n    sys.path.remove(full_path)\n  self.addCleanup(cleanup)\n  def listdir(_):\n   return['foo.py']\n  def isfile(_):\n   return True\n  def isdir(_):\n   return True\n  os.listdir=listdir\n  os.path.isfile=isfile\n  os.path.isdir=isdir\n  loader=unittest.TestLoader()\n  mod_dir=os.path.abspath('bar')\n  expected_dir=os.path.abspath('foo')\n  msg=re.escape(r\"'foo' module incorrectly imported from %r. Expected %r. \"\n  \"Is this module globally installed?\"%(mod_dir,expected_dir))\n  self.assertRaisesRegex(\n  ImportError,'^%s$'%msg,loader.discover,\n  start_dir='foo',pattern='foo.py'\n  )\n  self.assertEqual(sys.path[0],full_path)\n def test_discovery_from_dotted_path(self):\n  loader=unittest.TestLoader()\n  tests=[self]\n  expectedPath=os.path.abspath(os.path.dirname(unittest.test.__file__))\n  self.wasRun=False\n  def _find_tests(start_dir,pattern):\n   self.wasRun=True\n   self.assertEqual(start_dir,expectedPath)\n   return tests\n  loader._find_tests=_find_tests\n  suite=loader.discover('unittest.test')\n  self.assertTrue(self.wasRun)\n  self.assertEqual(suite._tests,tests)\nif __name__=='__main__':\n unittest.main()\n"], "unittest.test.testmock.testcallable": ["\nimport unittest\nfrom unittest.test.testmock.support import is_instance,X,SomeClass\nfrom unittest.mock import(\nMock,MagicMock,NonCallableMagicMock,\nNonCallableMock,patch,create_autospec,\nCallableMixin\n)\nclass TestCallable(unittest.TestCase):\n def assertNotCallable(self,mock):\n  self.assertTrue(is_instance(mock,NonCallableMagicMock))\n  self.assertFalse(is_instance(mock,CallableMixin))\n def test_non_callable(self):\n  for mock in NonCallableMagicMock(),NonCallableMock():\n   self.assertRaises(TypeError,mock)\n   self.assertFalse(hasattr(mock,'__call__'))\n   self.assertIn(mock.__class__.__name__,repr(mock))\n def test_heirarchy(self):\n  self.assertTrue(issubclass(MagicMock,Mock))\n  self.assertTrue(issubclass(NonCallableMagicMock,NonCallableMock))\n def test_attributes(self):\n  one=NonCallableMock()\n  self.assertTrue(issubclass(type(one.one),Mock))\n  two=NonCallableMagicMock()\n  self.assertTrue(issubclass(type(two.two),MagicMock))\n def test_subclasses(self):\n  class MockSub(Mock):\n   pass\n  one=MockSub()\n  self.assertTrue(issubclass(type(one.one),MockSub))\n  class MagicSub(MagicMock):\n   pass\n  two=MagicSub()\n  self.assertTrue(issubclass(type(two.two),MagicSub))\n def test_patch_spec(self):\n  patcher=patch('%s.X'%__name__,spec=True)\n  mock=patcher.start()\n  self.addCleanup(patcher.stop)\n  instance=mock()\n  mock.assert_called_once_with()\n  self.assertNotCallable(instance)\n  self.assertRaises(TypeError,instance)\n def test_patch_spec_set(self):\n  patcher=patch('%s.X'%__name__,spec_set=True)\n  mock=patcher.start()\n  self.addCleanup(patcher.stop)\n  instance=mock()\n  mock.assert_called_once_with()\n  self.assertNotCallable(instance)\n  self.assertRaises(TypeError,instance)\n def test_patch_spec_instance(self):\n  patcher=patch('%s.X'%__name__,spec=X())\n  mock=patcher.start()\n  self.addCleanup(patcher.stop)\n  self.assertNotCallable(mock)\n  self.assertRaises(TypeError,mock)\n def test_patch_spec_set_instance(self):\n  patcher=patch('%s.X'%__name__,spec_set=X())\n  mock=patcher.start()\n  self.addCleanup(patcher.stop)\n  self.assertNotCallable(mock)\n  self.assertRaises(TypeError,mock)\n def test_patch_spec_callable_class(self):\n  class CallableX(X):\n   def __call__(self):\n    pass\n  class Sub(CallableX):\n   pass\n  class Multi(SomeClass,Sub):\n   pass\n  for arg in'spec','spec_set':\n   for Klass in CallableX,Sub,Multi:\n    with patch('%s.X'%__name__,**{arg:Klass})as mock:\n     instance=mock()\n     mock.assert_called_once_with()\n     self.assertTrue(is_instance(instance,MagicMock))\n     self.assertRaises(AttributeError,getattr,instance,\n     'foobarbaz')\n     result=instance()\n     instance.assert_called_once_with()\n     result(3,2,1)\n     result.assert_called_once_with(3,2,1)\n     result.foo(3,2,1)\n     result.foo.assert_called_once_with(3,2,1)\n def test_create_autopsec(self):\n  mock=create_autospec(X)\n  instance=mock()\n  self.assertRaises(TypeError,instance)\n  mock=create_autospec(X())\n  self.assertRaises(TypeError,mock)\n def test_create_autospec_instance(self):\n  mock=create_autospec(SomeClass,instance=True)\n  self.assertRaises(TypeError,mock)\n  mock.wibble()\n  mock.wibble.assert_called_once_with()\n  self.assertRaises(TypeError,mock.wibble,'some','args')\n"], "unittest.test": ["import os\nimport sys\nimport unittest\nhere=os.path.dirname(__file__)\nloader=unittest.defaultTestLoader\ndef suite():\n suite=unittest.TestSuite()\n for fn in os.listdir(here):\n  if fn.startswith(\"test\")and fn.endswith(\".py\"):\n   modname=\"unittest.test.\"+fn[:-3]\n   __import__(modname)\n   module=sys.modules[modname]\n   suite.addTest(loader.loadTestsFromModule(module))\n suite.addTest(loader.loadTestsFromName('unittest.test.testmock'))\n return suite\nif __name__==\"__main__\":\n unittest.main(defaultTest=\"suite\")\n", 1], "unittest.main": ["\nimport sys\nimport optparse\nimport os\nfrom.import loader,runner\nfrom.signals import installHandler\n__unittest=True\nFAILFAST=\"  -f, --failfast   Stop on first failure\\n\"\nCATCHBREAK=\"  -c, --catch      Catch control-C and display results\\n\"\nBUFFEROUTPUT=\"  -b, --buffer     Buffer stdout and stderr during test runs\\n\"\nUSAGE_AS_MAIN=\"\"\"\\\nUsage: %(progName)s [options] [tests]\nOptions:\n  -h, --help       Show this message\n  -v, --verbose    Verbose output\n  -q, --quiet      Minimal output\n%(failfast)s%(catchbreak)s%(buffer)s\nExamples:\n  %(progName)s test_module               - run tests from test_module\n  %(progName)s module.TestClass          - run tests from module.TestClass\n  %(progName)s module.Class.test_method  - run specified test method\n[tests] can be a list of any number of test modules, classes and test\nmethods.\nAlternative Usage: %(progName)s discover [options]\nOptions:\n  -v, --verbose    Verbose output\n%(failfast)s%(catchbreak)s%(buffer)s  -s directory     Directory to start discovery ('.' default)\n  -p pattern       Pattern to match test files ('test*.py' default)\n  -t directory     Top level directory of project (default to\n                   start directory)\nFor test discovery all test modules must be importable from the top\nlevel directory of the project.\n\"\"\"\nUSAGE_FROM_MODULE=\"\"\"\\\nUsage: %(progName)s [options] [test] [...]\nOptions:\n  -h, --help       Show this message\n  -v, --verbose    Verbose output\n  -q, --quiet      Minimal output\n%(failfast)s%(catchbreak)s%(buffer)s\nExamples:\n  %(progName)s                               - run default set of tests\n  %(progName)s MyTestSuite                   - run suite 'MyTestSuite'\n  %(progName)s MyTestCase.testSomething      - run MyTestCase.testSomething\n  %(progName)s MyTestCase                    - run all 'test*' test methods\n                                               in MyTestCase\n\"\"\"\ndef _convert_name(name):\n if os.path.isfile(name)and name.lower().endswith('.py'):\n  if os.path.isabs(name):\n   rel_path=os.path.relpath(name,os.getcwd())\n   if os.path.isabs(rel_path)or rel_path.startswith(os.pardir):\n    return name\n   name=rel_path\n  return name[:-3].replace('\\\\','.').replace('/','.')\n return name\ndef _convert_names(names):\n return[_convert_name(name)for name in names]\nclass TestProgram(object):\n '' \n USAGE=USAGE_FROM_MODULE\n failfast=catchbreak=buffer=progName=warnings=None\n def __init__(self,module='__main__',defaultTest=None,argv=None,\n testRunner=None,testLoader=loader.defaultTestLoader,\n exit=True,verbosity=1,failfast=None,catchbreak=None,\n buffer=None,warnings=None):\n  if isinstance(module,str):\n   self.module=__import__(module)\n   for part in module.split('.')[1:]:\n    self.module=getattr(self.module,part)\n  else:\n   self.module=module\n  if argv is None:\n   argv=sys.argv\n  self.exit=exit\n  self.failfast=failfast\n  self.catchbreak=catchbreak\n  self.verbosity=verbosity\n  self.buffer=buffer\n  if warnings is None and not sys.warnoptions:\n   self.warnings='default'\n  else:\n   self.warnings=warnings\n  self.defaultTest=defaultTest\n  self.testRunner=testRunner\n  self.testLoader=testLoader\n  self.progName=os.path.basename(argv[0])\n  self.parseArgs(argv)\n  self.runTests()\n def usageExit(self,msg=None):\n  if msg:\n   print(msg)\n  usage={'progName':self.progName,'catchbreak':'','failfast':'',\n  'buffer':''}\n  if self.failfast!=False:\n   usage['failfast']=FAILFAST\n  if self.catchbreak!=False:\n   usage['catchbreak']=CATCHBREAK\n  if self.buffer!=False:\n   usage['buffer']=BUFFEROUTPUT\n  print(self.USAGE%usage)\n  sys.exit(2)\n def parseArgs(self,argv):\n  if((len(argv)>1 and argv[1].lower()=='discover')or\n  (len(argv)==1 and self.module is None)):\n   self._do_discovery(argv[2:])\n   return\n  parser=self._getOptParser()\n  options,args=parser.parse_args(argv[1:])\n  self._setAttributesFromOptions(options)\n  if len(args)==0 and self.module is None:\n   self._do_discovery(argv[1:])\n   return\n  if len(args)==0 and self.defaultTest is None:\n   self.testNames=None\n  elif len(args)>0:\n   self.testNames=_convert_names(args)\n   if __name__=='__main__':\n    self.module=None\n  else:\n   self.testNames=(self.defaultTest,)\n  self.createTests()\n def createTests(self):\n  if self.testNames is None:\n   self.test=self.testLoader.loadTestsFromModule(self.module)\n  else:\n   self.test=self.testLoader.loadTestsFromNames(self.testNames,\n   self.module)\n def _getOptParser(self):\n  import optparse\n  parser=optparse.OptionParser()\n  parser.prog=self.progName\n  parser.add_option('-v','--verbose',dest='verbose',default=False,\n  help='Verbose output',action='store_true')\n  parser.add_option('-q','--quiet',dest='quiet',default=False,\n  help='Quiet output',action='store_true')\n  if self.failfast!=False:\n   parser.add_option('-f','--failfast',dest='failfast',default=False,\n   help='Stop on first fail or error',\n   action='store_true')\n  if self.catchbreak!=False:\n   parser.add_option('-c','--catch',dest='catchbreak',default=False,\n   help='Catch ctrl-C and display results so far',\n   action='store_true')\n  if self.buffer!=False:\n   parser.add_option('-b','--buffer',dest='buffer',default=False,\n   help='Buffer stdout and stderr during tests',\n   action='store_true')\n  return parser\n def _setAttributesFromOptions(self,options):\n  if self.failfast is None:\n   self.failfast=options.failfast\n  if self.catchbreak is None:\n   self.catchbreak=options.catchbreak\n  if self.buffer is None:\n   self.buffer=options.buffer\n  if options.verbose:\n   self.verbosity=2\n  elif options.quiet:\n   self.verbosity=0\n def _addDiscoveryOptions(self,parser):\n  parser.add_option('-s','--start-directory',dest='start',default='.',\n  help=\"Directory to start discovery ('.' default)\")\n  parser.add_option('-p','--pattern',dest='pattern',default='test*.py',\n  help=\"Pattern to match tests ('test*.py' default)\")\n  parser.add_option('-t','--top-level-directory',dest='top',default=None,\n  help='Top level directory of project (defaults to start directory)')\n def _do_discovery(self,argv,Loader=None):\n  if Loader is None:\n   Loader=lambda:self.testLoader\n  self.progName='%s discover'%self.progName\n  parser=self._getOptParser()\n  self._addDiscoveryOptions(parser)\n  options,args=parser.parse_args(argv)\n  if len(args)>3:\n   self.usageExit()\n  for name,value in zip(('start','pattern','top'),args):\n   setattr(options,name,value)\n  self._setAttributesFromOptions(options)\n  start_dir=options.start\n  pattern=options.pattern\n  top_level_dir=options.top\n  loader=Loader()\n  self.test=loader.discover(start_dir,pattern,top_level_dir)\n def runTests(self):\n  if self.catchbreak:\n   installHandler()\n  if self.testRunner is None:\n   self.testRunner=runner.TextTestRunner\n  if isinstance(self.testRunner,type):\n   try:\n    testRunner=self.testRunner(verbosity=self.verbosity,\n    failfast=self.failfast,\n    buffer=self.buffer,\n    warnings=self.warnings)\n   except TypeError:\n    testRunner=self.testRunner()\n  else:\n   testRunner=self.testRunner\n  self.result=testRunner.run(self.test)\n  if self.exit:\n   sys.exit(not self.result.wasSuccessful())\nmain=TestProgram\n"], "unittest.loader": ["\nimport os\nimport re\nimport sys\nimport traceback\nimport types\nimport functools\nfrom fnmatch import fnmatch\nfrom.import case,suite,util\n__unittest=True\nVALID_MODULE_NAME=re.compile(r'[_a-z]\\w*\\.py$',re.IGNORECASE)\ndef _make_failed_import_test(name,suiteClass):\n message='Failed to import test module: %s\\n%s'%(name,traceback.format_exc())\n return _make_failed_test('ModuleImportFailure',name,ImportError(message),\n suiteClass)\ndef _make_failed_load_tests(name,exception,suiteClass):\n return _make_failed_test('LoadTestsFailure',name,exception,suiteClass)\ndef _make_failed_test(classname,methodname,exception,suiteClass):\n def testFailure(self):\n  raise exception\n attrs={methodname:testFailure}\n TestClass=type(classname,(case.TestCase,),attrs)\n return suiteClass((TestClass(methodname),))\ndef _jython_aware_splitext(path):\n if path.lower().endswith('$py.class'):\n  return path[:-9]\n return os.path.splitext(path)[0]\nclass TestLoader(object):\n '' \n testMethodPrefix='test'\n sortTestMethodsUsing=staticmethod(util.three_way_cmp)\n suiteClass=suite.TestSuite\n _top_level_dir=None\n def loadTestsFromTestCase(self,testCaseClass):\n  if issubclass(testCaseClass,suite.TestSuite):\n   raise TypeError(\"Test cases should not be derived from TestSuite.\"   \" Maybe you meant to derive from TestCase?\")\n  testCaseNames=self.getTestCaseNames(testCaseClass)\n  if not testCaseNames and hasattr(testCaseClass,'runTest'):\n   testCaseNames=['runTest']\n  loaded_suite=self.suiteClass(map(testCaseClass,testCaseNames))\n  return loaded_suite\n def loadTestsFromModule(self,module,use_load_tests=True):\n  tests=[]\n  for name in dir(module):\n   obj=getattr(module,name)\n   if isinstance(obj,type)and issubclass(obj,case.TestCase):\n    tests.append(self.loadTestsFromTestCase(obj))\n  load_tests=getattr(module,'load_tests',None)\n  tests=self.suiteClass(tests)\n  if use_load_tests and load_tests is not None:\n   try:\n    return load_tests(self,tests,None)\n   except Exception as e:\n    return _make_failed_load_tests(module.__name__,e,\n    self.suiteClass)\n  return tests\n def loadTestsFromName(self,name,module=None):\n  ''  \n  parts=name.split('.')\n  if module is None:\n   parts_copy=parts[:]\n   while parts_copy:\n    try:\n     module=__import__('.'.join(parts_copy))\n     break\n    except ImportError:\n     del parts_copy[-1]\n     if not parts_copy:\n      raise\n   parts=parts[1:]\n  obj=module\n  for part in parts:\n   parent,obj=obj,getattr(obj,part)\n  if isinstance(obj,types.ModuleType):\n   return self.loadTestsFromModule(obj)\n  elif isinstance(obj,type)and issubclass(obj,case.TestCase):\n   return self.loadTestsFromTestCase(obj)\n  elif(isinstance(obj,types.FunctionType)and\n  isinstance(parent,type)and\n  issubclass(parent,case.TestCase)):\n   name=parts[-1]\n   inst=parent(name)\n   if not isinstance(getattr(inst,name),types.FunctionType):\n    return self.suiteClass([inst])\n  elif isinstance(obj,suite.TestSuite):\n   return obj\n  if callable(obj):\n   test=obj()\n   if isinstance(test,suite.TestSuite):\n    return test\n   elif isinstance(test,case.TestCase):\n    return self.suiteClass([test])\n   else:\n    raise TypeError(\"calling %s returned %s, not a test\"%\n    (obj,test))\n  else:\n   raise TypeError(\"don't know how to make test from: %s\"%obj)\n def loadTestsFromNames(self,names,module=None):\n  ''  \n  suites=[self.loadTestsFromName(name,module)for name in names]\n  return self.suiteClass(suites)\n def getTestCaseNames(self,testCaseClass):\n  ''  \n  def isTestMethod(attrname,testCaseClass=testCaseClass,\n  prefix=self.testMethodPrefix):\n   return attrname.startswith(prefix)and   callable(getattr(testCaseClass,attrname))\n  testFnNames=list(filter(isTestMethod,dir(testCaseClass)))\n  if self.sortTestMethodsUsing:\n   testFnNames.sort(key=functools.cmp_to_key(self.sortTestMethodsUsing))\n  return testFnNames\n def discover(self,start_dir,pattern='test*.py',top_level_dir=None):\n  ''  \n  set_implicit_top=False\n  if top_level_dir is None and self._top_level_dir is not None:\n   top_level_dir=self._top_level_dir\n  elif top_level_dir is None:\n   set_implicit_top=True\n   top_level_dir=start_dir\n  top_level_dir=os.path.abspath(top_level_dir)\n  if not top_level_dir in sys.path:\n   sys.path.insert(0,top_level_dir)\n  self._top_level_dir=top_level_dir\n  is_not_importable=False\n  if os.path.isdir(os.path.abspath(start_dir)):\n   start_dir=os.path.abspath(start_dir)\n   if start_dir!=top_level_dir:\n    is_not_importable=not os.path.isfile(os.path.join(start_dir,'__init__.py'))\n  else:\n   try:\n    __import__(start_dir)\n   except ImportError:\n    is_not_importable=True\n   else:\n    the_module=sys.modules[start_dir]\n    top_part=start_dir.split('.')[0]\n    start_dir=os.path.abspath(os.path.dirname((the_module.__file__)))\n    if set_implicit_top:\n     self._top_level_dir=self._get_directory_containing_module(top_part)\n     sys.path.remove(top_level_dir)\n  if is_not_importable:\n   raise ImportError('Start directory is not importable: %r'%start_dir)\n  tests=list(self._find_tests(start_dir,pattern))\n  return self.suiteClass(tests)\n def _get_directory_containing_module(self,module_name):\n  module=sys.modules[module_name]\n  full_path=os.path.abspath(module.__file__)\n  if os.path.basename(full_path).lower().startswith('__init__.py'):\n   return os.path.dirname(os.path.dirname(full_path))\n  else:\n   return os.path.dirname(full_path)\n def _get_name_from_path(self,path):\n  path=_jython_aware_splitext(os.path.normpath(path))\n  _relpath=os.path.relpath(path,self._top_level_dir)\n  assert not os.path.isabs(_relpath),\"Path must be within the project\"\n  assert not _relpath.startswith('..'),\"Path must be within the project\"\n  name=_relpath.replace(os.path.sep,'.')\n  return name\n def _get_module_from_name(self,name):\n  __import__(name)\n  return sys.modules[name]\n def _match_path(self,path,full_path,pattern):\n  return fnmatch(path,pattern)\n def _find_tests(self,start_dir,pattern):\n  paths=os.listdir(start_dir)\n  for path in paths:\n   full_path=os.path.join(start_dir,path)\n   if os.path.isfile(full_path):\n    if not VALID_MODULE_NAME.match(path):\n     continue\n    if not self._match_path(path,full_path,pattern):\n     continue\n    name=self._get_name_from_path(full_path)\n    try:\n     module=self._get_module_from_name(name)\n    except:\n     yield _make_failed_import_test(name,self.suiteClass)\n    else:\n     mod_file=os.path.abspath(getattr(module,'__file__',full_path))\n     realpath=_jython_aware_splitext(os.path.realpath(mod_file))\n     fullpath_noext=_jython_aware_splitext(os.path.realpath(full_path))\n     if realpath.lower()!=fullpath_noext.lower():\n      module_dir=os.path.dirname(realpath)\n      mod_name=_jython_aware_splitext(os.path.basename(full_path))\n      expected_dir=os.path.dirname(full_path)\n      msg=(\"%r module incorrectly imported from %r. Expected %r. \"\n      \"Is this module globally installed?\")\n      raise ImportError(msg%(mod_name,module_dir,expected_dir))\n     yield self.loadTestsFromModule(module)\n   elif os.path.isdir(full_path):\n    if not os.path.isfile(os.path.join(full_path,'__init__.py')):\n     continue\n    load_tests=None\n    tests=None\n    if fnmatch(path,pattern):\n     name=self._get_name_from_path(full_path)\n     package=self._get_module_from_name(name)\n     load_tests=getattr(package,'load_tests',None)\n     tests=self.loadTestsFromModule(package,use_load_tests=False)\n    if load_tests is None:\n     if tests is not None:\n      yield tests\n     for test in self._find_tests(full_path,pattern):\n      yield test\n    else:\n     try:\n      yield load_tests(self,tests,pattern)\n     except Exception as e:\n      yield _make_failed_load_tests(package.__name__,e,\n      self.suiteClass)\ndefaultTestLoader=TestLoader()\ndef _makeLoader(prefix,sortUsing,suiteClass=None):\n loader=TestLoader()\n loader.sortTestMethodsUsing=sortUsing\n loader.testMethodPrefix=prefix\n if suiteClass:\n  loader.suiteClass=suiteClass\n return loader\ndef getTestCaseNames(testCaseClass,prefix,sortUsing=util.three_way_cmp):\n return _makeLoader(prefix,sortUsing).getTestCaseNames(testCaseClass)\ndef makeSuite(testCaseClass,prefix='test',sortUsing=util.three_way_cmp,\nsuiteClass=suite.TestSuite):\n return _makeLoader(prefix,sortUsing,suiteClass).loadTestsFromTestCase(\n testCaseClass)\ndef findTestCases(module,prefix='test',sortUsing=util.three_way_cmp,\nsuiteClass=suite.TestSuite):\n return _makeLoader(prefix,sortUsing,suiteClass).loadTestsFromModule( module)\n"], "unittest.suite": ["\nimport sys\nfrom.import case\nfrom.import util\n__unittest=True\ndef _call_if_exists(parent,attr):\n func=getattr(parent,attr,lambda:None)\n func()\nclass BaseTestSuite(object):\n '' \n def __init__(self,tests=()):\n  self._tests=[]\n  self.addTests(tests)\n def __repr__(self):\n  return\"<%s tests=%s>\"%(util.strclass(self.__class__),list(self))\n def __eq__(self,other):\n  if not isinstance(other,self.__class__):\n   return NotImplemented\n  return list(self)==list(other)\n def __ne__(self,other):\n  return not self==other\n def __iter__(self):\n  return iter(self._tests)\n def countTestCases(self):\n  cases=0\n  for test in self:\n   cases+=test.countTestCases()\n  return cases\n def addTest(self,test):\n  if not callable(test):\n   raise TypeError(\"{} is not callable\".format(repr(test)))\n  if isinstance(test,type)and issubclass(test,\n  (case.TestCase,TestSuite)):\n   raise TypeError(\"TestCases and TestSuites must be instantiated \"\n   \"before passing them to addTest()\")\n  self._tests.append(test)\n def addTests(self,tests):\n  if isinstance(tests,str):\n   raise TypeError(\"tests must be an iterable of tests, not a string\")\n  for test in tests:\n   self.addTest(test)\n def run(self,result):\n  for test in self:\n   if result.shouldStop:\n    break\n   test(result)\n  return result\n def __call__(self,*args,**kwds):\n  return self.run(*args,**kwds)\n def debug(self):\n  for test in self:\n   test.debug()\nclass TestSuite(BaseTestSuite):\n '' \n def run(self,result,debug=False):\n  topLevel=False\n  if getattr(result,'_testRunEntered',False)is False:\n   result._testRunEntered=topLevel=True\n  for test in self:\n   if result.shouldStop:\n    break\n   if _isnotsuite(test):\n    self._tearDownPreviousClass(test,result)\n    self._handleModuleFixture(test,result)\n    self._handleClassSetUp(test,result)\n    result._previousTestClass=test.__class__\n    if(getattr(test.__class__,'_classSetupFailed',False)or\n    getattr(result,'_moduleSetUpFailed',False)):\n     continue\n   if not debug:\n    test(result)\n   else:\n    test.debug()\n  if topLevel:\n   self._tearDownPreviousClass(None,result)\n   self._handleModuleTearDown(result)\n   result._testRunEntered=False\n  return result\n def debug(self):\n  debug=_DebugResult()\n  self.run(debug,True)\n def _handleClassSetUp(self,test,result):\n  previousClass=getattr(result,'_previousTestClass',None)\n  currentClass=test.__class__\n  if currentClass==previousClass:\n   return\n  if result._moduleSetUpFailed:\n   return\n  if getattr(currentClass,\"__unittest_skip__\",False):\n   return\n  try:\n   currentClass._classSetupFailed=False\n  except TypeError:\n   pass\n  setUpClass=getattr(currentClass,'setUpClass',None)\n  if setUpClass is not None:\n   _call_if_exists(result,'_setupStdout')\n   try:\n    setUpClass()\n   except Exception as e:\n    if isinstance(result,_DebugResult):\n     raise\n    currentClass._classSetupFailed=True\n    className=util.strclass(currentClass)\n    errorName='setUpClass (%s)'%className\n    self._addClassOrModuleLevelException(result,e,errorName)\n   finally:\n    _call_if_exists(result,'_restoreStdout')\n def _get_previous_module(self,result):\n  previousModule=None\n  previousClass=getattr(result,'_previousTestClass',None)\n  if previousClass is not None:\n   previousModule=previousClass.__module__\n  return previousModule\n def _handleModuleFixture(self,test,result):\n  previousModule=self._get_previous_module(result)\n  currentModule=test.__class__.__module__\n  if currentModule==previousModule:\n   return\n  self._handleModuleTearDown(result)\n  result._moduleSetUpFailed=False\n  try:\n   module=sys.modules[currentModule]\n  except KeyError:\n   return\n  setUpModule=getattr(module,'setUpModule',None)\n  if setUpModule is not None:\n   _call_if_exists(result,'_setupStdout')\n   try:\n    setUpModule()\n   except Exception as e:\n    if isinstance(result,_DebugResult):\n     raise\n    result._moduleSetUpFailed=True\n    errorName='setUpModule (%s)'%currentModule\n    self._addClassOrModuleLevelException(result,e,errorName)\n   finally:\n    _call_if_exists(result,'_restoreStdout')\n def _addClassOrModuleLevelException(self,result,exception,errorName):\n  error=_ErrorHolder(errorName)\n  addSkip=getattr(result,'addSkip',None)\n  if addSkip is not None and isinstance(exception,case.SkipTest):\n   addSkip(error,str(exception))\n  else:\n   result.addError(error,sys.exc_info())\n def _handleModuleTearDown(self,result):\n  previousModule=self._get_previous_module(result)\n  if previousModule is None:\n   return\n  if result._moduleSetUpFailed:\n   return\n  try:\n   module=sys.modules[previousModule]\n  except KeyError:\n   return\n  tearDownModule=getattr(module,'tearDownModule',None)\n  if tearDownModule is not None:\n   _call_if_exists(result,'_setupStdout')\n   try:\n    tearDownModule()\n   except Exception as e:\n    if isinstance(result,_DebugResult):\n     raise\n    errorName='tearDownModule (%s)'%previousModule\n    self._addClassOrModuleLevelException(result,e,errorName)\n   finally:\n    _call_if_exists(result,'_restoreStdout')\n def _tearDownPreviousClass(self,test,result):\n  previousClass=getattr(result,'_previousTestClass',None)\n  currentClass=test.__class__\n  if currentClass==previousClass:\n   return\n  if getattr(previousClass,'_classSetupFailed',False):\n   return\n  if getattr(result,'_moduleSetUpFailed',False):\n   return\n  if getattr(previousClass,\"__unittest_skip__\",False):\n   return\n  tearDownClass=getattr(previousClass,'tearDownClass',None)\n  if tearDownClass is not None:\n   _call_if_exists(result,'_setupStdout')\n   try:\n    tearDownClass()\n   except Exception as e:\n    if isinstance(result,_DebugResult):\n     raise\n    className=util.strclass(previousClass)\n    errorName='tearDownClass (%s)'%className\n    self._addClassOrModuleLevelException(result,e,errorName)\n   finally:\n    _call_if_exists(result,'_restoreStdout')\nclass _ErrorHolder(object):\n '' \n failureException=None\n def __init__(self,description):\n  self.description=description\n def id(self):\n  return self.description\n def shortDescription(self):\n  return None\n def __repr__(self):\n  return\"<ErrorHolder description=%r>\"%(self.description,)\n def __str__(self):\n  return self.id()\n def run(self,result):\n  pass\n def __call__(self,result):\n  return self.run(result)\n def countTestCases(self):\n  return 0\ndef _isnotsuite(test):\n try:\n  iter(test)\n except TypeError:\n  return True\n return False\nclass _DebugResult(object):\n _previousTestClass=None\n _moduleSetUpFailed=False\n shouldStop=False\n"], "unittest.test.testmock.testhelpers": ["import unittest\nfrom unittest.mock import(\ncall,_Call,create_autospec,MagicMock,\nMock,ANY,_CallList,patch,PropertyMock\n)\nfrom datetime import datetime\nclass SomeClass(object):\n def one(self,a,b):\n  pass\n def two(self):\n  pass\n def three(self,a=None):\n  pass\nclass AnyTest(unittest.TestCase):\n def test_any(self):\n  self.assertEqual(ANY,object())\n  mock=Mock()\n  mock(ANY)\n  mock.assert_called_with(ANY)\n  mock=Mock()\n  mock(foo=ANY)\n  mock.assert_called_with(foo=ANY)\n def test_repr(self):\n  self.assertEqual(repr(ANY),'<ANY>')\n  self.assertEqual(str(ANY),'<ANY>')\n def test_any_and_datetime(self):\n  mock=Mock()\n  mock(datetime.now(),foo=datetime.now())\n  mock.assert_called_with(ANY,foo=ANY)\n def test_any_mock_calls_comparison_order(self):\n  mock=Mock()\n  d=datetime.now()\n  class Foo(object):\n   def __eq__(self,other):\n    return False\n   def __ne__(self,other):\n    return True\n  for d in datetime.now(),Foo():\n   mock.reset_mock()\n   mock(d,foo=d,bar=d)\n   mock.method(d,zinga=d,alpha=d)\n   mock().method(a1=d,z99=d)\n   expected=[\n   call(ANY,foo=ANY,bar=ANY),\n   call.method(ANY,zinga=ANY,alpha=ANY),\n   call(),call().method(a1=ANY,z99=ANY)\n   ]\n   self.assertEqual(expected,mock.mock_calls)\n   self.assertEqual(mock.mock_calls,expected)\nclass CallTest(unittest.TestCase):\n def test_call_with_call(self):\n  kall=_Call()\n  self.assertEqual(kall,_Call())\n  self.assertEqual(kall,_Call(('',)))\n  self.assertEqual(kall,_Call(((),)))\n  self.assertEqual(kall,_Call(({},)))\n  self.assertEqual(kall,_Call(('',())))\n  self.assertEqual(kall,_Call(('',{})))\n  self.assertEqual(kall,_Call(('',(),{})))\n  self.assertEqual(kall,_Call(('foo',)))\n  self.assertEqual(kall,_Call(('bar',())))\n  self.assertEqual(kall,_Call(('baz',{})))\n  self.assertEqual(kall,_Call(('spam',(),{})))\n  kall=_Call(((1,2,3),))\n  self.assertEqual(kall,_Call(((1,2,3),)))\n  self.assertEqual(kall,_Call(('',(1,2,3))))\n  self.assertEqual(kall,_Call(((1,2,3),{})))\n  self.assertEqual(kall,_Call(('',(1,2,3),{})))\n  kall=_Call(((1,2,4),))\n  self.assertNotEqual(kall,_Call(('',(1,2,3))))\n  self.assertNotEqual(kall,_Call(('',(1,2,3),{})))\n  kall=_Call(('foo',(1,2,4),))\n  self.assertNotEqual(kall,_Call(('',(1,2,4))))\n  self.assertNotEqual(kall,_Call(('',(1,2,4),{})))\n  self.assertNotEqual(kall,_Call(('bar',(1,2,4))))\n  self.assertNotEqual(kall,_Call(('bar',(1,2,4),{})))\n  kall=_Call(({'a':3},))\n  self.assertEqual(kall,_Call(('',(),{'a':3})))\n  self.assertEqual(kall,_Call(('',{'a':3})))\n  self.assertEqual(kall,_Call(((),{'a':3})))\n  self.assertEqual(kall,_Call(({'a':3},)))\n def test_empty__Call(self):\n  args=_Call()\n  self.assertEqual(args,())\n  self.assertEqual(args,('foo',))\n  self.assertEqual(args,((),))\n  self.assertEqual(args,('foo',()))\n  self.assertEqual(args,('foo',(),{}))\n  self.assertEqual(args,('foo',{}))\n  self.assertEqual(args,({},))\n def test_named_empty_call(self):\n  args=_Call(('foo',(),{}))\n  self.assertEqual(args,('foo',))\n  self.assertEqual(args,('foo',()))\n  self.assertEqual(args,('foo',(),{}))\n  self.assertEqual(args,('foo',{}))\n  self.assertNotEqual(args,((),))\n  self.assertNotEqual(args,())\n  self.assertNotEqual(args,({},))\n  self.assertNotEqual(args,('bar',))\n  self.assertNotEqual(args,('bar',()))\n  self.assertNotEqual(args,('bar',{}))\n def test_call_with_args(self):\n  args=_Call(((1,2,3),{}))\n  self.assertEqual(args,((1,2,3),))\n  self.assertEqual(args,('foo',(1,2,3)))\n  self.assertEqual(args,('foo',(1,2,3),{}))\n  self.assertEqual(args,((1,2,3),{}))\n def test_named_call_with_args(self):\n  args=_Call(('foo',(1,2,3),{}))\n  self.assertEqual(args,('foo',(1,2,3)))\n  self.assertEqual(args,('foo',(1,2,3),{}))\n  self.assertNotEqual(args,((1,2,3),))\n  self.assertNotEqual(args,((1,2,3),{}))\n def test_call_with_kwargs(self):\n  args=_Call(((),dict(a=3,b=4)))\n  self.assertEqual(args,(dict(a=3,b=4),))\n  self.assertEqual(args,('foo',dict(a=3,b=4)))\n  self.assertEqual(args,('foo',(),dict(a=3,b=4)))\n  self.assertEqual(args,((),dict(a=3,b=4)))\n def test_named_call_with_kwargs(self):\n  args=_Call(('foo',(),dict(a=3,b=4)))\n  self.assertEqual(args,('foo',dict(a=3,b=4)))\n  self.assertEqual(args,('foo',(),dict(a=3,b=4)))\n  self.assertNotEqual(args,(dict(a=3,b=4),))\n  self.assertNotEqual(args,((),dict(a=3,b=4)))\n def test_call_with_args_call_empty_name(self):\n  args=_Call(((1,2,3),{}))\n  self.assertEqual(args,call(1,2,3))\n  self.assertEqual(call(1,2,3),args)\n  self.assertTrue(call(1,2,3)in[args])\n def test_call_ne(self):\n  self.assertNotEqual(_Call(((1,2,3),)),call(1,2))\n  self.assertFalse(_Call(((1,2,3),))!=call(1,2,3))\n  self.assertTrue(_Call(((1,2),{}))!=call(1,2,3))\n def test_call_non_tuples(self):\n  kall=_Call(((1,2,3),))\n  for value in 1,None,self,int:\n   self.assertNotEqual(kall,value)\n   self.assertFalse(kall==value)\n def test_repr(self):\n  self.assertEqual(repr(_Call()),'call()')\n  self.assertEqual(repr(_Call(('foo',))),'call.foo()')\n  self.assertEqual(repr(_Call(((1,2,3),{'a':'b'}))),\n  \"call(1, 2, 3, a='b')\")\n  self.assertEqual(repr(_Call(('bar',(1,2,3),{'a':'b'}))),\n  \"call.bar(1, 2, 3, a='b')\")\n  self.assertEqual(repr(call),'call')\n  self.assertEqual(str(call),'call')\n  self.assertEqual(repr(call()),'call()')\n  self.assertEqual(repr(call(1)),'call(1)')\n  self.assertEqual(repr(call(zz='thing')),\"call(zz='thing')\")\n  self.assertEqual(repr(call().foo),'call().foo')\n  self.assertEqual(repr(call(1).foo.bar(a=3).bing),\n  'call().foo.bar().bing')\n  self.assertEqual(\n  repr(call().foo(1,2,a=3)),\n  \"call().foo(1, 2, a=3)\"\n  )\n  self.assertEqual(repr(call()()),\"call()()\")\n  self.assertEqual(repr(call(1)(2)),\"call()(2)\")\n  self.assertEqual(\n  repr(call()().bar().baz.beep(1)),\n  \"call()().bar().baz.beep(1)\"\n  )\n def test_call(self):\n  self.assertEqual(call(),('',(),{}))\n  self.assertEqual(call('foo','bar',one=3,two=4),\n  ('',('foo','bar'),{'one':3,'two':4}))\n  mock=Mock()\n  mock(1,2,3)\n  mock(a=3,b=6)\n  self.assertEqual(mock.call_args_list,\n  [call(1,2,3),call(a=3,b=6)])\n def test_attribute_call(self):\n  self.assertEqual(call.foo(1),('foo',(1,),{}))\n  self.assertEqual(call.bar.baz(fish='eggs'),\n  ('bar.baz',(),{'fish':'eggs'}))\n  mock=Mock()\n  mock.foo(1,2,3)\n  mock.bar.baz(a=3,b=6)\n  self.assertEqual(mock.method_calls,\n  [call.foo(1,2,3),call.bar.baz(a=3,b=6)])\n def test_extended_call(self):\n  result=call(1).foo(2).bar(3,a=4)\n  self.assertEqual(result,('().foo().bar',(3,),dict(a=4)))\n  mock=MagicMock()\n  mock(1,2,a=3,b=4)\n  self.assertEqual(mock.call_args,call(1,2,a=3,b=4))\n  self.assertNotEqual(mock.call_args,call(1,2,3))\n  self.assertEqual(mock.call_args_list,[call(1,2,a=3,b=4)])\n  self.assertEqual(mock.mock_calls,[call(1,2,a=3,b=4)])\n  mock=MagicMock()\n  mock.foo(1).bar()().baz.beep(a=6)\n  last_call=call.foo(1).bar()().baz.beep(a=6)\n  self.assertEqual(mock.mock_calls[-1],last_call)\n  self.assertEqual(mock.mock_calls,last_call.call_list())\n def test_call_list(self):\n  mock=MagicMock()\n  mock(1)\n  self.assertEqual(call(1).call_list(),mock.mock_calls)\n  mock=MagicMock()\n  mock(1).method(2)\n  self.assertEqual(call(1).method(2).call_list(),\n  mock.mock_calls)\n  mock=MagicMock()\n  mock(1).method(2)(3)\n  self.assertEqual(call(1).method(2)(3).call_list(),\n  mock.mock_calls)\n  mock=MagicMock()\n  int(mock(1).method(2)(3).foo.bar.baz(4)(5))\n  kall=call(1).method(2)(3).foo.bar.baz(4)(5).__int__()\n  self.assertEqual(kall.call_list(),mock.mock_calls)\n def test_call_any(self):\n  self.assertEqual(call,ANY)\n  m=MagicMock()\n  int(m)\n  self.assertEqual(m.mock_calls,[ANY])\n  self.assertEqual([ANY],m.mock_calls)\n def test_two_args_call(self):\n  args=_Call(((1,2),{'a':3}),two=True)\n  self.assertEqual(len(args),2)\n  self.assertEqual(args[0],(1,2))\n  self.assertEqual(args[1],{'a':3})\n  other_args=_Call(((1,2),{'a':3}))\n  self.assertEqual(args,other_args)\nclass SpecSignatureTest(unittest.TestCase):\n def _check_someclass_mock(self,mock):\n  self.assertRaises(AttributeError,getattr,mock,'foo')\n  mock.one(1,2)\n  mock.one.assert_called_with(1,2)\n  self.assertRaises(AssertionError,\n  mock.one.assert_called_with,3,4)\n  self.assertRaises(TypeError,mock.one,1)\n  mock.two()\n  mock.two.assert_called_with()\n  self.assertRaises(AssertionError,\n  mock.two.assert_called_with,3)\n  self.assertRaises(TypeError,mock.two,1)\n  mock.three()\n  mock.three.assert_called_with()\n  self.assertRaises(AssertionError,\n  mock.three.assert_called_with,3)\n  self.assertRaises(TypeError,mock.three,3,2)\n  mock.three(1)\n  mock.three.assert_called_with(1)\n  mock.three(a=1)\n  mock.three.assert_called_with(a=1)\n def test_basic(self):\n  for spec in(SomeClass,SomeClass()):\n   mock=create_autospec(spec)\n   self._check_someclass_mock(mock)\n def test_create_autospec_return_value(self):\n  def f():\n   pass\n  mock=create_autospec(f,return_value='foo')\n  self.assertEqual(mock(),'foo')\n  class Foo(object):\n   pass\n  mock=create_autospec(Foo,return_value='foo')\n  self.assertEqual(mock(),'foo')\n def test_autospec_reset_mock(self):\n  m=create_autospec(int)\n  int(m)\n  m.reset_mock()\n  self.assertEqual(m.__int__.call_count,0)\n def test_mocking_unbound_methods(self):\n  class Foo(object):\n   def foo(self,foo):\n    pass\n  p=patch.object(Foo,'foo')\n  mock_foo=p.start()\n  Foo().foo(1)\n  mock_foo.assert_called_with(1)\n def test_create_autospec_unbound_methods(self):\n  return\n  class Foo(object):\n   def foo(self):\n    pass\n  klass=create_autospec(Foo)\n  instance=klass()\n  self.assertRaises(TypeError,instance.foo,1)\n  klass.foo(1)\n  klass.foo.assert_called_with(1)\n  self.assertRaises(TypeError,klass.foo)\n def test_create_autospec_keyword_arguments(self):\n  class Foo(object):\n   a=3\n  m=create_autospec(Foo,a='3')\n  self.assertEqual(m.a,'3')\n def test_create_autospec_keyword_only_arguments(self):\n  def foo(a,*,b=None):\n   pass\n  m=create_autospec(foo)\n  m(1)\n  m.assert_called_with(1)\n  self.assertRaises(TypeError,m,1,2)\n  m(2,b=3)\n  m.assert_called_with(2,b=3)\n def test_function_as_instance_attribute(self):\n  obj=SomeClass()\n  def f(a):\n   pass\n  obj.f=f\n  mock=create_autospec(obj)\n  mock.f('bing')\n  mock.f.assert_called_with('bing')\n def test_spec_as_list(self):\n  mock=create_autospec([])\n  mock.append('foo')\n  mock.append.assert_called_with('foo')\n  self.assertRaises(AttributeError,getattr,mock,'foo')\n  class Foo(object):\n   foo=[]\n  mock=create_autospec(Foo)\n  mock.foo.append(3)\n  mock.foo.append.assert_called_with(3)\n  self.assertRaises(AttributeError,getattr,mock.foo,'foo')\n def test_attributes(self):\n  class Sub(SomeClass):\n   attr=SomeClass()\n  sub_mock=create_autospec(Sub)\n  for mock in(sub_mock,sub_mock.attr):\n   self._check_someclass_mock(mock)\n def test_builtin_functions_types(self):\n  class BuiltinSubclass(list):\n   def bar(self,arg):\n    pass\n   sorted=sorted\n   attr={}\n  mock=create_autospec(BuiltinSubclass)\n  mock.append(3)\n  mock.append.assert_called_with(3)\n  self.assertRaises(AttributeError,getattr,mock.append,'foo')\n  mock.bar('foo')\n  mock.bar.assert_called_with('foo')\n  self.assertRaises(TypeError,mock.bar,'foo','bar')\n  self.assertRaises(AttributeError,getattr,mock.bar,'foo')\n  mock.sorted([1,2])\n  mock.sorted.assert_called_with([1,2])\n  self.assertRaises(AttributeError,getattr,mock.sorted,'foo')\n  mock.attr.pop(3)\n  mock.attr.pop.assert_called_with(3)\n  self.assertRaises(AttributeError,getattr,mock.attr,'foo')\n def test_method_calls(self):\n  class Sub(SomeClass):\n   attr=SomeClass()\n  mock=create_autospec(Sub)\n  mock.one(1,2)\n  mock.two()\n  mock.three(3)\n  expected=[call.one(1,2),call.two(),call.three(3)]\n  self.assertEqual(mock.method_calls,expected)\n  mock.attr.one(1,2)\n  mock.attr.two()\n  mock.attr.three(3)\n  expected.extend(\n  [call.attr.one(1,2),call.attr.two(),call.attr.three(3)]\n  )\n  self.assertEqual(mock.method_calls,expected)\n def test_magic_methods(self):\n  class BuiltinSubclass(list):\n   attr={}\n  mock=create_autospec(BuiltinSubclass)\n  self.assertEqual(list(mock),[])\n  self.assertRaises(TypeError,int,mock)\n  self.assertRaises(TypeError,int,mock.attr)\n  self.assertEqual(list(mock),[])\n  self.assertIsInstance(mock['foo'],MagicMock)\n  self.assertIsInstance(mock.attr['foo'],MagicMock)\n def test_spec_set(self):\n  class Sub(SomeClass):\n   attr=SomeClass()\n  for spec in(Sub,Sub()):\n   mock=create_autospec(spec,spec_set=True)\n   self._check_someclass_mock(mock)\n   self.assertRaises(AttributeError,setattr,mock,'foo','bar')\n   self.assertRaises(AttributeError,setattr,mock.attr,'foo','bar')\n def test_descriptors(self):\n  class Foo(object):\n   @classmethod\n   def f(cls,a,b):\n    pass\n   @staticmethod\n   def g(a,b):\n    pass\n  class Bar(Foo):\n   pass\n  class Baz(SomeClass,Bar):\n   pass\n  for spec in(Foo,Foo(),Bar,Bar(),Baz,Baz()):\n   mock=create_autospec(spec)\n   mock.f(1,2)\n   mock.f.assert_called_once_with(1,2)\n   mock.g(3,4)\n   mock.g.assert_called_once_with(3,4)\n def test_recursive(self):\n  class A(object):\n   def a(self):\n    pass\n   foo='foo bar baz'\n   bar=foo\n  A.B=A\n  mock=create_autospec(A)\n  mock()\n  self.assertFalse(mock.B.called)\n  mock.a()\n  mock.B.a()\n  self.assertEqual(mock.method_calls,[call.a(),call.B.a()])\n  self.assertIs(A.foo,A.bar)\n  self.assertIsNot(mock.foo,mock.bar)\n  mock.foo.lower()\n  self.assertRaises(AssertionError,mock.bar.lower.assert_called_with)\n def test_spec_inheritance_for_classes(self):\n  class Foo(object):\n   def a(self):\n    pass\n   class Bar(object):\n    def f(self):\n     pass\n  class_mock=create_autospec(Foo)\n  self.assertIsNot(class_mock,class_mock())\n  for this_mock in class_mock,class_mock():\n   this_mock.a()\n   this_mock.a.assert_called_with()\n   self.assertRaises(TypeError,this_mock.a,'foo')\n   self.assertRaises(AttributeError,getattr,this_mock,'b')\n  instance_mock=create_autospec(Foo())\n  instance_mock.a()\n  instance_mock.a.assert_called_with()\n  self.assertRaises(TypeError,instance_mock.a,'foo')\n  self.assertRaises(AttributeError,getattr,instance_mock,'b')\n  self.assertRaises(TypeError,instance_mock)\n  instance_mock.Bar.f()\n  instance_mock.Bar.f.assert_called_with()\n  self.assertRaises(AttributeError,getattr,instance_mock.Bar,'g')\n  instance_mock.Bar().f()\n  instance_mock.Bar().f.assert_called_with()\n  self.assertRaises(AttributeError,getattr,instance_mock.Bar(),'g')\n def test_inherit(self):\n  class Foo(object):\n   a=3\n  Foo.Foo=Foo\n  mock=create_autospec(Foo)\n  instance=mock()\n  self.assertRaises(AttributeError,getattr,instance,'b')\n  attr_instance=mock.Foo()\n  self.assertRaises(AttributeError,getattr,attr_instance,'b')\n  mock=create_autospec(Foo())\n  self.assertRaises(AttributeError,getattr,mock,'b')\n  self.assertRaises(TypeError,mock)\n  call_result=mock.Foo()\n  self.assertRaises(AttributeError,getattr,call_result,'b')\n def test_builtins(self):\n  create_autospec(1)\n  create_autospec(int)\n  create_autospec('foo')\n  create_autospec(str)\n  create_autospec({})\n  create_autospec(dict)\n  create_autospec([])\n  create_autospec(list)\n  create_autospec(set())\n  create_autospec(set)\n  create_autospec(1.0)\n  create_autospec(float)\n  create_autospec(1j)\n  create_autospec(complex)\n  create_autospec(False)\n  create_autospec(True)\n def test_function(self):\n  def f(a,b):\n   pass\n  mock=create_autospec(f)\n  self.assertRaises(TypeError,mock)\n  mock(1,2)\n  mock.assert_called_with(1,2)\n  f.f=f\n  mock=create_autospec(f)\n  self.assertRaises(TypeError,mock.f)\n  mock.f(3,4)\n  mock.f.assert_called_with(3,4)\n def test_skip_attributeerrors(self):\n  class Raiser(object):\n   def __get__(self,obj,type=None):\n    if obj is None:\n     raise AttributeError('Can only be accessed via an instance')\n  class RaiserClass(object):\n   raiser=Raiser()\n   @staticmethod\n   def existing(a,b):\n    return a+b\n  s=create_autospec(RaiserClass)\n  self.assertRaises(TypeError,lambda x:s.existing(1,2,3))\n  s.existing(1,2)\n  self.assertRaises(AttributeError,lambda:s.nonexisting)\n  obj=s.raiser\n  obj.foo,obj.bar\n def test_signature_class(self):\n  class Foo(object):\n   def __init__(self,a,b=3):\n    pass\n  mock=create_autospec(Foo)\n  self.assertRaises(TypeError,mock)\n  mock(1)\n  mock.assert_called_once_with(1)\n  mock(4,5)\n  mock.assert_called_with(4,5)\n def test_class_with_no_init(self):\n  class Foo(object):\n   pass\n  create_autospec(Foo)\n def test_signature_callable(self):\n  class Callable(object):\n   def __init__(self):\n    pass\n   def __call__(self,a):\n    pass\n  mock=create_autospec(Callable)\n  mock()\n  mock.assert_called_once_with()\n  self.assertRaises(TypeError,mock,'a')\n  instance=mock()\n  self.assertRaises(TypeError,instance)\n  instance(a='a')\n  instance.assert_called_once_with(a='a')\n  instance('a')\n  instance.assert_called_with('a')\n  mock=create_autospec(Callable())\n  mock(a='a')\n  mock.assert_called_once_with(a='a')\n  self.assertRaises(TypeError,mock)\n  mock('a')\n  mock.assert_called_with('a')\n def test_signature_noncallable(self):\n  class NonCallable(object):\n   def __init__(self):\n    pass\n  mock=create_autospec(NonCallable)\n  instance=mock()\n  mock.assert_called_once_with()\n  self.assertRaises(TypeError,mock,'a')\n  self.assertRaises(TypeError,instance)\n  self.assertRaises(TypeError,instance,'a')\n  mock=create_autospec(NonCallable())\n  self.assertRaises(TypeError,mock)\n  self.assertRaises(TypeError,mock,'a')\n def test_create_autospec_none(self):\n  class Foo(object):\n   bar=None\n  mock=create_autospec(Foo)\n  none=mock.bar\n  self.assertNotIsInstance(none,type(None))\n  none.foo()\n  none.foo.assert_called_once_with()\n def test_autospec_functions_with_self_in_odd_place(self):\n  class Foo(object):\n   def f(a,self):\n    pass\n  a=create_autospec(Foo)\n  a.f(self=10)\n  a.f.assert_called_with(self=10)\n def test_autospec_property(self):\n  class Foo(object):\n   @property\n   def foo(self):\n    return 3\n  foo=create_autospec(Foo)\n  mock_property=foo.foo\n  self.assertTrue(isinstance(mock_property,MagicMock))\n  mock_property(1,2,3)\n  mock_property.abc(4,5,6)\n  mock_property.assert_called_once_with(1,2,3)\n  mock_property.abc.assert_called_once_with(4,5,6)\n def test_autospec_slots(self):\n  class Foo(object):\n   __slots__=['a']\n  foo=create_autospec(Foo)\n  mock_slot=foo.a\n  mock_slot(1,2,3)\n  mock_slot.abc(4,5,6)\n  mock_slot.assert_called_once_with(1,2,3)\n  mock_slot.abc.assert_called_once_with(4,5,6)\nclass TestCallList(unittest.TestCase):\n def test_args_list_contains_call_list(self):\n  mock=Mock()\n  self.assertIsInstance(mock.call_args_list,_CallList)\n  mock(1,2)\n  mock(a=3)\n  mock(3,4)\n  mock(b=6)\n  for kall in call(1,2),call(a=3),call(3,4),call(b=6):\n   self.assertTrue(kall in mock.call_args_list)\n  calls=[call(a=3),call(3,4)]\n  self.assertTrue(calls in mock.call_args_list)\n  calls=[call(1,2),call(a=3)]\n  self.assertTrue(calls in mock.call_args_list)\n  calls=[call(3,4),call(b=6)]\n  self.assertTrue(calls in mock.call_args_list)\n  calls=[call(3,4)]\n  self.assertTrue(calls in mock.call_args_list)\n  self.assertFalse(call('fish')in mock.call_args_list)\n  self.assertFalse([call('fish')]in mock.call_args_list)\n def test_call_list_str(self):\n  mock=Mock()\n  mock(1,2)\n  mock.foo(a=3)\n  mock.foo.bar().baz('fish',cat='dog')\n  expected=(\n  \"[call(1, 2),\\n\"\n  \" call.foo(a=3),\\n\"\n  \" call.foo.bar(),\\n\"\n  \" call.foo.bar().baz('fish', cat='dog')]\"\n  )\n  self.assertEqual(str(mock.mock_calls),expected)\n def test_propertymock(self):\n  p=patch('%s.SomeClass.one'%__name__,new_callable=PropertyMock)\n  mock=p.start()\n  try:\n   SomeClass.one\n   mock.assert_called_once_with()\n   s=SomeClass()\n   s.one\n   mock.assert_called_with()\n   self.assertEqual(mock.mock_calls,[call(),call()])\n   s.one=3\n   self.assertEqual(mock.mock_calls,[call(),call(),call(3)])\n  finally:\n   p.stop()\n def test_propertymock_returnvalue(self):\n  m=MagicMock()\n  p=PropertyMock()\n  type(m).foo=p\n  returned=m.foo\n  p.assert_called_once_with()\n  self.assertIsInstance(returned,MagicMock)\n  self.assertNotIsInstance(returned,PropertyMock)\nif __name__=='__main__':\n unittest.main()\n"], "unittest.test.testmock.testmock": ["import copy\nimport sys\nimport unittest\nfrom unittest.test.testmock.support import is_instance\nfrom unittest import mock\nfrom unittest.mock import(\ncall,DEFAULT,patch,sentinel,\nMagicMock,Mock,NonCallableMock,\nNonCallableMagicMock,_CallList,\ncreate_autospec\n)\nclass Iter(object):\n def __init__(self):\n  self.thing=iter(['this','is','an','iter'])\n def __iter__(self):\n  return self\n def next(self):\n  return next(self.thing)\n __next__=next\nclass MockTest(unittest.TestCase):\n def test_all(self):\n  exec(\"from unittest.mock import *\")\n def test_constructor(self):\n  mock=Mock()\n  self.assertFalse(mock.called,\"called not initialised correctly\")\n  self.assertEqual(mock.call_count,0,\n  \"call_count not initialised correctly\")\n  self.assertTrue(is_instance(mock.return_value,Mock),\n  \"return_value not initialised correctly\")\n  self.assertEqual(mock.call_args,None,\n  \"call_args not initialised correctly\")\n  self.assertEqual(mock.call_args_list,[],\n  \"call_args_list not initialised correctly\")\n  self.assertEqual(mock.method_calls,[],\n  \"method_calls not initialised correctly\")\n  self.assertFalse('_items'in mock.__dict__,\n  \"default mock should not have '_items' attribute\")\n  self.assertIsNone(mock._mock_parent,\n  \"parent not initialised correctly\")\n  self.assertIsNone(mock._mock_methods,\n  \"methods not initialised correctly\")\n  self.assertEqual(mock._mock_children,{},\n  \"children not initialised incorrectly\")\n def test_return_value_in_constructor(self):\n  mock=Mock(return_value=None)\n  self.assertIsNone(mock.return_value,\n  \"return value in constructor not honoured\")\n def test_repr(self):\n  mock=Mock(name='foo')\n  self.assertIn('foo',repr(mock))\n  self.assertIn(\"'%s'\"%id(mock),repr(mock))\n  mocks=[(Mock(),'mock'),(Mock(name='bar'),'bar')]\n  for mock,name in mocks:\n   self.assertIn('%s.bar'%name,repr(mock.bar))\n   self.assertIn('%s.foo()'%name,repr(mock.foo()))\n   self.assertIn('%s.foo().bing'%name,repr(mock.foo().bing))\n   self.assertIn('%s()'%name,repr(mock()))\n   self.assertIn('%s()()'%name,repr(mock()()))\n   self.assertIn('%s()().foo.bar.baz().bing'%name,\n   repr(mock()().foo.bar.baz().bing))\n def test_repr_with_spec(self):\n  class X(object):\n   pass\n  mock=Mock(spec=X)\n  self.assertIn(\" spec='X' \",repr(mock))\n  mock=Mock(spec=X())\n  self.assertIn(\" spec='X' \",repr(mock))\n  mock=Mock(spec_set=X)\n  self.assertIn(\" spec_set='X' \",repr(mock))\n  mock=Mock(spec_set=X())\n  self.assertIn(\" spec_set='X' \",repr(mock))\n  mock=Mock(spec=X,name='foo')\n  self.assertIn(\" spec='X' \",repr(mock))\n  self.assertIn(\" name='foo' \",repr(mock))\n  mock=Mock(name='foo')\n  self.assertNotIn(\"spec\",repr(mock))\n  mock=Mock()\n  self.assertNotIn(\"spec\",repr(mock))\n  mock=Mock(spec=['foo'])\n  self.assertNotIn(\"spec\",repr(mock))\n def test_side_effect(self):\n  mock=Mock()\n  def effect(*args,**kwargs):\n   raise SystemError('kablooie')\n  mock.side_effect=effect\n  self.assertRaises(SystemError,mock,1,2,fish=3)\n  mock.assert_called_with(1,2,fish=3)\n  results=[1,2,3]\n  def effect():\n   return results.pop()\n  mock.side_effect=effect\n  self.assertEqual([mock(),mock(),mock()],[3,2,1],\n  \"side effect not used correctly\")\n  mock=Mock(side_effect=sentinel.SideEffect)\n  self.assertEqual(mock.side_effect,sentinel.SideEffect,\n  \"side effect in constructor not used\")\n  def side_effect():\n   return DEFAULT\n  mock=Mock(side_effect=side_effect,return_value=sentinel.RETURN)\n  self.assertEqual(mock(),sentinel.RETURN)\n @unittest.skipUnless('java'in sys.platform,\n 'This test only applies to Jython')\n def test_java_exception_side_effect(self):\n  import java\n  mock=Mock(side_effect=java.lang.RuntimeException(\"Boom!\"))\n  try:\n   mock(1,2,fish=3)\n  except java.lang.RuntimeException:\n   pass\n  else:\n   self.fail('java exception not raised')\n  mock.assert_called_with(1,2,fish=3)\n def test_reset_mock(self):\n  parent=Mock()\n  spec=[\"something\"]\n  mock=Mock(name=\"child\",parent=parent,spec=spec)\n  mock(sentinel.Something,something=sentinel.SomethingElse)\n  something=mock.something\n  mock.something()\n  mock.side_effect=sentinel.SideEffect\n  return_value=mock.return_value\n  return_value()\n  mock.reset_mock()\n  self.assertEqual(mock._mock_name,\"child\",\n  \"name incorrectly reset\")\n  self.assertEqual(mock._mock_parent,parent,\n  \"parent incorrectly reset\")\n  self.assertEqual(mock._mock_methods,spec,\n  \"methods incorrectly reset\")\n  self.assertFalse(mock.called,\"called not reset\")\n  self.assertEqual(mock.call_count,0,\"call_count not reset\")\n  self.assertEqual(mock.call_args,None,\"call_args not reset\")\n  self.assertEqual(mock.call_args_list,[],\"call_args_list not reset\")\n  self.assertEqual(mock.method_calls,[],\n  \"method_calls not initialised correctly: %r != %r\"%\n  (mock.method_calls,[]))\n  self.assertEqual(mock.mock_calls,[])\n  self.assertEqual(mock.side_effect,sentinel.SideEffect,\n  \"side_effect incorrectly reset\")\n  self.assertEqual(mock.return_value,return_value,\n  \"return_value incorrectly reset\")\n  self.assertFalse(return_value.called,\"return value mock not reset\")\n  self.assertEqual(mock._mock_children,{'something':something},\n  \"children reset incorrectly\")\n  self.assertEqual(mock.something,something,\n  \"children incorrectly cleared\")\n  self.assertFalse(mock.something.called,\"child not reset\")\n def test_reset_mock_recursion(self):\n  mock=Mock()\n  mock.return_value=mock\n  mock.reset_mock()\n def test_call(self):\n  mock=Mock()\n  self.assertTrue(is_instance(mock.return_value,Mock),\n  \"Default return_value should be a Mock\")\n  result=mock()\n  self.assertEqual(mock(),result,\n  \"different result from consecutive calls\")\n  mock.reset_mock()\n  ret_val=mock(sentinel.Arg)\n  self.assertTrue(mock.called,\"called not set\")\n  self.assertEqual(mock.call_count,1,\"call_count incoreect\")\n  self.assertEqual(mock.call_args,((sentinel.Arg,),{}),\n  \"call_args not set\")\n  self.assertEqual(mock.call_args_list,[((sentinel.Arg,),{})],\n  \"call_args_list not initialised correctly\")\n  mock.return_value=sentinel.ReturnValue\n  ret_val=mock(sentinel.Arg,key=sentinel.KeyArg)\n  self.assertEqual(ret_val,sentinel.ReturnValue,\n  \"incorrect return value\")\n  self.assertEqual(mock.call_count,2,\"call_count incorrect\")\n  self.assertEqual(mock.call_args,\n  ((sentinel.Arg,),{'key':sentinel.KeyArg}),\n  \"call_args not set\")\n  self.assertEqual(mock.call_args_list,[\n  ((sentinel.Arg,),{}),\n  ((sentinel.Arg,),{'key':sentinel.KeyArg})\n  ],\n  \"call_args_list not set\")\n def test_call_args_comparison(self):\n  mock=Mock()\n  mock()\n  mock(sentinel.Arg)\n  mock(kw=sentinel.Kwarg)\n  mock(sentinel.Arg,kw=sentinel.Kwarg)\n  self.assertEqual(mock.call_args_list,[\n  (),\n  ((sentinel.Arg,),),\n  ({\"kw\":sentinel.Kwarg},),\n  ((sentinel.Arg,),{\"kw\":sentinel.Kwarg})\n  ])\n  self.assertEqual(mock.call_args,\n  ((sentinel.Arg,),{\"kw\":sentinel.Kwarg}))\n def test_assert_called_with(self):\n  mock=Mock()\n  mock()\n  mock.assert_called_with()\n  self.assertRaises(AssertionError,mock.assert_called_with,1)\n  mock.reset_mock()\n  self.assertRaises(AssertionError,mock.assert_called_with)\n  mock(1,2,3,a='fish',b='nothing')\n  mock.assert_called_with(1,2,3,a='fish',b='nothing')\n def test_assert_called_once_with(self):\n  mock=Mock()\n  mock()\n  mock.assert_called_once_with()\n  mock()\n  self.assertRaises(AssertionError,mock.assert_called_once_with)\n  mock.reset_mock()\n  self.assertRaises(AssertionError,mock.assert_called_once_with)\n  mock('foo','bar',baz=2)\n  mock.assert_called_once_with('foo','bar',baz=2)\n  mock.reset_mock()\n  mock('foo','bar',baz=2)\n  self.assertRaises(\n  AssertionError,\n  lambda:mock.assert_called_once_with('bob','bar',baz=2)\n  )\n def test_attribute_access_returns_mocks(self):\n  mock=Mock()\n  something=mock.something\n  self.assertTrue(is_instance(something,Mock),\"attribute isn't a mock\")\n  self.assertEqual(mock.something,something,\n  \"different attributes returned for same name\")\n  mock=Mock()\n  mock.something.return_value=3\n  self.assertEqual(mock.something(),3,\"method returned wrong value\")\n  self.assertTrue(mock.something.called,\n  \"method didn't record being called\")\n def test_attributes_have_name_and_parent_set(self):\n  mock=Mock()\n  something=mock.something\n  self.assertEqual(something._mock_name,\"something\",\n  \"attribute name not set correctly\")\n  self.assertEqual(something._mock_parent,mock,\n  \"attribute parent not set correctly\")\n def test_method_calls_recorded(self):\n  mock=Mock()\n  mock.something(3,fish=None)\n  mock.something_else.something(6,cake=sentinel.Cake)\n  self.assertEqual(mock.something_else.method_calls,\n  [(\"something\",(6,),{'cake':sentinel.Cake})],\n  \"method calls not recorded correctly\")\n  self.assertEqual(mock.method_calls,[\n  (\"something\",(3,),{'fish':None}),\n  (\"something_else.something\",(6,),{'cake':sentinel.Cake})\n  ],\n  \"method calls not recorded correctly\")\n def test_method_calls_compare_easily(self):\n  mock=Mock()\n  mock.something()\n  self.assertEqual(mock.method_calls,[('something',)])\n  self.assertEqual(mock.method_calls,[('something',(),{})])\n  mock=Mock()\n  mock.something('different')\n  self.assertEqual(mock.method_calls,[('something',('different',))])\n  self.assertEqual(mock.method_calls,\n  [('something',('different',),{})])\n  mock=Mock()\n  mock.something(x=1)\n  self.assertEqual(mock.method_calls,[('something',{'x':1})])\n  self.assertEqual(mock.method_calls,[('something',(),{'x':1})])\n  mock=Mock()\n  mock.something('different',some='more')\n  self.assertEqual(mock.method_calls,[\n  ('something',('different',),{'some':'more'})\n  ])\n def test_only_allowed_methods_exist(self):\n  for spec in['something'],('something',):\n   for arg in'spec','spec_set':\n    mock=Mock(**{arg:spec})\n    mock.something\n    self.assertRaisesRegex(\n    AttributeError,\n    \"Mock object has no attribute 'something_else'\",\n    getattr,mock,'something_else'\n    )\n def test_from_spec(self):\n  class Something(object):\n   x=3\n   __something__=None\n   def y(self):\n    pass\n  def test_attributes(mock):\n   mock.x\n   mock.y\n   mock.__something__\n   self.assertRaisesRegex(\n   AttributeError,\n   \"Mock object has no attribute 'z'\",\n   getattr,mock,'z'\n   )\n   self.assertRaisesRegex(\n   AttributeError,\n   \"Mock object has no attribute '__foobar__'\",\n   getattr,mock,'__foobar__'\n   )\n  test_attributes(Mock(spec=Something))\n  test_attributes(Mock(spec=Something()))\n def test_wraps_calls(self):\n  real=Mock()\n  mock=Mock(wraps=real)\n  self.assertEqual(mock(),real())\n  real.reset_mock()\n  mock(1,2,fish=3)\n  real.assert_called_with(1,2,fish=3)\n def test_wraps_call_with_nondefault_return_value(self):\n  real=Mock()\n  mock=Mock(wraps=real)\n  mock.return_value=3\n  self.assertEqual(mock(),3)\n  self.assertFalse(real.called)\n def test_wraps_attributes(self):\n  class Real(object):\n   attribute=Mock()\n  real=Real()\n  mock=Mock(wraps=real)\n  self.assertEqual(mock.attribute(),real.attribute())\n  self.assertRaises(AttributeError,lambda:mock.fish)\n  self.assertNotEqual(mock.attribute,real.attribute)\n  result=mock.attribute.frog(1,2,fish=3)\n  Real.attribute.frog.assert_called_with(1,2,fish=3)\n  self.assertEqual(result,Real.attribute.frog())\n def test_exceptional_side_effect(self):\n  mock=Mock(side_effect=AttributeError)\n  self.assertRaises(AttributeError,mock)\n  mock=Mock(side_effect=AttributeError('foo'))\n  self.assertRaises(AttributeError,mock)\n def test_baseexceptional_side_effect(self):\n  mock=Mock(side_effect=KeyboardInterrupt)\n  self.assertRaises(KeyboardInterrupt,mock)\n  mock=Mock(side_effect=KeyboardInterrupt('foo'))\n  self.assertRaises(KeyboardInterrupt,mock)\n def test_assert_called_with_message(self):\n  mock=Mock()\n  self.assertRaisesRegex(AssertionError,'Not called',\n  mock.assert_called_with)\n def test__name__(self):\n  mock=Mock()\n  self.assertRaises(AttributeError,lambda:mock.__name__)\n  mock.__name__='foo'\n  self.assertEqual(mock.__name__,'foo')\n def test_spec_list_subclass(self):\n  class Sub(list):\n   pass\n  mock=Mock(spec=Sub(['foo']))\n  mock.append(3)\n  mock.append.assert_called_with(3)\n  self.assertRaises(AttributeError,getattr,mock,'foo')\n def test_spec_class(self):\n  class X(object):\n   pass\n  mock=Mock(spec=X)\n  self.assertTrue(isinstance(mock,X))\n  mock=Mock(spec=X())\n  self.assertTrue(isinstance(mock,X))\n  self.assertIs(mock.__class__,X)\n  self.assertEqual(Mock().__class__.__name__,'Mock')\n  mock=Mock(spec_set=X)\n  self.assertTrue(isinstance(mock,X))\n  mock=Mock(spec_set=X())\n  self.assertTrue(isinstance(mock,X))\n def test_setting_attribute_with_spec_set(self):\n  class X(object):\n   y=3\n  mock=Mock(spec=X)\n  mock.x='foo'\n  mock=Mock(spec_set=X)\n  def set_attr():\n   mock.x='foo'\n  mock.y='foo'\n  self.assertRaises(AttributeError,set_attr)\n def test_copy(self):\n  current=sys.getrecursionlimit()\n  self.addCleanup(sys.setrecursionlimit,current)\n  sys.setrecursionlimit(int(10e8))\n  copy.copy(Mock())\n def test_subclass_with_properties(self):\n  class SubClass(Mock):\n   def _get(self):\n    return 3\n   def _set(self,value):\n    raise NameError('strange error')\n   some_attribute=property(_get,_set)\n  s=SubClass(spec_set=SubClass)\n  self.assertEqual(s.some_attribute,3)\n  def test():\n   s.some_attribute=3\n  self.assertRaises(NameError,test)\n  def test():\n   s.foo='bar'\n  self.assertRaises(AttributeError,test)\n def test_setting_call(self):\n  mock=Mock()\n  def __call__(self,a):\n   return self._mock_call(a)\n  type(mock).__call__=__call__\n  mock('one')\n  mock.assert_called_with('one')\n  self.assertRaises(TypeError,mock,'one','two')\n def test_dir(self):\n  mock=Mock()\n  attrs=set(dir(mock))\n  type_attrs=set([m for m in dir(Mock)if not m.startswith('_')])\n  self.assertEqual(set(),type_attrs-attrs)\n  mock.a,mock.b\n  self.assertIn('a',dir(mock))\n  self.assertIn('b',dir(mock))\n  mock.c=mock.d=None\n  self.assertIn('c',dir(mock))\n  self.assertIn('d',dir(mock))\n  mock.__iter__=lambda s:iter([])\n  self.assertIn('__iter__',dir(mock))\n def test_dir_from_spec(self):\n  mock=Mock(spec=unittest.TestCase)\n  testcase_attrs=set(dir(unittest.TestCase))\n  attrs=set(dir(mock))\n  self.assertEqual(set(),testcase_attrs-attrs)\n  mock.version=3\n  self.assertEqual(dir(mock).count('version'),1)\n def test_filter_dir(self):\n  patcher=patch.object(mock,'FILTER_DIR',False)\n  patcher.start()\n  try:\n   attrs=set(dir(Mock()))\n   type_attrs=set(dir(Mock))\n   self.assertEqual(set(),type_attrs-attrs)\n  finally:\n   patcher.stop()\n def test_configure_mock(self):\n  mock=Mock(foo='bar')\n  self.assertEqual(mock.foo,'bar')\n  mock=MagicMock(foo='bar')\n  self.assertEqual(mock.foo,'bar')\n  kwargs={'side_effect':KeyError,'foo.bar.return_value':33,\n  'foo':MagicMock()}\n  mock=Mock(**kwargs)\n  self.assertRaises(KeyError,mock)\n  self.assertEqual(mock.foo.bar(),33)\n  self.assertIsInstance(mock.foo,MagicMock)\n  mock=Mock()\n  mock.configure_mock(**kwargs)\n  self.assertRaises(KeyError,mock)\n  self.assertEqual(mock.foo.bar(),33)\n  self.assertIsInstance(mock.foo,MagicMock)\n def assertRaisesWithMsg(self,exception,message,func,*args,**kwargs):\n  try:\n   func(*args,**kwargs)\n  except:\n   instance=sys.exc_info()[1]\n   self.assertIsInstance(instance,exception)\n  else:\n   self.fail('Exception %r not raised'%(exception,))\n  msg=str(instance)\n  self.assertEqual(msg,message)\n def test_assert_called_with_failure_message(self):\n  mock=NonCallableMock()\n  expected=\"mock(1, '2', 3, bar='foo')\"\n  message='Expected call: %s\\nNot called'\n  self.assertRaisesWithMsg(\n  AssertionError,message%(expected,),\n  mock.assert_called_with,1,'2',3,bar='foo'\n  )\n  mock.foo(1,'2',3,foo='foo')\n  asserters=[\n  mock.foo.assert_called_with,mock.foo.assert_called_once_with\n  ]\n  for meth in asserters:\n   actual=\"foo(1, '2', 3, foo='foo')\"\n   expected=\"foo(1, '2', 3, bar='foo')\"\n   message='Expected call: %s\\nActual call: %s'\n   self.assertRaisesWithMsg(\n   AssertionError,message%(expected,actual),\n   meth,1,'2',3,bar='foo'\n   )\n  for meth in asserters:\n   actual=\"foo(1, '2', 3, foo='foo')\"\n   expected=\"foo(bar='foo')\"\n   message='Expected call: %s\\nActual call: %s'\n   self.assertRaisesWithMsg(\n   AssertionError,message%(expected,actual),\n   meth,bar='foo'\n   )\n  for meth in asserters:\n   actual=\"foo(1, '2', 3, foo='foo')\"\n   expected=\"foo(1, 2, 3)\"\n   message='Expected call: %s\\nActual call: %s'\n   self.assertRaisesWithMsg(\n   AssertionError,message%(expected,actual),\n   meth,1,2,3\n   )\n  for meth in asserters:\n   actual=\"foo(1, '2', 3, foo='foo')\"\n   expected=\"foo()\"\n   message='Expected call: %s\\nActual call: %s'\n   self.assertRaisesWithMsg(\n   AssertionError,message%(expected,actual),meth\n   )\n def test_mock_calls(self):\n  mock=MagicMock()\n  self.assertIs(mock.mock_calls==[],True)\n  mock=MagicMock()\n  mock()\n  expected=[('',(),{})]\n  self.assertEqual(mock.mock_calls,expected)\n  mock.foo()\n  expected.append(call.foo())\n  self.assertEqual(mock.mock_calls,expected)\n  self.assertEqual(mock.foo.mock_calls,[('',(),{})])\n  mock=MagicMock()\n  mock().foo(1,2,3,a=4,b=5)\n  expected=[\n  ('',(),{}),('().foo',(1,2,3),dict(a=4,b=5))\n  ]\n  self.assertEqual(mock.mock_calls,expected)\n  self.assertEqual(mock.return_value.foo.mock_calls,\n  [('',(1,2,3),dict(a=4,b=5))])\n  self.assertEqual(mock.return_value.mock_calls,\n  [('foo',(1,2,3),dict(a=4,b=5))])\n  mock=MagicMock()\n  mock().foo.bar().baz()\n  expected=[\n  ('',(),{}),('().foo.bar',(),{}),\n  ('().foo.bar().baz',(),{})\n  ]\n  self.assertEqual(mock.mock_calls,expected)\n  self.assertEqual(mock().mock_calls,\n  call.foo.bar().baz().call_list())\n  for kwargs in dict(),dict(name='bar'):\n   mock=MagicMock(**kwargs)\n   int(mock.foo)\n   expected=[('foo.__int__',(),{})]\n   self.assertEqual(mock.mock_calls,expected)\n   mock=MagicMock(**kwargs)\n   mock.a()()\n   expected=[('a',(),{}),('a()',(),{})]\n   self.assertEqual(mock.mock_calls,expected)\n   self.assertEqual(mock.a().mock_calls,[call()])\n   mock=MagicMock(**kwargs)\n   mock(1)(2)(3)\n   self.assertEqual(mock.mock_calls,call(1)(2)(3).call_list())\n   self.assertEqual(mock().mock_calls,call(2)(3).call_list())\n   self.assertEqual(mock()().mock_calls,call(3).call_list())\n   mock=MagicMock(**kwargs)\n   mock(1)(2)(3).a.b.c(4)\n   self.assertEqual(mock.mock_calls,\n   call(1)(2)(3).a.b.c(4).call_list())\n   self.assertEqual(mock().mock_calls,\n   call(2)(3).a.b.c(4).call_list())\n   self.assertEqual(mock()().mock_calls,\n   call(3).a.b.c(4).call_list())\n   mock=MagicMock(**kwargs)\n   int(mock().foo.bar().baz())\n   last_call=('().foo.bar().baz().__int__',(),{})\n   self.assertEqual(mock.mock_calls[-1],last_call)\n   self.assertEqual(mock().mock_calls,\n   call.foo.bar().baz().__int__().call_list())\n   self.assertEqual(mock().foo.bar().mock_calls,\n   call.baz().__int__().call_list())\n   self.assertEqual(mock().foo.bar().baz.mock_calls,\n   call().__int__().call_list())\n def test_subclassing(self):\n  class Subclass(Mock):\n   pass\n  mock=Subclass()\n  self.assertIsInstance(mock.foo,Subclass)\n  self.assertIsInstance(mock(),Subclass)\n  class Subclass(Mock):\n   def _get_child_mock(self,**kwargs):\n    return Mock(**kwargs)\n  mock=Subclass()\n  self.assertNotIsInstance(mock.foo,Subclass)\n  self.assertNotIsInstance(mock(),Subclass)\n def test_arg_lists(self):\n  mocks=[\n  Mock(),\n  MagicMock(),\n  NonCallableMock(),\n  NonCallableMagicMock()\n  ]\n  def assert_attrs(mock):\n   names='call_args_list','method_calls','mock_calls'\n   for name in names:\n    attr=getattr(mock,name)\n    self.assertIsInstance(attr,_CallList)\n    self.assertIsInstance(attr,list)\n    self.assertEqual(attr,[])\n  for mock in mocks:\n   assert_attrs(mock)\n   if callable(mock):\n    mock()\n    mock(1,2)\n    mock(a=3)\n    mock.reset_mock()\n    assert_attrs(mock)\n   mock.foo()\n   mock.foo.bar(1,a=3)\n   mock.foo(1).bar().baz(3)\n   mock.reset_mock()\n   assert_attrs(mock)\n def test_call_args_two_tuple(self):\n  mock=Mock()\n  mock(1,a=3)\n  mock(2,b=4)\n  self.assertEqual(len(mock.call_args),2)\n  args,kwargs=mock.call_args\n  self.assertEqual(args,(2,))\n  self.assertEqual(kwargs,dict(b=4))\n  expected_list=[((1,),dict(a=3)),((2,),dict(b=4))]\n  for expected,call_args in zip(expected_list,mock.call_args_list):\n   self.assertEqual(len(call_args),2)\n   self.assertEqual(expected[0],call_args[0])\n   self.assertEqual(expected[1],call_args[1])\n def test_side_effect_iterator(self):\n  mock=Mock(side_effect=iter([1,2,3]))\n  self.assertEqual([mock(),mock(),mock()],[1,2,3])\n  self.assertRaises(StopIteration,mock)\n  mock=MagicMock(side_effect=['a','b','c'])\n  self.assertEqual([mock(),mock(),mock()],['a','b','c'])\n  self.assertRaises(StopIteration,mock)\n  mock=Mock(side_effect='ghi')\n  self.assertEqual([mock(),mock(),mock()],['g','h','i'])\n  self.assertRaises(StopIteration,mock)\n  class Foo(object):\n   pass\n  mock=MagicMock(side_effect=Foo)\n  self.assertIsInstance(mock(),Foo)\n  mock=Mock(side_effect=Iter())\n  self.assertEqual([mock(),mock(),mock(),mock()],\n  ['this','is','an','iter'])\n  self.assertRaises(StopIteration,mock)\n def test_side_effect_iterator_exceptions(self):\n  for Klass in Mock,MagicMock:\n   iterable=(ValueError,3,KeyError,6)\n   m=Klass(side_effect=iterable)\n   self.assertRaises(ValueError,m)\n   self.assertEqual(m(),3)\n   self.assertRaises(KeyError,m)\n   self.assertEqual(m(),6)\n def test_side_effect_setting_iterator(self):\n  mock=Mock()\n  mock.side_effect=iter([1,2,3])\n  self.assertEqual([mock(),mock(),mock()],[1,2,3])\n  self.assertRaises(StopIteration,mock)\n  side_effect=mock.side_effect\n  self.assertIsInstance(side_effect,type(iter([])))\n  mock.side_effect=['a','b','c']\n  self.assertEqual([mock(),mock(),mock()],['a','b','c'])\n  self.assertRaises(StopIteration,mock)\n  side_effect=mock.side_effect\n  self.assertIsInstance(side_effect,type(iter([])))\n  this_iter=Iter()\n  mock.side_effect=this_iter\n  self.assertEqual([mock(),mock(),mock(),mock()],\n  ['this','is','an','iter'])\n  self.assertRaises(StopIteration,mock)\n  self.assertIs(mock.side_effect,this_iter)\n def test_assert_has_calls_any_order(self):\n  mock=Mock()\n  mock(1,2)\n  mock(a=3)\n  mock(3,4)\n  mock(b=6)\n  mock(b=6)\n  kalls=[\n  call(1,2),({'a':3},),\n  ((3,4),),((),{'a':3}),\n  ('',(1,2)),('',{'a':3}),\n  ('',(1,2),{}),('',(),{'a':3})\n  ]\n  for kall in kalls:\n   mock.assert_has_calls([kall],any_order=True)\n  for kall in call(1,'2'),call(b=3),call(),3,None,'foo':\n   self.assertRaises(\n   AssertionError,mock.assert_has_calls,\n   [kall],any_order=True\n   )\n  kall_lists=[\n  [call(1,2),call(b=6)],\n  [call(3,4),call(1,2)],\n  [call(b=6),call(b=6)],\n  ]\n  for kall_list in kall_lists:\n   mock.assert_has_calls(kall_list,any_order=True)\n  kall_lists=[\n  [call(b=6),call(b=6),call(b=6)],\n  [call(1,2),call(1,2)],\n  [call(3,4),call(1,2),call(5,7)],\n  [call(b=6),call(3,4),call(b=6),call(1,2),call(b=6)],\n  ]\n  for kall_list in kall_lists:\n   self.assertRaises(\n   AssertionError,mock.assert_has_calls,\n   kall_list,any_order=True\n   )\n def test_assert_has_calls(self):\n  kalls1=[\n  call(1,2),({'a':3},),\n  ((3,4),),call(b=6),\n  ('',(1,),{'b':6}),\n  ]\n  kalls2=[call.foo(),call.bar(1)]\n  kalls2.extend(call.spam().baz(a=3).call_list())\n  kalls2.extend(call.bam(set(),foo={}).fish([1]).call_list())\n  mocks=[]\n  for mock in Mock(),MagicMock():\n   mock(1,2)\n   mock(a=3)\n   mock(3,4)\n   mock(b=6)\n   mock(1,b=6)\n   mocks.append((mock,kalls1))\n  mock=Mock()\n  mock.foo()\n  mock.bar(1)\n  mock.spam().baz(a=3)\n  mock.bam(set(),foo={}).fish([1])\n  mocks.append((mock,kalls2))\n  for mock,kalls in mocks:\n   for i in range(len(kalls)):\n    for step in 1,2,3:\n     these=kalls[i:i+step]\n     mock.assert_has_calls(these)\n     if len(these)>1:\n      self.assertRaises(\n      AssertionError,\n      mock.assert_has_calls,\n      list(reversed(these))\n      )\n def test_assert_any_call(self):\n  mock=Mock()\n  mock(1,2)\n  mock(a=3)\n  mock(1,b=6)\n  mock.assert_any_call(1,2)\n  mock.assert_any_call(a=3)\n  mock.assert_any_call(1,b=6)\n  self.assertRaises(\n  AssertionError,\n  mock.assert_any_call\n  )\n  self.assertRaises(\n  AssertionError,\n  mock.assert_any_call,\n  1,3\n  )\n  self.assertRaises(\n  AssertionError,\n  mock.assert_any_call,\n  a=4\n  )\n def test_mock_calls_create_autospec(self):\n  def f(a,b):\n   pass\n  obj=Iter()\n  obj.f=f\n  funcs=[\n  create_autospec(f),\n  create_autospec(obj).f\n  ]\n  for func in funcs:\n   func(1,2)\n   func(3,4)\n   self.assertEqual(\n   func.mock_calls,[call(1,2),call(3,4)]\n   )\n def test_mock_add_spec(self):\n  class _One(object):\n   one=1\n  class _Two(object):\n   two=2\n  class Anything(object):\n   one=two=three='four'\n  klasses=[\n  Mock,MagicMock,NonCallableMock,NonCallableMagicMock\n  ]\n  for Klass in list(klasses):\n   klasses.append(lambda K=Klass:K(spec=Anything))\n   klasses.append(lambda K=Klass:K(spec_set=Anything))\n  for Klass in klasses:\n   for kwargs in dict(),dict(spec_set=True):\n    mock=Klass()\n    mock.one,mock.two,mock.three\n    for One,Two in[(_One,_Two),(['one'],['two'])]:\n     for kwargs in dict(),dict(spec_set=True):\n      mock.mock_add_spec(One,**kwargs)\n      mock.one\n      self.assertRaises(\n      AttributeError,getattr,mock,'two'\n      )\n      self.assertRaises(\n      AttributeError,getattr,mock,'three'\n      )\n      if'spec_set'in kwargs:\n       self.assertRaises(\n       AttributeError,setattr,mock,'three',None\n       )\n      mock.mock_add_spec(Two,**kwargs)\n      self.assertRaises(\n      AttributeError,getattr,mock,'one'\n      )\n      mock.two\n      self.assertRaises(\n      AttributeError,getattr,mock,'three'\n      )\n      if'spec_set'in kwargs:\n       self.assertRaises(\n       AttributeError,setattr,mock,'three',None\n       )\n def test_mock_add_spec_magic_methods(self):\n  for Klass in MagicMock,NonCallableMagicMock:\n   mock=Klass()\n   int(mock)\n   mock.mock_add_spec(object)\n   self.assertRaises(TypeError,int,mock)\n   mock=Klass()\n   mock['foo']\n   mock.__int__.return_value=4\n   mock.mock_add_spec(int)\n   self.assertEqual(int(mock),4)\n   self.assertRaises(TypeError,lambda:mock['foo'])\n def test_adding_child_mock(self):\n  for Klass in NonCallableMock,Mock,MagicMock,NonCallableMagicMock:\n   mock=Klass()\n   mock.foo=Mock()\n   mock.foo()\n   self.assertEqual(mock.method_calls,[call.foo()])\n   self.assertEqual(mock.mock_calls,[call.foo()])\n   mock=Klass()\n   mock.bar=Mock(name='name')\n   mock.bar()\n   self.assertEqual(mock.method_calls,[])\n   self.assertEqual(mock.mock_calls,[])\n   mock=Klass()\n   mock.baz=MagicMock()()\n   mock.baz()\n   self.assertEqual(mock.method_calls,[])\n   self.assertEqual(mock.mock_calls,[])\n def test_adding_return_value_mock(self):\n  for Klass in Mock,MagicMock:\n   mock=Klass()\n   mock.return_value=MagicMock()\n   mock()()\n   self.assertEqual(mock.mock_calls,[call(),call()()])\n def test_manager_mock(self):\n  class Foo(object):\n   one='one'\n   two='two'\n  manager=Mock()\n  p1=patch.object(Foo,'one')\n  p2=patch.object(Foo,'two')\n  mock_one=p1.start()\n  self.addCleanup(p1.stop)\n  mock_two=p2.start()\n  self.addCleanup(p2.stop)\n  manager.attach_mock(mock_one,'one')\n  manager.attach_mock(mock_two,'two')\n  Foo.two()\n  Foo.one()\n  self.assertEqual(manager.mock_calls,[call.two(),call.one()])\n def test_magic_methods_mock_calls(self):\n  for Klass in Mock,MagicMock:\n   m=Klass()\n   m.__int__=Mock(return_value=3)\n   m.__float__=MagicMock(return_value=3.0)\n   int(m)\n   float(m)\n   self.assertEqual(m.mock_calls,[call.__int__(),call.__float__()])\n   self.assertEqual(m.method_calls,[])\n def test_attribute_deletion(self):\n  for Klass in Mock,MagicMock,NonCallableMagicMock,NonCallableMock:\n   m=Klass()\n   original=m.foo\n   m.foo=3\n   del m.foo\n   self.assertEqual(m.foo,original)\n   new=m.foo=Mock()\n   del m.foo\n   self.assertEqual(m.foo,new)\n def test_mock_parents(self):\n  for Klass in Mock,MagicMock:\n   m=Klass()\n   original_repr=repr(m)\n   m.return_value=m\n   self.assertIs(m(),m)\n   self.assertEqual(repr(m),original_repr)\n   m.reset_mock()\n   self.assertIs(m(),m)\n   self.assertEqual(repr(m),original_repr)\n   m=Klass()\n   m.b=m.a\n   self.assertIn(\"name='mock.a'\",repr(m.b))\n   self.assertIn(\"name='mock.a'\",repr(m.a))\n   m.reset_mock()\n   self.assertIn(\"name='mock.a'\",repr(m.b))\n   self.assertIn(\"name='mock.a'\",repr(m.a))\n   m=Klass()\n   original_repr=repr(m)\n   m.a=m()\n   m.a.return_value=m\n   self.assertEqual(repr(m),original_repr)\n   self.assertEqual(repr(m.a()),original_repr)\n def test_attach_mock(self):\n  classes=Mock,MagicMock,NonCallableMagicMock,NonCallableMock\n  for Klass in classes:\n   for Klass2 in classes:\n    m=Klass()\n    m2=Klass2(name='foo')\n    m.attach_mock(m2,'bar')\n    self.assertIs(m.bar,m2)\n    self.assertIn(\"name='mock.bar'\",repr(m2))\n    m.bar.baz(1)\n    self.assertEqual(m.mock_calls,[call.bar.baz(1)])\n    self.assertEqual(m.method_calls,[call.bar.baz(1)])\n def test_attach_mock_return_value(self):\n  classes=Mock,MagicMock,NonCallableMagicMock,NonCallableMock\n  for Klass in Mock,MagicMock:\n   for Klass2 in classes:\n    m=Klass()\n    m2=Klass2(name='foo')\n    m.attach_mock(m2,'return_value')\n    self.assertIs(m(),m2)\n    self.assertIn(\"name='mock()'\",repr(m2))\n    m2.foo()\n    self.assertEqual(m.mock_calls,call().foo().call_list())\n def test_attribute_deletion(self):\n  for mock in Mock(),MagicMock():\n   self.assertTrue(hasattr(mock,'m'))\n   del mock.m\n   self.assertFalse(hasattr(mock,'m'))\n   del mock.f\n   self.assertFalse(hasattr(mock,'f'))\n   self.assertRaises(AttributeError,getattr,mock,'f')\n def test_class_assignable(self):\n  for mock in Mock(),MagicMock():\n   self.assertNotIsInstance(mock,int)\n   mock.__class__=int\n   self.assertIsInstance(mock,int)\n   mock.foo\nif __name__=='__main__':\n unittest.main()\n"], "unittest": ["\n__all__=['TestResult','TestCase','TestSuite',\n'TextTestRunner','TestLoader','FunctionTestCase','main',\n'defaultTestLoader','SkipTest','skip','skipIf','skipUnless',\n'expectedFailure','TextTestResult','installHandler',\n'registerResult','removeResult','removeHandler']\n__all__.extend(['getTestCaseNames','makeSuite','findTestCases'])\n__unittest=True\nfrom.result import TestResult\nfrom.case import(TestCase,FunctionTestCase,SkipTest,skip,skipIf,\nskipUnless,expectedFailure)\nfrom.suite import BaseTestSuite,TestSuite\nfrom.loader import(TestLoader,defaultTestLoader,makeSuite,getTestCaseNames,\nfindTestCases)\nfrom.main import TestProgram,main\nfrom.runner import TextTestRunner,TextTestResult\nfrom.signals import installHandler,registerResult,removeResult,removeHandler\n_TextTestResult=TextTestResult\n", 1], "unittest.test.test_skipping": ["import unittest\nfrom.support import LoggingResult\nclass Test_TestSkipping(unittest.TestCase):\n def test_skipping(self):\n  class Foo(unittest.TestCase):\n   def test_skip_me(self):\n    self.skipTest(\"skip\")\n  events=[]\n  result=LoggingResult(events)\n  test=Foo(\"test_skip_me\")\n  test.run(result)\n  self.assertEqual(events,['startTest','addSkip','stopTest'])\n  self.assertEqual(result.skipped,[(test,\"skip\")])\n  class Foo(unittest.TestCase):\n   def setUp(self):\n    self.skipTest(\"testing\")\n   def test_nothing(self):pass\n  events=[]\n  result=LoggingResult(events)\n  test=Foo(\"test_nothing\")\n  test.run(result)\n  self.assertEqual(events,['startTest','addSkip','stopTest'])\n  self.assertEqual(result.skipped,[(test,\"testing\")])\n  self.assertEqual(result.testsRun,1)\n def test_skipping_decorators(self):\n  op_table=((unittest.skipUnless,False,True),\n  (unittest.skipIf,True,False))\n  for deco,do_skip,dont_skip in op_table:\n   class Foo(unittest.TestCase):\n    @deco(do_skip,\"testing\")\n    def test_skip(self):pass\n    @deco(dont_skip,\"testing\")\n    def test_dont_skip(self):pass\n   test_do_skip=Foo(\"test_skip\")\n   test_dont_skip=Foo(\"test_dont_skip\")\n   suite=unittest.TestSuite([test_do_skip,test_dont_skip])\n   events=[]\n   result=LoggingResult(events)\n   suite.run(result)\n   self.assertEqual(len(result.skipped),1)\n   expected=['startTest','addSkip','stopTest',\n   'startTest','addSuccess','stopTest']\n   self.assertEqual(events,expected)\n   self.assertEqual(result.testsRun,2)\n   self.assertEqual(result.skipped,[(test_do_skip,\"testing\")])\n   self.assertTrue(result.wasSuccessful())\n def test_skip_class(self):\n  @unittest.skip(\"testing\")\n  class Foo(unittest.TestCase):\n   def test_1(self):\n    record.append(1)\n  record=[]\n  result=unittest.TestResult()\n  test=Foo(\"test_1\")\n  suite=unittest.TestSuite([test])\n  suite.run(result)\n  self.assertEqual(result.skipped,[(test,\"testing\")])\n  self.assertEqual(record,[])\n def test_skip_non_unittest_class(self):\n  @unittest.skip(\"testing\")\n  class Mixin:\n   def test_1(self):\n    record.append(1)\n  class Foo(Mixin,unittest.TestCase):\n   pass\n  record=[]\n  result=unittest.TestResult()\n  test=Foo(\"test_1\")\n  suite=unittest.TestSuite([test])\n  suite.run(result)\n  self.assertEqual(result.skipped,[(test,\"testing\")])\n  self.assertEqual(record,[])\n def test_expected_failure(self):\n  class Foo(unittest.TestCase):\n   @unittest.expectedFailure\n   def test_die(self):\n    self.fail(\"help me!\")\n  events=[]\n  result=LoggingResult(events)\n  test=Foo(\"test_die\")\n  test.run(result)\n  self.assertEqual(events,\n  ['startTest','addExpectedFailure','stopTest'])\n  self.assertEqual(result.expectedFailures[0][0],test)\n  self.assertTrue(result.wasSuccessful())\n def test_unexpected_success(self):\n  class Foo(unittest.TestCase):\n   @unittest.expectedFailure\n   def test_die(self):\n    pass\n  events=[]\n  result=LoggingResult(events)\n  test=Foo(\"test_die\")\n  test.run(result)\n  self.assertEqual(events,\n  ['startTest','addUnexpectedSuccess','stopTest'])\n  self.assertFalse(result.failures)\n  self.assertEqual(result.unexpectedSuccesses,[test])\n  self.assertTrue(result.wasSuccessful())\n def test_skip_doesnt_run_setup(self):\n  class Foo(unittest.TestCase):\n   wasSetUp=False\n   wasTornDown=False\n   def setUp(self):\n    Foo.wasSetUp=True\n   def tornDown(self):\n    Foo.wasTornDown=True\n   @unittest.skip('testing')\n   def test_1(self):\n    pass\n  result=unittest.TestResult()\n  test=Foo(\"test_1\")\n  suite=unittest.TestSuite([test])\n  suite.run(result)\n  self.assertEqual(result.skipped,[(test,\"testing\")])\n  self.assertFalse(Foo.wasSetUp)\n  self.assertFalse(Foo.wasTornDown)\n def test_decorated_skip(self):\n  def decorator(func):\n   def inner(*a):\n    return func(*a)\n   return inner\n  class Foo(unittest.TestCase):\n   @decorator\n   @unittest.skip('testing')\n   def test_1(self):\n    pass\n  result=unittest.TestResult()\n  test=Foo(\"test_1\")\n  suite=unittest.TestSuite([test])\n  suite.run(result)\n  self.assertEqual(result.skipped,[(test,\"testing\")])\n"], "unittest.test.testmock.testsentinel": ["import unittest\nfrom unittest.mock import sentinel,DEFAULT\nclass SentinelTest(unittest.TestCase):\n def testSentinels(self):\n  self.assertEqual(sentinel.whatever,sentinel.whatever,\n  'sentinel not stored')\n  self.assertNotEqual(sentinel.whatever,sentinel.whateverelse,\n  'sentinel should be unique')\n def testSentinelName(self):\n  self.assertEqual(str(sentinel.whatever),'sentinel.whatever',\n  'sentinel name incorrect')\n def testDEFAULT(self):\n  self.assertTrue(DEFAULT is sentinel.DEFAULT)\n def testBases(self):\n  self.assertRaises(AttributeError,lambda:sentinel.__bases__)\nif __name__=='__main__':\n unittest.main()\n"], "unittest.test.test_loader": ["import sys\nimport types\nimport unittest\nclass Test_TestLoader(unittest.TestCase):\n def test_loadTestsFromTestCase(self):\n  class Foo(unittest.TestCase):\n   def test_1(self):pass\n   def test_2(self):pass\n   def foo_bar(self):pass\n  tests=unittest.TestSuite([Foo('test_1'),Foo('test_2')])\n  loader=unittest.TestLoader()\n  self.assertEqual(loader.loadTestsFromTestCase(Foo),tests)\n def test_loadTestsFromTestCase__no_matches(self):\n  class Foo(unittest.TestCase):\n   def foo_bar(self):pass\n  empty_suite=unittest.TestSuite()\n  loader=unittest.TestLoader()\n  self.assertEqual(loader.loadTestsFromTestCase(Foo),empty_suite)\n def test_loadTestsFromTestCase__TestSuite_subclass(self):\n  class NotATestCase(unittest.TestSuite):\n   pass\n  loader=unittest.TestLoader()\n  try:\n   loader.loadTestsFromTestCase(NotATestCase)\n  except TypeError:\n   pass\n  else:\n   self.fail('Should raise TypeError')\n def test_loadTestsFromTestCase__default_method_name(self):\n  class Foo(unittest.TestCase):\n   def runTest(self):\n    pass\n  loader=unittest.TestLoader()\n  self.assertFalse('runTest'.startswith(loader.testMethodPrefix))\n  suite=loader.loadTestsFromTestCase(Foo)\n  self.assertIsInstance(suite,loader.suiteClass)\n  self.assertEqual(list(suite),[Foo('runTest')])\n def test_loadTestsFromModule__TestCase_subclass(self):\n  m=types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testcase_1=MyTestCase\n  loader=unittest.TestLoader()\n  suite=loader.loadTestsFromModule(m)\n  self.assertIsInstance(suite,loader.suiteClass)\n  expected=[loader.suiteClass([MyTestCase('test')])]\n  self.assertEqual(list(suite),expected)\n def test_loadTestsFromModule__no_TestCase_instances(self):\n  m=types.ModuleType('m')\n  loader=unittest.TestLoader()\n  suite=loader.loadTestsFromModule(m)\n  self.assertIsInstance(suite,loader.suiteClass)\n  self.assertEqual(list(suite),[])\n def test_loadTestsFromModule__no_TestCase_tests(self):\n  m=types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   pass\n  m.testcase_1=MyTestCase\n  loader=unittest.TestLoader()\n  suite=loader.loadTestsFromModule(m)\n  self.assertIsInstance(suite,loader.suiteClass)\n  self.assertEqual(list(suite),[loader.suiteClass()])\n def test_loadTestsFromModule__not_a_module(self):\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  class NotAModule(object):\n   test_2=MyTestCase\n  loader=unittest.TestLoader()\n  suite=loader.loadTestsFromModule(NotAModule)\n  reference=[unittest.TestSuite([MyTestCase('test')])]\n  self.assertEqual(list(suite),reference)\n def test_loadTestsFromModule__load_tests(self):\n  m=types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testcase_1=MyTestCase\n  load_tests_args=[]\n  def load_tests(loader,tests,pattern):\n   self.assertIsInstance(tests,unittest.TestSuite)\n   load_tests_args.extend((loader,tests,pattern))\n   return tests\n  m.load_tests=load_tests\n  loader=unittest.TestLoader()\n  suite=loader.loadTestsFromModule(m)\n  self.assertIsInstance(suite,unittest.TestSuite)\n  self.assertEqual(load_tests_args,[loader,suite,None])\n  load_tests_args=[]\n  suite=loader.loadTestsFromModule(m,use_load_tests=False)\n  self.assertEqual(load_tests_args,[])\n def test_loadTestsFromModule__faulty_load_tests(self):\n  m=types.ModuleType('m')\n  def load_tests(loader,tests,pattern):\n   raise TypeError('some failure')\n  m.load_tests=load_tests\n  loader=unittest.TestLoader()\n  suite=loader.loadTestsFromModule(m)\n  self.assertIsInstance(suite,unittest.TestSuite)\n  self.assertEqual(suite.countTestCases(),1)\n  test=list(suite)[0]\n  self.assertRaisesRegex(TypeError,\"some failure\",test.m)\n def test_loadTestsFromName__empty_name(self):\n  loader=unittest.TestLoader()\n  try:\n   loader.loadTestsFromName('')\n  except ValueError as e:\n   self.assertEqual(str(e),\"Empty module name\")\n  else:\n   self.fail(\"TestLoader.loadTestsFromName failed to raise ValueError\")\n def test_loadTestsFromName__malformed_name(self):\n  loader=unittest.TestLoader()\n  try:\n   loader.loadTestsFromName('abc () //')\n  except ValueError:\n   pass\n  except ImportError:\n   pass\n  else:\n   self.fail(\"TestLoader.loadTestsFromName failed to raise ValueError\")\n def test_loadTestsFromName__unknown_module_name(self):\n  loader=unittest.TestLoader()\n  try:\n   loader.loadTestsFromName('sdasfasfasdf')\n  except ImportError as e:\n   self.assertEqual(str(e),\"No module named 'sdasfasfasdf'\")\n  else:\n   self.fail(\"TestLoader.loadTestsFromName failed to raise ImportError\")\n def test_loadTestsFromName__unknown_attr_name(self):\n  loader=unittest.TestLoader()\n  try:\n   loader.loadTestsFromName('unittest.sdasfasfasdf')\n  except AttributeError as e:\n   self.assertEqual(str(e),\"'module' object has no attribute 'sdasfasfasdf'\")\n  else:\n   self.fail(\"TestLoader.loadTestsFromName failed to raise AttributeError\")\n def test_loadTestsFromName__relative_unknown_name(self):\n  loader=unittest.TestLoader()\n  try:\n   loader.loadTestsFromName('sdasfasfasdf',unittest)\n  except AttributeError as e:\n   self.assertEqual(str(e),\"'module' object has no attribute 'sdasfasfasdf'\")\n  else:\n   self.fail(\"TestLoader.loadTestsFromName failed to raise AttributeError\")\n def test_loadTestsFromName__relative_empty_name(self):\n  loader=unittest.TestLoader()\n  try:\n   loader.loadTestsFromName('',unittest)\n  except AttributeError as e:\n   pass\n  else:\n   self.fail(\"Failed to raise AttributeError\")\n def test_loadTestsFromName__relative_malformed_name(self):\n  loader=unittest.TestLoader()\n  try:\n   loader.loadTestsFromName('abc () //',unittest)\n  except ValueError:\n   pass\n  except AttributeError:\n   pass\n  else:\n   self.fail(\"TestLoader.loadTestsFromName failed to raise ValueError\")\n def test_loadTestsFromName__relative_not_a_module(self):\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  class NotAModule(object):\n   test_2=MyTestCase\n  loader=unittest.TestLoader()\n  suite=loader.loadTestsFromName('test_2',NotAModule)\n  reference=[MyTestCase('test')]\n  self.assertEqual(list(suite),reference)\n def test_loadTestsFromName__relative_bad_object(self):\n  m=types.ModuleType('m')\n  m.testcase_1=object()\n  loader=unittest.TestLoader()\n  try:\n   loader.loadTestsFromName('testcase_1',m)\n  except TypeError:\n   pass\n  else:\n   self.fail(\"Should have raised TypeError\")\n def test_loadTestsFromName__relative_TestCase_subclass(self):\n  m=types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testcase_1=MyTestCase\n  loader=unittest.TestLoader()\n  suite=loader.loadTestsFromName('testcase_1',m)\n  self.assertIsInstance(suite,loader.suiteClass)\n  self.assertEqual(list(suite),[MyTestCase('test')])\n def test_loadTestsFromName__relative_TestSuite(self):\n  m=types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testsuite=unittest.TestSuite([MyTestCase('test')])\n  loader=unittest.TestLoader()\n  suite=loader.loadTestsFromName('testsuite',m)\n  self.assertIsInstance(suite,loader.suiteClass)\n  self.assertEqual(list(suite),[MyTestCase('test')])\n def test_loadTestsFromName__relative_testmethod(self):\n  m=types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testcase_1=MyTestCase\n  loader=unittest.TestLoader()\n  suite=loader.loadTestsFromName('testcase_1.test',m)\n  self.assertIsInstance(suite,loader.suiteClass)\n  self.assertEqual(list(suite),[MyTestCase('test')])\n def test_loadTestsFromName__relative_invalid_testmethod(self):\n  m=types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testcase_1=MyTestCase\n  loader=unittest.TestLoader()\n  try:\n   loader.loadTestsFromName('testcase_1.testfoo',m)\n  except AttributeError as e:\n   self.assertEqual(str(e),\"type object 'MyTestCase' has no attribute 'testfoo'\")\n  else:\n   self.fail(\"Failed to raise AttributeError\")\n def test_loadTestsFromName__callable__TestSuite(self):\n  m=types.ModuleType('m')\n  testcase_1=unittest.FunctionTestCase(lambda:None)\n  testcase_2=unittest.FunctionTestCase(lambda:None)\n  def return_TestSuite():\n   return unittest.TestSuite([testcase_1,testcase_2])\n  m.return_TestSuite=return_TestSuite\n  loader=unittest.TestLoader()\n  suite=loader.loadTestsFromName('return_TestSuite',m)\n  self.assertIsInstance(suite,loader.suiteClass)\n  self.assertEqual(list(suite),[testcase_1,testcase_2])\n def test_loadTestsFromName__callable__TestCase_instance(self):\n  m=types.ModuleType('m')\n  testcase_1=unittest.FunctionTestCase(lambda:None)\n  def return_TestCase():\n   return testcase_1\n  m.return_TestCase=return_TestCase\n  loader=unittest.TestLoader()\n  suite=loader.loadTestsFromName('return_TestCase',m)\n  self.assertIsInstance(suite,loader.suiteClass)\n  self.assertEqual(list(suite),[testcase_1])\n def test_loadTestsFromName__callable__TestCase_instance_ProperSuiteClass(self):\n  class SubTestSuite(unittest.TestSuite):\n   pass\n  m=types.ModuleType('m')\n  testcase_1=unittest.FunctionTestCase(lambda:None)\n  def return_TestCase():\n   return testcase_1\n  m.return_TestCase=return_TestCase\n  loader=unittest.TestLoader()\n  loader.suiteClass=SubTestSuite\n  suite=loader.loadTestsFromName('return_TestCase',m)\n  self.assertIsInstance(suite,loader.suiteClass)\n  self.assertEqual(list(suite),[testcase_1])\n def test_loadTestsFromName__relative_testmethod_ProperSuiteClass(self):\n  class SubTestSuite(unittest.TestSuite):\n   pass\n  m=types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testcase_1=MyTestCase\n  loader=unittest.TestLoader()\n  loader.suiteClass=SubTestSuite\n  suite=loader.loadTestsFromName('testcase_1.test',m)\n  self.assertIsInstance(suite,loader.suiteClass)\n  self.assertEqual(list(suite),[MyTestCase('test')])\n def test_loadTestsFromName__callable__wrong_type(self):\n  m=types.ModuleType('m')\n  def return_wrong():\n   return 6\n  m.return_wrong=return_wrong\n  loader=unittest.TestLoader()\n  try:\n   suite=loader.loadTestsFromName('return_wrong',m)\n  except TypeError:\n   pass\n  else:\n   self.fail(\"TestLoader.loadTestsFromName failed to raise TypeError\")\n def test_loadTestsFromName__module_not_loaded(self):\n  module_name='unittest.test.dummy'\n  sys.modules.pop(module_name,None)\n  loader=unittest.TestLoader()\n  try:\n   suite=loader.loadTestsFromName(module_name)\n   self.assertIsInstance(suite,loader.suiteClass)\n   self.assertEqual(list(suite),[])\n   self.assertIn(module_name,sys.modules)\n  finally:\n   if module_name in sys.modules:\n    del sys.modules[module_name]\n def test_loadTestsFromNames__empty_name_list(self):\n  loader=unittest.TestLoader()\n  suite=loader.loadTestsFromNames([])\n  self.assertIsInstance(suite,loader.suiteClass)\n  self.assertEqual(list(suite),[])\n def test_loadTestsFromNames__relative_empty_name_list(self):\n  loader=unittest.TestLoader()\n  suite=loader.loadTestsFromNames([],unittest)\n  self.assertIsInstance(suite,loader.suiteClass)\n  self.assertEqual(list(suite),[])\n def test_loadTestsFromNames__empty_name(self):\n  loader=unittest.TestLoader()\n  try:\n   loader.loadTestsFromNames([''])\n  except ValueError as e:\n   self.assertEqual(str(e),\"Empty module name\")\n  else:\n   self.fail(\"TestLoader.loadTestsFromNames failed to raise ValueError\")\n def test_loadTestsFromNames__malformed_name(self):\n  loader=unittest.TestLoader()\n  try:\n   loader.loadTestsFromNames(['abc () //'])\n  except ValueError:\n   pass\n  except ImportError:\n   pass\n  else:\n   self.fail(\"TestLoader.loadTestsFromNames failed to raise ValueError\")\n def test_loadTestsFromNames__unknown_module_name(self):\n  loader=unittest.TestLoader()\n  try:\n   loader.loadTestsFromNames(['sdasfasfasdf'])\n  except ImportError as e:\n   self.assertEqual(str(e),\"No module named 'sdasfasfasdf'\")\n  else:\n   self.fail(\"TestLoader.loadTestsFromNames failed to raise ImportError\")\n def test_loadTestsFromNames__unknown_attr_name(self):\n  loader=unittest.TestLoader()\n  try:\n   loader.loadTestsFromNames(['unittest.sdasfasfasdf','unittest'])\n  except AttributeError as e:\n   self.assertEqual(str(e),\"'module' object has no attribute 'sdasfasfasdf'\")\n  else:\n   self.fail(\"TestLoader.loadTestsFromNames failed to raise AttributeError\")\n def test_loadTestsFromNames__unknown_name_relative_1(self):\n  loader=unittest.TestLoader()\n  try:\n   loader.loadTestsFromNames(['sdasfasfasdf'],unittest)\n  except AttributeError as e:\n   self.assertEqual(str(e),\"'module' object has no attribute 'sdasfasfasdf'\")\n  else:\n   self.fail(\"TestLoader.loadTestsFromName failed to raise AttributeError\")\n def test_loadTestsFromNames__unknown_name_relative_2(self):\n  loader=unittest.TestLoader()\n  try:\n   loader.loadTestsFromNames(['TestCase','sdasfasfasdf'],unittest)\n  except AttributeError as e:\n   self.assertEqual(str(e),\"'module' object has no attribute 'sdasfasfasdf'\")\n  else:\n   self.fail(\"TestLoader.loadTestsFromName failed to raise AttributeError\")\n def test_loadTestsFromNames__relative_empty_name(self):\n  loader=unittest.TestLoader()\n  try:\n   loader.loadTestsFromNames([''],unittest)\n  except AttributeError:\n   pass\n  else:\n   self.fail(\"Failed to raise ValueError\")\n def test_loadTestsFromNames__relative_malformed_name(self):\n  loader=unittest.TestLoader()\n  try:\n   loader.loadTestsFromNames(['abc () //'],unittest)\n  except AttributeError:\n   pass\n  except ValueError:\n   pass\n  else:\n   self.fail(\"TestLoader.loadTestsFromNames failed to raise ValueError\")\n def test_loadTestsFromNames__relative_not_a_module(self):\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  class NotAModule(object):\n   test_2=MyTestCase\n  loader=unittest.TestLoader()\n  suite=loader.loadTestsFromNames(['test_2'],NotAModule)\n  reference=[unittest.TestSuite([MyTestCase('test')])]\n  self.assertEqual(list(suite),reference)\n def test_loadTestsFromNames__relative_bad_object(self):\n  m=types.ModuleType('m')\n  m.testcase_1=object()\n  loader=unittest.TestLoader()\n  try:\n   loader.loadTestsFromNames(['testcase_1'],m)\n  except TypeError:\n   pass\n  else:\n   self.fail(\"Should have raised TypeError\")\n def test_loadTestsFromNames__relative_TestCase_subclass(self):\n  m=types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testcase_1=MyTestCase\n  loader=unittest.TestLoader()\n  suite=loader.loadTestsFromNames(['testcase_1'],m)\n  self.assertIsInstance(suite,loader.suiteClass)\n  expected=loader.suiteClass([MyTestCase('test')])\n  self.assertEqual(list(suite),[expected])\n def test_loadTestsFromNames__relative_TestSuite(self):\n  m=types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testsuite=unittest.TestSuite([MyTestCase('test')])\n  loader=unittest.TestLoader()\n  suite=loader.loadTestsFromNames(['testsuite'],m)\n  self.assertIsInstance(suite,loader.suiteClass)\n  self.assertEqual(list(suite),[m.testsuite])\n def test_loadTestsFromNames__relative_testmethod(self):\n  m=types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testcase_1=MyTestCase\n  loader=unittest.TestLoader()\n  suite=loader.loadTestsFromNames(['testcase_1.test'],m)\n  self.assertIsInstance(suite,loader.suiteClass)\n  ref_suite=unittest.TestSuite([MyTestCase('test')])\n  self.assertEqual(list(suite),[ref_suite])\n def test_loadTestsFromNames__relative_invalid_testmethod(self):\n  m=types.ModuleType('m')\n  class MyTestCase(unittest.TestCase):\n   def test(self):\n    pass\n  m.testcase_1=MyTestCase\n  loader=unittest.TestLoader()\n  try:\n   loader.loadTestsFromNames(['testcase_1.testfoo'],m)\n  except AttributeError as e:\n   self.assertEqual(str(e),\"type object 'MyTestCase' has no attribute 'testfoo'\")\n  else:\n   self.fail(\"Failed to raise AttributeError\")\n def test_loadTestsFromNames__callable__TestSuite(self):\n  m=types.ModuleType('m')\n  testcase_1=unittest.FunctionTestCase(lambda:None)\n  testcase_2=unittest.FunctionTestCase(lambda:None)\n  def return_TestSuite():\n   return unittest.TestSuite([testcase_1,testcase_2])\n  m.return_TestSuite=return_TestSuite\n  loader=unittest.TestLoader()\n  suite=loader.loadTestsFromNames(['return_TestSuite'],m)\n  self.assertIsInstance(suite,loader.suiteClass)\n  expected=unittest.TestSuite([testcase_1,testcase_2])\n  self.assertEqual(list(suite),[expected])\n def test_loadTestsFromNames__callable__TestCase_instance(self):\n  m=types.ModuleType('m')\n  testcase_1=unittest.FunctionTestCase(lambda:None)\n  def return_TestCase():\n   return testcase_1\n  m.return_TestCase=return_TestCase\n  loader=unittest.TestLoader()\n  suite=loader.loadTestsFromNames(['return_TestCase'],m)\n  self.assertIsInstance(suite,loader.suiteClass)\n  ref_suite=unittest.TestSuite([testcase_1])\n  self.assertEqual(list(suite),[ref_suite])\n def test_loadTestsFromNames__callable__call_staticmethod(self):\n  m=types.ModuleType('m')\n  class Test1(unittest.TestCase):\n   def test(self):\n    pass\n  testcase_1=Test1('test')\n  class Foo(unittest.TestCase):\n   @staticmethod\n   def foo():\n    return testcase_1\n  m.Foo=Foo\n  loader=unittest.TestLoader()\n  suite=loader.loadTestsFromNames(['Foo.foo'],m)\n  self.assertIsInstance(suite,loader.suiteClass)\n  ref_suite=unittest.TestSuite([testcase_1])\n  self.assertEqual(list(suite),[ref_suite])\n def test_loadTestsFromNames__callable__wrong_type(self):\n  m=types.ModuleType('m')\n  def return_wrong():\n   return 6\n  m.return_wrong=return_wrong\n  loader=unittest.TestLoader()\n  try:\n   suite=loader.loadTestsFromNames(['return_wrong'],m)\n  except TypeError:\n   pass\n  else:\n   self.fail(\"TestLoader.loadTestsFromNames failed to raise TypeError\")\n def test_loadTestsFromNames__module_not_loaded(self):\n  module_name='unittest.test.dummy'\n  sys.modules.pop(module_name,None)\n  loader=unittest.TestLoader()\n  try:\n   suite=loader.loadTestsFromNames([module_name])\n   self.assertIsInstance(suite,loader.suiteClass)\n   self.assertEqual(list(suite),[unittest.TestSuite()])\n   self.assertIn(module_name,sys.modules)\n  finally:\n   if module_name in sys.modules:\n    del sys.modules[module_name]\n def test_getTestCaseNames(self):\n  class Test(unittest.TestCase):\n   def test_1(self):pass\n   def test_2(self):pass\n   def foobar(self):pass\n  loader=unittest.TestLoader()\n  self.assertEqual(loader.getTestCaseNames(Test),['test_1','test_2'])\n def test_getTestCaseNames__no_tests(self):\n  class Test(unittest.TestCase):\n   def foobar(self):pass\n  loader=unittest.TestLoader()\n  self.assertEqual(loader.getTestCaseNames(Test),[])\n def test_getTestCaseNames__not_a_TestCase(self):\n  class BadCase(int):\n   def test_foo(self):\n    pass\n  loader=unittest.TestLoader()\n  names=loader.getTestCaseNames(BadCase)\n  self.assertEqual(names,['test_foo'])\n def test_getTestCaseNames__inheritance(self):\n  class TestP(unittest.TestCase):\n   def test_1(self):pass\n   def test_2(self):pass\n   def foobar(self):pass\n  class TestC(TestP):\n   def test_1(self):pass\n   def test_3(self):pass\n  loader=unittest.TestLoader()\n  names=['test_1','test_2','test_3']\n  self.assertEqual(loader.getTestCaseNames(TestC),names)\n def test_testMethodPrefix__loadTestsFromTestCase(self):\n  class Foo(unittest.TestCase):\n   def test_1(self):pass\n   def test_2(self):pass\n   def foo_bar(self):pass\n  tests_1=unittest.TestSuite([Foo('foo_bar')])\n  tests_2=unittest.TestSuite([Foo('test_1'),Foo('test_2')])\n  loader=unittest.TestLoader()\n  loader.testMethodPrefix='foo'\n  self.assertEqual(loader.loadTestsFromTestCase(Foo),tests_1)\n  loader.testMethodPrefix='test'\n  self.assertEqual(loader.loadTestsFromTestCase(Foo),tests_2)\n def test_testMethodPrefix__loadTestsFromModule(self):\n  m=types.ModuleType('m')\n  class Foo(unittest.TestCase):\n   def test_1(self):pass\n   def test_2(self):pass\n   def foo_bar(self):pass\n  m.Foo=Foo\n  tests_1=[unittest.TestSuite([Foo('foo_bar')])]\n  tests_2=[unittest.TestSuite([Foo('test_1'),Foo('test_2')])]\n  loader=unittest.TestLoader()\n  loader.testMethodPrefix='foo'\n  self.assertEqual(list(loader.loadTestsFromModule(m)),tests_1)\n  loader.testMethodPrefix='test'\n  self.assertEqual(list(loader.loadTestsFromModule(m)),tests_2)\n def test_testMethodPrefix__loadTestsFromName(self):\n  m=types.ModuleType('m')\n  class Foo(unittest.TestCase):\n   def test_1(self):pass\n   def test_2(self):pass\n   def foo_bar(self):pass\n  m.Foo=Foo\n  tests_1=unittest.TestSuite([Foo('foo_bar')])\n  tests_2=unittest.TestSuite([Foo('test_1'),Foo('test_2')])\n  loader=unittest.TestLoader()\n  loader.testMethodPrefix='foo'\n  self.assertEqual(loader.loadTestsFromName('Foo',m),tests_1)\n  loader.testMethodPrefix='test'\n  self.assertEqual(loader.loadTestsFromName('Foo',m),tests_2)\n def test_testMethodPrefix__loadTestsFromNames(self):\n  m=types.ModuleType('m')\n  class Foo(unittest.TestCase):\n   def test_1(self):pass\n   def test_2(self):pass\n   def foo_bar(self):pass\n  m.Foo=Foo\n  tests_1=unittest.TestSuite([unittest.TestSuite([Foo('foo_bar')])])\n  tests_2=unittest.TestSuite([Foo('test_1'),Foo('test_2')])\n  tests_2=unittest.TestSuite([tests_2])\n  loader=unittest.TestLoader()\n  loader.testMethodPrefix='foo'\n  self.assertEqual(loader.loadTestsFromNames(['Foo'],m),tests_1)\n  loader.testMethodPrefix='test'\n  self.assertEqual(loader.loadTestsFromNames(['Foo'],m),tests_2)\n def test_testMethodPrefix__default_value(self):\n  loader=unittest.TestLoader()\n  self.assertEqual(loader.testMethodPrefix,'test')\n def test_sortTestMethodsUsing__loadTestsFromTestCase(self):\n  def reversed_cmp(x,y):\n   return-((x>y)-(x<y))\n  class Foo(unittest.TestCase):\n   def test_1(self):pass\n   def test_2(self):pass\n  loader=unittest.TestLoader()\n  loader.sortTestMethodsUsing=reversed_cmp\n  tests=loader.suiteClass([Foo('test_2'),Foo('test_1')])\n  self.assertEqual(loader.loadTestsFromTestCase(Foo),tests)\n def test_sortTestMethodsUsing__loadTestsFromModule(self):\n  def reversed_cmp(x,y):\n   return-((x>y)-(x<y))\n  m=types.ModuleType('m')\n  class Foo(unittest.TestCase):\n   def test_1(self):pass\n   def test_2(self):pass\n  m.Foo=Foo\n  loader=unittest.TestLoader()\n  loader.sortTestMethodsUsing=reversed_cmp\n  tests=[loader.suiteClass([Foo('test_2'),Foo('test_1')])]\n  self.assertEqual(list(loader.loadTestsFromModule(m)),tests)\n def test_sortTestMethodsUsing__loadTestsFromName(self):\n  def reversed_cmp(x,y):\n   return-((x>y)-(x<y))\n  m=types.ModuleType('m')\n  class Foo(unittest.TestCase):\n   def test_1(self):pass\n   def test_2(self):pass\n  m.Foo=Foo\n  loader=unittest.TestLoader()\n  loader.sortTestMethodsUsing=reversed_cmp\n  tests=loader.suiteClass([Foo('test_2'),Foo('test_1')])\n  self.assertEqual(loader.loadTestsFromName('Foo',m),tests)\n def test_sortTestMethodsUsing__loadTestsFromNames(self):\n  def reversed_cmp(x,y):\n   return-((x>y)-(x<y))\n  m=types.ModuleType('m')\n  class Foo(unittest.TestCase):\n   def test_1(self):pass\n   def test_2(self):pass\n  m.Foo=Foo\n  loader=unittest.TestLoader()\n  loader.sortTestMethodsUsing=reversed_cmp\n  tests=[loader.suiteClass([Foo('test_2'),Foo('test_1')])]\n  self.assertEqual(list(loader.loadTestsFromNames(['Foo'],m)),tests)\n def test_sortTestMethodsUsing__getTestCaseNames(self):\n  def reversed_cmp(x,y):\n   return-((x>y)-(x<y))\n  class Foo(unittest.TestCase):\n   def test_1(self):pass\n   def test_2(self):pass\n  loader=unittest.TestLoader()\n  loader.sortTestMethodsUsing=reversed_cmp\n  test_names=['test_2','test_1']\n  self.assertEqual(loader.getTestCaseNames(Foo),test_names)\n def test_sortTestMethodsUsing__default_value(self):\n  loader=unittest.TestLoader()\n  class Foo(unittest.TestCase):\n   def test_2(self):pass\n   def test_3(self):pass\n   def test_1(self):pass\n  test_names=['test_2','test_3','test_1']\n  self.assertEqual(loader.getTestCaseNames(Foo),sorted(test_names))\n def test_sortTestMethodsUsing__None(self):\n  class Foo(unittest.TestCase):\n   def test_1(self):pass\n   def test_2(self):pass\n  loader=unittest.TestLoader()\n  loader.sortTestMethodsUsing=None\n  test_names=['test_2','test_1']\n  self.assertEqual(set(loader.getTestCaseNames(Foo)),set(test_names))\n def test_suiteClass__loadTestsFromTestCase(self):\n  class Foo(unittest.TestCase):\n   def test_1(self):pass\n   def test_2(self):pass\n   def foo_bar(self):pass\n  tests=[Foo('test_1'),Foo('test_2')]\n  loader=unittest.TestLoader()\n  loader.suiteClass=list\n  self.assertEqual(loader.loadTestsFromTestCase(Foo),tests)\n def test_suiteClass__loadTestsFromModule(self):\n  m=types.ModuleType('m')\n  class Foo(unittest.TestCase):\n   def test_1(self):pass\n   def test_2(self):pass\n   def foo_bar(self):pass\n  m.Foo=Foo\n  tests=[[Foo('test_1'),Foo('test_2')]]\n  loader=unittest.TestLoader()\n  loader.suiteClass=list\n  self.assertEqual(loader.loadTestsFromModule(m),tests)\n def test_suiteClass__loadTestsFromName(self):\n  m=types.ModuleType('m')\n  class Foo(unittest.TestCase):\n   def test_1(self):pass\n   def test_2(self):pass\n   def foo_bar(self):pass\n  m.Foo=Foo\n  tests=[Foo('test_1'),Foo('test_2')]\n  loader=unittest.TestLoader()\n  loader.suiteClass=list\n  self.assertEqual(loader.loadTestsFromName('Foo',m),tests)\n def test_suiteClass__loadTestsFromNames(self):\n  m=types.ModuleType('m')\n  class Foo(unittest.TestCase):\n   def test_1(self):pass\n   def test_2(self):pass\n   def foo_bar(self):pass\n  m.Foo=Foo\n  tests=[[Foo('test_1'),Foo('test_2')]]\n  loader=unittest.TestLoader()\n  loader.suiteClass=list\n  self.assertEqual(loader.loadTestsFromNames(['Foo'],m),tests)\n def test_suiteClass__default_value(self):\n  loader=unittest.TestLoader()\n  self.assertTrue(loader.suiteClass is unittest.TestSuite)\n"], "unittest.test._test_warnings": ["\n\"\"\"\nThis module has a number of tests that raise different kinds of warnings.\nWhen the tests are run, the warnings are caught and their messages are printed\nto stdout.  This module also accepts an arg that is then passed to\nunittest.main to affect the behavior of warnings.\nTest_TextTestRunner.test_warnings executes this script with different\ncombinations of warnings args and -W flags and check that the output is correct.\nSee #10535.\n\"\"\"\nimport sys\nimport unittest\nimport warnings\ndef warnfun():\n warnings.warn('rw',RuntimeWarning)\nclass TestWarnings(unittest.TestCase):\n def test_assert(self):\n  self.assertEquals(2+2,4)\n  self.assertEquals(2*2,4)\n  self.assertEquals(2**2,4)\n def test_fail(self):\n  self.failUnless(1)\n  self.failUnless(True)\n def test_other_unittest(self):\n  self.assertAlmostEqual(2+2,4)\n  self.assertNotAlmostEqual(4+4,2)\n def test_deprecation(self):\n  warnings.warn('dw',DeprecationWarning)\n  warnings.warn('dw',DeprecationWarning)\n  warnings.warn('dw',DeprecationWarning)\n def test_import(self):\n  warnings.warn('iw',ImportWarning)\n  warnings.warn('iw',ImportWarning)\n  warnings.warn('iw',ImportWarning)\n def test_warning(self):\n  warnings.warn('uw')\n  warnings.warn('uw')\n  warnings.warn('uw')\n def test_function(self):\n  warnfun()\n  warnfun()\n  warnfun()\nif __name__=='__main__':\n with warnings.catch_warnings(record=True)as ws:\n  if len(sys.argv)==2:\n   unittest.main(exit=False,warnings=sys.argv.pop())\n  else:\n   unittest.main(exit=False)\n for w in ws:\n  print(w.message)\n"], "unittest.mock": ["\n__all__=(\n'Mock',\n'MagicMock',\n'patch',\n'sentinel',\n'DEFAULT',\n'ANY',\n'call',\n'create_autospec',\n'FILTER_DIR',\n'NonCallableMock',\n'NonCallableMagicMock',\n'mock_open',\n'PropertyMock',\n)\n__version__='1.0'\nimport inspect\nimport pprint\nimport sys\nfrom functools import wraps\nBaseExceptions=(BaseException,)\nif'java'in sys.platform:\n import java\n BaseExceptions=(BaseException,java.lang.Throwable)\nFILTER_DIR=True\n_safe_super=super\ndef _is_instance_mock(obj):\n return issubclass(type(obj),NonCallableMock)\ndef _is_exception(obj):\n return(\n isinstance(obj,BaseExceptions)or\n isinstance(obj,type)and issubclass(obj,BaseExceptions)\n )\nclass _slotted(object):\n __slots__=['a']\nDescriptorTypes=(\ntype(_slotted.a),\nproperty,\n)\ndef _getsignature(func,skipfirst,instance=False):\n if isinstance(func,type)and not instance:\n  try:\n   func=func.__init__\n  except AttributeError:\n   return\n  skipfirst=True\n elif not isinstance(func,FunctionTypes):\n  try:\n   func=func.__call__\n  except AttributeError:\n   return\n try:\n  argspec=inspect.getfullargspec(func)\n except TypeError:\n  return\n regargs,varargs,varkw,defaults,kwonly,kwonlydef,ann=argspec\n if getattr(func,'__self__',None)is not None:\n  regargs=regargs[1:]\n if skipfirst:\n  regargs=regargs[1:]\n signature=inspect.formatargspec(\n regargs,varargs,varkw,defaults,\n kwonly,kwonlydef,ann,formatvalue=lambda value:\"\")\n return signature[1:-1],func\ndef _check_signature(func,mock,skipfirst,instance=False):\n if not _callable(func):\n  return\n result=_getsignature(func,skipfirst,instance)\n if result is None:\n  return\n signature,func=result\n src=\"lambda _mock_self, %s: None\"%signature\n checksig=eval(src,{})\n _copy_func_details(func,checksig)\n type(mock)._mock_check_sig=checksig\ndef _copy_func_details(func,funcopy):\n funcopy.__name__=func.__name__\n funcopy.__doc__=func.__doc__\n funcopy.__module__=func.__module__\n funcopy.__defaults__=func.__defaults__\n funcopy.__kwdefaults__=func.__kwdefaults__\ndef _callable(obj):\n if isinstance(obj,type):\n  return True\n if getattr(obj,'__call__',None)is not None:\n  return True\n return False\ndef _is_list(obj):\n return type(obj)in(list,tuple)\ndef _instance_callable(obj):\n '' \n if not isinstance(obj,type):\n  return getattr(obj,'__call__',None)is not None\n for base in(obj,)+obj.__mro__:\n  if base.__dict__.get('__call__')is not None:\n   return True\n return False\ndef _set_signature(mock,original,instance=False):\n if not _callable(original):\n  return\n skipfirst=isinstance(original,type)\n result=_getsignature(original,skipfirst,instance)\n if result is None:\n  return\n signature,func=result\n src=\"lambda %s: None\"%signature\n checksig=eval(src,{})\n _copy_func_details(func,checksig)\n name=original.__name__\n if not name.isidentifier():\n  name='funcopy'\n context={'_checksig_':checksig,'mock':mock}\n src=\"\"\"def %s(*args, **kwargs):\n    _checksig_(*args, **kwargs)\n    return mock(*args, **kwargs)\"\"\"%name\n exec(src,context)\n funcopy=context[name]\n _setup_func(funcopy,mock)\n return funcopy\ndef _setup_func(funcopy,mock):\n funcopy.mock=mock\n if not _is_instance_mock(mock):\n  return\n def assert_called_with(*args,**kwargs):\n  return mock.assert_called_with(*args,**kwargs)\n def assert_called_once_with(*args,**kwargs):\n  return mock.assert_called_once_with(*args,**kwargs)\n def assert_has_calls(*args,**kwargs):\n  return mock.assert_has_calls(*args,**kwargs)\n def assert_any_call(*args,**kwargs):\n  return mock.assert_any_call(*args,**kwargs)\n def reset_mock():\n  funcopy.method_calls=_CallList()\n  funcopy.mock_calls=_CallList()\n  mock.reset_mock()\n  ret=funcopy.return_value\n  if _is_instance_mock(ret)and not ret is mock:\n   ret.reset_mock()\n funcopy.called=False\n funcopy.call_count=0\n funcopy.call_args=None\n funcopy.call_args_list=_CallList()\n funcopy.method_calls=_CallList()\n funcopy.mock_calls=_CallList()\n funcopy.return_value=mock.return_value\n funcopy.side_effect=mock.side_effect\n funcopy._mock_children=mock._mock_children\n funcopy.assert_called_with=assert_called_with\n funcopy.assert_called_once_with=assert_called_once_with\n funcopy.assert_has_calls=assert_has_calls\n funcopy.assert_any_call=assert_any_call\n funcopy.reset_mock=reset_mock\n mock._mock_delegate=funcopy\ndef _is_magic(name):\n return'__%s__'%name[2:-2]==name\nclass _SentinelObject(object):\n def __init__(self,name):\n  self.name=name\n def __repr__(self):\n  return'sentinel.%s'%self.name\nclass _Sentinel(object):\n def __init__(self):\n  self._sentinels={}\n def __getattr__(self,name):\n  if name=='__bases__':\n   raise AttributeError\n  return self._sentinels.setdefault(name,_SentinelObject(name))\nsentinel=_Sentinel()\nDEFAULT=sentinel.DEFAULT\n_missing=sentinel.MISSING\n_deleted=sentinel.DELETED\ndef _copy(value):\n if type(value)in(dict,list,tuple,set):\n  return type(value)(value)\n return value\n_allowed_names=set(\n[\n'return_value','_mock_return_value','side_effect',\n'_mock_side_effect','_mock_parent','_mock_new_parent',\n'_mock_name','_mock_new_name'\n]\n)\ndef _delegating_property(name):\n _allowed_names.add(name)\n _the_name='_mock_'+name\n def _get(self,name=name,_the_name=_the_name):\n  sig=self._mock_delegate\n  if sig is None:\n   return getattr(self,_the_name)\n  return getattr(sig,name)\n def _set(self,value,name=name,_the_name=_the_name):\n  sig=self._mock_delegate\n  if sig is None:\n   self.__dict__[_the_name]=value\n  else:\n   setattr(sig,name,value)\n return property(_get,_set)\nclass _CallList(list):\n def __contains__(self,value):\n  if not isinstance(value,list):\n   return list.__contains__(self,value)\n  len_value=len(value)\n  len_self=len(self)\n  if len_value>len_self:\n   return False\n  for i in range(0,len_self-len_value+1):\n   sub_list=self[i:i+len_value]\n   if sub_list==value:\n    return True\n  return False\n def __repr__(self):\n  return pprint.pformat(list(self))\ndef _check_and_set_parent(parent,value,name,new_name):\n if not _is_instance_mock(value):\n  return False\n if((value._mock_name or value._mock_new_name)or\n (value._mock_parent is not None)or\n (value._mock_new_parent is not None)):\n  return False\n _parent=parent\n while _parent is not None:\n  if _parent is value:\n   return False\n  _parent=_parent._mock_new_parent\n if new_name:\n  value._mock_new_parent=parent\n  value._mock_new_name=new_name\n if name:\n  value._mock_parent=parent\n  value._mock_name=name\n return True\nclass Base(object):\n _mock_return_value=DEFAULT\n _mock_side_effect=None\n def __init__(self,*args,**kwargs):\n  pass\nclass NonCallableMock(Base):\n def __new__(cls,*args,**kw):\n  new=type(cls.__name__,(cls,),{'__doc__':cls.__doc__})\n  instance=object.__new__(new)\n  return instance\n def __init__(\n self,spec=None,wraps=None,name=None,spec_set=None,\n parent=None,_spec_state=None,_new_name='',_new_parent=None,\n **kwargs\n ):\n  if _new_parent is None:\n   _new_parent=parent\n  __dict__=self.__dict__\n  __dict__['_mock_parent']=parent\n  __dict__['_mock_name']=name\n  __dict__['_mock_new_name']=_new_name\n  __dict__['_mock_new_parent']=_new_parent\n  if spec_set is not None:\n   spec=spec_set\n   spec_set=True\n  self._mock_add_spec(spec,spec_set)\n  __dict__['_mock_children']={}\n  __dict__['_mock_wraps']=wraps\n  __dict__['_mock_delegate']=None\n  __dict__['_mock_called']=False\n  __dict__['_mock_call_args']=None\n  __dict__['_mock_call_count']=0\n  __dict__['_mock_call_args_list']=_CallList()\n  __dict__['_mock_mock_calls']=_CallList()\n  __dict__['method_calls']=_CallList()\n  if kwargs:\n   self.configure_mock(**kwargs)\n  _safe_super(NonCallableMock,self).__init__(\n  spec,wraps,name,spec_set,parent,\n  _spec_state\n  )\n def attach_mock(self,mock,attribute):\n  ''  \n  mock._mock_parent=None\n  mock._mock_new_parent=None\n  mock._mock_name=''\n  mock._mock_new_name=None\n  setattr(self,attribute,mock)\n def mock_add_spec(self,spec,spec_set=False):\n  ''  \n  self._mock_add_spec(spec,spec_set)\n def _mock_add_spec(self,spec,spec_set):\n  _spec_class=None\n  if spec is not None and not _is_list(spec):\n   if isinstance(spec,type):\n    _spec_class=spec\n   else:\n    _spec_class=_get_class(spec)\n   spec=dir(spec)\n  __dict__=self.__dict__\n  __dict__['_spec_class']=_spec_class\n  __dict__['_spec_set']=spec_set\n  __dict__['_mock_methods']=spec\n def __get_return_value(self):\n  ret=self._mock_return_value\n  if self._mock_delegate is not None:\n   ret=self._mock_delegate.return_value\n  if ret is DEFAULT:\n   ret=self._get_child_mock(\n   _new_parent=self,_new_name='()'\n   )\n   self.return_value=ret\n  return ret\n def __set_return_value(self,value):\n  if self._mock_delegate is not None:\n   self._mock_delegate.return_value=value\n  else:\n   self._mock_return_value=value\n   _check_and_set_parent(self,value,None,'()')\n __return_value_doc=\"The value to be returned when the mock is called.\"\n return_value=property(__get_return_value,__set_return_value,\n __return_value_doc)\n @property\n def __class__(self):\n  if self._spec_class is None:\n   return type(self)\n  return self._spec_class\n called=_delegating_property('called')\n call_count=_delegating_property('call_count')\n call_args=_delegating_property('call_args')\n call_args_list=_delegating_property('call_args_list')\n mock_calls=_delegating_property('mock_calls')\n def __get_side_effect(self):\n  delegated=self._mock_delegate\n  if delegated is None:\n   return self._mock_side_effect\n  return delegated.side_effect\n def __set_side_effect(self,value):\n  value=_try_iter(value)\n  delegated=self._mock_delegate\n  if delegated is None:\n   self._mock_side_effect=value\n  else:\n   delegated.side_effect=value\n side_effect=property(__get_side_effect,__set_side_effect)\n def reset_mock(self):\n  self.called=False\n  self.call_args=None\n  self.call_count=0\n  self.mock_calls=_CallList()\n  self.call_args_list=_CallList()\n  self.method_calls=_CallList()\n  for child in self._mock_children.values():\n   if isinstance(child,_SpecState):\n    continue\n   child.reset_mock()\n  ret=self._mock_return_value\n  if _is_instance_mock(ret)and ret is not self:\n   ret.reset_mock()\n def configure_mock(self,**kwargs):\n  ''  \n  for arg,val in sorted(kwargs.items(),\n  key=lambda entry:entry[0].count('.')):\n   args=arg.split('.')\n   final=args.pop()\n   obj=self\n   for entry in args:\n    obj=getattr(obj,entry)\n   setattr(obj,final,val)\n def __getattr__(self,name):\n  if name=='_mock_methods':\n   raise AttributeError(name)\n  elif self._mock_methods is not None:\n   if name not in self._mock_methods or name in _all_magics:\n    raise AttributeError(\"Mock object has no attribute %r\"%name)\n  elif _is_magic(name):\n   raise AttributeError(name)\n  result=self._mock_children.get(name)\n  if result is _deleted:\n   raise AttributeError(name)\n  elif result is None:\n   wraps=None\n   if self._mock_wraps is not None:\n    wraps=getattr(self._mock_wraps,name)\n   result=self._get_child_mock(\n   parent=self,name=name,wraps=wraps,_new_name=name,\n   _new_parent=self\n   )\n   self._mock_children[name]=result\n  elif isinstance(result,_SpecState):\n   result=create_autospec(\n   result.spec,result.spec_set,result.instance,\n   result.parent,result.name\n   )\n   self._mock_children[name]=result\n  return result\n def __repr__(self):\n  _name_list=[self._mock_new_name]\n  _parent=self._mock_new_parent\n  last=self\n  dot='.'\n  if _name_list==['()']:\n   dot=''\n  seen=set()\n  while _parent is not None:\n   last=_parent\n   _name_list.append(_parent._mock_new_name+dot)\n   dot='.'\n   if _parent._mock_new_name=='()':\n    dot=''\n   _parent=_parent._mock_new_parent\n   if id(_parent)in seen:\n    break\n   seen.add(id(_parent))\n  _name_list=list(reversed(_name_list))\n  _first=last._mock_name or'mock'\n  if len(_name_list)>1:\n   if _name_list[1]not in('()','().'):\n    _first+='.'\n  _name_list[0]=_first\n  name=''.join(_name_list)\n  name_string=''\n  if name not in('mock','mock.'):\n   name_string=' name=%r'%name\n  spec_string=''\n  if self._spec_class is not None:\n   spec_string=' spec=%r'\n   if self._spec_set:\n    spec_string=' spec_set=%r'\n   spec_string=spec_string%self._spec_class.__name__\n  return\"<%s%s%s id='%s'>\"%(\n  type(self).__name__,\n  name_string,\n  spec_string,\n  id(self)\n  )\n def __dir__(self):\n  if not FILTER_DIR:\n   return object.__dir__(self)\n  extras=self._mock_methods or[]\n  from_type=dir(type(self))\n  from_dict=list(self.__dict__)\n  from_type=[e for e in from_type if not e.startswith('_')]\n  from_dict=[e for e in from_dict if not e.startswith('_')or\n  _is_magic(e)]\n  return sorted(set(extras+from_type+from_dict+\n  list(self._mock_children)))\n def __setattr__(self,name,value):\n  if name in _allowed_names:\n   return object.__setattr__(self,name,value)\n  elif(self._spec_set and self._mock_methods is not None and\n  name not in self._mock_methods and\n  name not in self.__dict__):\n   raise AttributeError(\"Mock object has no attribute '%s'\"%name)\n  elif name in _unsupported_magics:\n   msg='Attempting to set unsupported magic method %r.'%name\n   raise AttributeError(msg)\n  elif name in _all_magics:\n   if self._mock_methods is not None and name not in self._mock_methods:\n    raise AttributeError(\"Mock object has no attribute '%s'\"%name)\n   if not _is_instance_mock(value):\n    setattr(type(self),name,_get_method(name,value))\n    original=value\n    value=lambda*args,**kw:original(self,*args,**kw)\n   else:\n    _check_and_set_parent(self,value,None,name)\n    setattr(type(self),name,value)\n    self._mock_children[name]=value\n  elif name=='__class__':\n   self._spec_class=value\n   return\n  else:\n   if _check_and_set_parent(self,value,name,name):\n    self._mock_children[name]=value\n  return object.__setattr__(self,name,value)\n def __delattr__(self,name):\n  if name in _all_magics and name in type(self).__dict__:\n   delattr(type(self),name)\n   if name not in self.__dict__:\n    return\n  if name in self.__dict__:\n   object.__delattr__(self,name)\n  obj=self._mock_children.get(name,_missing)\n  if obj is _deleted:\n   raise AttributeError(name)\n  if obj is not _missing:\n   del self._mock_children[name]\n  self._mock_children[name]=_deleted\n def _format_mock_call_signature(self,args,kwargs):\n  name=self._mock_name or'mock'\n  return _format_call_signature(name,args,kwargs)\n def _format_mock_failure_message(self,args,kwargs):\n  message='Expected call: %s\\nActual call: %s'\n  expected_string=self._format_mock_call_signature(args,kwargs)\n  call_args=self.call_args\n  if len(call_args)==3:\n   call_args=call_args[1:]\n  actual_string=self._format_mock_call_signature(*call_args)\n  return message%(expected_string,actual_string)\n def assert_called_with(_mock_self,*args,**kwargs):\n  ''  \n  self=_mock_self\n  if self.call_args is None:\n   expected=self._format_mock_call_signature(args,kwargs)\n   raise AssertionError('Expected call: %s\\nNot called'%(expected,))\n  if self.call_args!=(args,kwargs):\n   msg=self._format_mock_failure_message(args,kwargs)\n   raise AssertionError(msg)\n def assert_called_once_with(_mock_self,*args,**kwargs):\n  ''  \n  self=_mock_self\n  if not self.call_count==1:\n   msg=(\"Expected '%s' to be called once. Called %s times.\"%\n   (self._mock_name or'mock',self.call_count))\n   raise AssertionError(msg)\n  return self.assert_called_with(*args,**kwargs)\n def assert_has_calls(self,calls,any_order=False):\n  ''  \n  if not any_order:\n   if calls not in self.mock_calls:\n    raise AssertionError(\n    'Calls not found.\\nExpected: %r\\n'\n    'Actual: %r'%(calls,self.mock_calls)\n    )\n   return\n  all_calls=list(self.mock_calls)\n  not_found=[]\n  for kall in calls:\n   try:\n    all_calls.remove(kall)\n   except ValueError:\n    not_found.append(kall)\n  if not_found:\n   raise AssertionError(\n   '%r not all found in call list'%(tuple(not_found),)\n   )\n def assert_any_call(self,*args,**kwargs):\n  ''  \n  kall=call(*args,**kwargs)\n  if kall not in self.call_args_list:\n   expected_string=self._format_mock_call_signature(args,kwargs)\n   raise AssertionError(\n   '%s call not found'%expected_string\n   )\n def _get_child_mock(self,**kw):\n  ''  \n  _type=type(self)\n  if not issubclass(_type,CallableMixin):\n   if issubclass(_type,NonCallableMagicMock):\n    klass=MagicMock\n   elif issubclass(_type,NonCallableMock):\n    klass=Mock\n  else:\n   klass=_type.__mro__[1]\n  return klass(**kw)\ndef _try_iter(obj):\n if obj is None:\n  return obj\n if _is_exception(obj):\n  return obj\n if _callable(obj):\n  return obj\n try:\n  return iter(obj)\n except TypeError:\n  return obj\nclass CallableMixin(Base):\n def __init__(self,spec=None,side_effect=None,return_value=DEFAULT,\n wraps=None,name=None,spec_set=None,parent=None,\n _spec_state=None,_new_name='',_new_parent=None,**kwargs):\n  self.__dict__['_mock_return_value']=return_value\n  _safe_super(CallableMixin,self).__init__(\n  spec,wraps,name,spec_set,parent,\n  _spec_state,_new_name,_new_parent,**kwargs\n  )\n  self.side_effect=side_effect\n def _mock_check_sig(self,*args,**kwargs):\n  pass\n def __call__(_mock_self,*args,**kwargs):\n  _mock_self._mock_check_sig(*args,**kwargs)\n  return _mock_self._mock_call(*args,**kwargs)\n def _mock_call(_mock_self,*args,**kwargs):\n  self=_mock_self\n  self.called=True\n  self.call_count+=1\n  self.call_args=_Call((args,kwargs),two=True)\n  self.call_args_list.append(_Call((args,kwargs),two=True))\n  _new_name=self._mock_new_name\n  _new_parent=self._mock_new_parent\n  self.mock_calls.append(_Call(('',args,kwargs)))\n  seen=set()\n  skip_next_dot=_new_name=='()'\n  do_method_calls=self._mock_parent is not None\n  name=self._mock_name\n  while _new_parent is not None:\n   this_mock_call=_Call((_new_name,args,kwargs))\n   if _new_parent._mock_new_name:\n    dot='.'\n    if skip_next_dot:\n     dot=''\n    skip_next_dot=False\n    if _new_parent._mock_new_name=='()':\n     skip_next_dot=True\n    _new_name=_new_parent._mock_new_name+dot+_new_name\n   if do_method_calls:\n    if _new_name==name:\n     this_method_call=this_mock_call\n    else:\n     this_method_call=_Call((name,args,kwargs))\n    _new_parent.method_calls.append(this_method_call)\n    do_method_calls=_new_parent._mock_parent is not None\n    if do_method_calls:\n     name=_new_parent._mock_name+'.'+name\n   _new_parent.mock_calls.append(this_mock_call)\n   _new_parent=_new_parent._mock_new_parent\n   _new_parent_id=id(_new_parent)\n   if _new_parent_id in seen:\n    break\n   seen.add(_new_parent_id)\n  ret_val=DEFAULT\n  effect=self.side_effect\n  if effect is not None:\n   if _is_exception(effect):\n    raise effect\n   if not _callable(effect):\n    result=next(effect)\n    if _is_exception(result):\n     raise result\n    if result is DEFAULT:\n     result=self.return_value\n    return result\n   ret_val=effect(*args,**kwargs)\n   if ret_val is DEFAULT:\n    ret_val=self.return_value\n  if(self._mock_wraps is not None and\n  self._mock_return_value is DEFAULT):\n   return self._mock_wraps(*args,**kwargs)\n  if ret_val is DEFAULT:\n   ret_val=self.return_value\n  return ret_val\nclass Mock(CallableMixin,NonCallableMock):\n '' \ndef _dot_lookup(thing,comp,import_path):\n try:\n  return getattr(thing,comp)\n except AttributeError:\n  __import__(import_path)\n  return getattr(thing,comp)\ndef _importer(target):\n components=target.split('.')\n import_path=components.pop(0)\n thing=__import__(import_path)\n for comp in components:\n  import_path+=\".%s\"%comp\n  thing=_dot_lookup(thing,comp,import_path)\n return thing\ndef _is_started(patcher):\n return hasattr(patcher,'is_local')\nclass _patch(object):\n attribute_name=None\n _active_patches=set()\n def __init__(\n self,getter,attribute,new,spec,create,\n spec_set,autospec,new_callable,kwargs\n ):\n  if new_callable is not None:\n   if new is not DEFAULT:\n    raise ValueError(\n    \"Cannot use 'new' and 'new_callable' together\"\n    )\n   if autospec is not None:\n    raise ValueError(\n    \"Cannot use 'autospec' and 'new_callable' together\"\n    )\n  self.getter=getter\n  self.attribute=attribute\n  self.new=new\n  self.new_callable=new_callable\n  self.spec=spec\n  self.create=create\n  self.has_local=False\n  self.spec_set=spec_set\n  self.autospec=autospec\n  self.kwargs=kwargs\n  self.additional_patchers=[]\n def copy(self):\n  patcher=_patch(\n  self.getter,self.attribute,self.new,self.spec,\n  self.create,self.spec_set,\n  self.autospec,self.new_callable,self.kwargs\n  )\n  patcher.attribute_name=self.attribute_name\n  patcher.additional_patchers=[\n  p.copy()for p in self.additional_patchers\n  ]\n  return patcher\n def __call__(self,func):\n  if isinstance(func,type):\n   return self.decorate_class(func)\n  return self.decorate_callable(func)\n def decorate_class(self,klass):\n  for attr in dir(klass):\n   if not attr.startswith(patch.TEST_PREFIX):\n    continue\n   attr_value=getattr(klass,attr)\n   if not hasattr(attr_value,\"__call__\"):\n    continue\n   patcher=self.copy()\n   setattr(klass,attr,patcher(attr_value))\n  return klass\n def decorate_callable(self,func):\n  if hasattr(func,'patchings'):\n   func.patchings.append(self)\n   return func\n  @wraps(func)\n  def patched(*args,**keywargs):\n   extra_args=[]\n   entered_patchers=[]\n   exc_info=tuple()\n   try:\n    for patching in patched.patchings:\n     arg=patching.__enter__()\n     entered_patchers.append(patching)\n     if patching.attribute_name is not None:\n      keywargs.update(arg)\n     elif patching.new is DEFAULT:\n      extra_args.append(arg)\n    args+=tuple(extra_args)\n    return func(*args,**keywargs)\n   except:\n    if(patching not in entered_patchers and\n    _is_started(patching)):\n     entered_patchers.append(patching)\n    exc_info=sys.exc_info()\n    raise\n   finally:\n    for patching in reversed(entered_patchers):\n     patching.__exit__(*exc_info)\n  patched.patchings=[self]\n  return patched\n def get_original(self):\n  target=self.getter()\n  name=self.attribute\n  original=DEFAULT\n  local=False\n  try:\n   original=target.__dict__[name]\n  except(AttributeError,KeyError):\n   original=getattr(target,name,DEFAULT)\n  else:\n   local=True\n  if not self.create and original is DEFAULT:\n   raise AttributeError(\n   \"%s does not have the attribute %r\"%(target,name)\n   )\n  return original,local\n def __enter__(self):\n  new,spec,spec_set=self.new,self.spec,self.spec_set\n  autospec,kwargs=self.autospec,self.kwargs\n  new_callable=self.new_callable\n  self.target=self.getter()\n  if spec is False:\n   spec=None\n  if spec_set is False:\n   spec_set=None\n  if autospec is False:\n   autospec=None\n  if spec is not None and autospec is not None:\n   raise TypeError(\"Can't specify spec and autospec\")\n  if((spec is not None or autospec is not None)and\n  spec_set not in(True,None)):\n   raise TypeError(\"Can't provide explicit spec_set *and* spec or autospec\")\n  original,local=self.get_original()\n  if new is DEFAULT and autospec is None:\n   inherit=False\n   if spec is True:\n    spec=original\n    if spec_set is True:\n     spec_set=original\n     spec=None\n   elif spec is not None:\n    if spec_set is True:\n     spec_set=spec\n     spec=None\n   elif spec_set is True:\n    spec_set=original\n   if spec is not None or spec_set is not None:\n    if original is DEFAULT:\n     raise TypeError(\"Can't use 'spec' with create=True\")\n    if isinstance(original,type):\n     inherit=True\n   Klass=MagicMock\n   _kwargs={}\n   if new_callable is not None:\n    Klass=new_callable\n   elif spec is not None or spec_set is not None:\n    this_spec=spec\n    if spec_set is not None:\n     this_spec=spec_set\n    if _is_list(this_spec):\n     not_callable='__call__'not in this_spec\n    else:\n     not_callable=not callable(this_spec)\n    if not_callable:\n     Klass=NonCallableMagicMock\n   if spec is not None:\n    _kwargs['spec']=spec\n   if spec_set is not None:\n    _kwargs['spec_set']=spec_set\n   if(isinstance(Klass,type)and\n   issubclass(Klass,NonCallableMock)and self.attribute):\n    _kwargs['name']=self.attribute\n   _kwargs.update(kwargs)\n   new=Klass(**_kwargs)\n   if inherit and _is_instance_mock(new):\n    this_spec=spec\n    if spec_set is not None:\n     this_spec=spec_set\n    if(not _is_list(this_spec)and not\n    _instance_callable(this_spec)):\n     Klass=NonCallableMagicMock\n    _kwargs.pop('name')\n    new.return_value=Klass(_new_parent=new,_new_name='()',\n    **_kwargs)\n  elif autospec is not None:\n   if new is not DEFAULT:\n    raise TypeError(\n    \"autospec creates the mock for you. Can't specify \"\n    \"autospec and new.\"\n    )\n   if original is DEFAULT:\n    raise TypeError(\"Can't use 'autospec' with create=True\")\n   spec_set=bool(spec_set)\n   if autospec is True:\n    autospec=original\n   new=create_autospec(autospec,spec_set=spec_set,\n   _name=self.attribute,**kwargs)\n  elif kwargs:\n   raise TypeError(\"Can't pass kwargs to a mock we aren't creating\")\n  new_attr=new\n  self.temp_original=original\n  self.is_local=local\n  setattr(self.target,self.attribute,new_attr)\n  if self.attribute_name is not None:\n   extra_args={}\n   if self.new is DEFAULT:\n    extra_args[self.attribute_name]=new\n   for patching in self.additional_patchers:\n    arg=patching.__enter__()\n    if patching.new is DEFAULT:\n     extra_args.update(arg)\n   return extra_args\n  return new\n def __exit__(self,*exc_info):\n  if not _is_started(self):\n   raise RuntimeError('stop called on unstarted patcher')\n  if self.is_local and self.temp_original is not DEFAULT:\n   setattr(self.target,self.attribute,self.temp_original)\n  else:\n   delattr(self.target,self.attribute)\n   if not self.create and not hasattr(self.target,self.attribute):\n    setattr(self.target,self.attribute,self.temp_original)\n  del self.temp_original\n  del self.is_local\n  del self.target\n  for patcher in reversed(self.additional_patchers):\n   if _is_started(patcher):\n    patcher.__exit__(*exc_info)\n def start(self):\n  result=self.__enter__()\n  self._active_patches.add(self)\n  return result\n def stop(self):\n  self._active_patches.discard(self)\n  return self.__exit__()\ndef _get_target(target):\n try:\n  target,attribute=target.rsplit('.',1)\n except(TypeError,ValueError):\n  raise TypeError(\"Need a valid target to patch. You supplied: %r\"%\n  (target,))\n getter=lambda:_importer(target)\n return getter,attribute\ndef _patch_object(\ntarget,attribute,new=DEFAULT,spec=None,\ncreate=False,spec_set=None,autospec=None,\nnew_callable=None,**kwargs\n):\n '' \n getter=lambda:target\n return _patch(\n getter,attribute,new,spec,create,\n spec_set,autospec,new_callable,kwargs\n )\ndef _patch_multiple(target,spec=None,create=False,spec_set=None,\nautospec=None,new_callable=None,**kwargs):\n '' \n if type(target)is str:\n  getter=lambda:_importer(target)\n else:\n  getter=lambda:target\n if not kwargs:\n  raise ValueError(\n  'Must supply at least one keyword argument with patch.multiple'\n  )\n items=list(kwargs.items())\n attribute,new=items[0]\n patcher=_patch(\n getter,attribute,new,spec,create,spec_set,\n autospec,new_callable,{}\n )\n patcher.attribute_name=attribute\n for attribute,new in items[1:]:\n  this_patcher=_patch(\n  getter,attribute,new,spec,create,spec_set,\n  autospec,new_callable,{}\n  )\n  this_patcher.attribute_name=attribute\n  patcher.additional_patchers.append(this_patcher)\n return patcher\ndef patch(\ntarget,new=DEFAULT,spec=None,create=False,\nspec_set=None,autospec=None,new_callable=None,**kwargs\n):\n '' \n getter,attribute=_get_target(target)\n return _patch(\n getter,attribute,new,spec,create,\n spec_set,autospec,new_callable,kwargs\n )\nclass _patch_dict(object):\n '' \n def __init__(self,in_dict,values=(),clear=False,**kwargs):\n  if isinstance(in_dict,str):\n   in_dict=_importer(in_dict)\n  self.in_dict=in_dict\n  self.values=dict(values)\n  self.values.update(kwargs)\n  self.clear=clear\n  self._original=None\n def __call__(self,f):\n  if isinstance(f,type):\n   return self.decorate_class(f)\n  @wraps(f)\n  def _inner(*args,**kw):\n   self._patch_dict()\n   try:\n    return f(*args,**kw)\n   finally:\n    self._unpatch_dict()\n  return _inner\n def decorate_class(self,klass):\n  for attr in dir(klass):\n   attr_value=getattr(klass,attr)\n   if(attr.startswith(patch.TEST_PREFIX)and\n   hasattr(attr_value,\"__call__\")):\n    decorator=_patch_dict(self.in_dict,self.values,self.clear)\n    decorated=decorator(attr_value)\n    setattr(klass,attr,decorated)\n  return klass\n def __enter__(self):\n  self._patch_dict()\n def _patch_dict(self):\n  values=self.values\n  in_dict=self.in_dict\n  clear=self.clear\n  try:\n   original=in_dict.copy()\n  except AttributeError:\n   original={}\n   for key in in_dict:\n    original[key]=in_dict[key]\n  self._original=original\n  if clear:\n   _clear_dict(in_dict)\n  try:\n   in_dict.update(values)\n  except AttributeError:\n   for key in values:\n    in_dict[key]=values[key]\n def _unpatch_dict(self):\n  in_dict=self.in_dict\n  original=self._original\n  _clear_dict(in_dict)\n  try:\n   in_dict.update(original)\n  except AttributeError:\n   for key in original:\n    in_dict[key]=original[key]\n def __exit__(self,*args):\n  self._unpatch_dict()\n  return False\n start=__enter__\n stop=__exit__\ndef _clear_dict(in_dict):\n try:\n  in_dict.clear()\n except AttributeError:\n  keys=list(in_dict)\n  for key in keys:\n   del in_dict[key]\ndef _patch_stopall():\n for patch in list(_patch._active_patches):\n  patch.stop()\npatch.object=_patch_object\npatch.dict=_patch_dict\npatch.multiple=_patch_multiple\npatch.stopall=_patch_stopall\npatch.TEST_PREFIX='test'\nmagic_methods=(\n\"lt le gt ge eq ne \"\n\"getitem setitem delitem \"\n\"len contains iter \"\n\"hash str sizeof \"\n\"enter exit \"\n\"divmod neg pos abs invert \"\n\"complex int float index \"\n\"trunc floor ceil \"\n\"bool next \"\n)\nnumerics=\"add sub mul div floordiv mod lshift rshift and xor or pow \"\ninplace=' '.join('i%s'%n for n in numerics.split())\nright=' '.join('r%s'%n for n in numerics.split())\n_non_defaults=set('__%s__'%method for method in[\n'get','set','delete','reversed','missing','reduce','reduce_ex',\n'getinitargs','getnewargs','getstate','setstate','getformat',\n'setformat','repr','dir','subclasses','format',\n])\ndef _get_method(name,func):\n def method(self,*args,**kw):\n  return func(self,*args,**kw)\n method.__name__=name\n return method\n_magics=set(\n'__%s__'%method for method in\n' '.join([magic_methods,numerics,inplace,right]).split()\n)\n_all_magics=_magics|_non_defaults\n_unsupported_magics=set([\n'__getattr__','__setattr__',\n'__init__','__new__','__prepare__'\n'__instancecheck__','__subclasscheck__',\n'__del__'\n])\n_calculate_return_value={\n'__hash__':lambda self:object.__hash__(self),\n'__str__':lambda self:object.__str__(self),\n'__sizeof__':lambda self:object.__sizeof__(self),\n}\n_return_values={\n'__lt__':NotImplemented,\n'__gt__':NotImplemented,\n'__le__':NotImplemented,\n'__ge__':NotImplemented,\n'__int__':1,\n'__contains__':False,\n'__len__':0,\n'__exit__':False,\n'__complex__':1j,\n'__float__':1.0,\n'__bool__':True,\n'__index__':1,\n}\ndef _get_eq(self):\n def __eq__(other):\n  ret_val=self.__eq__._mock_return_value\n  if ret_val is not DEFAULT:\n   return ret_val\n  return self is other\n return __eq__\ndef _get_ne(self):\n def __ne__(other):\n  if self.__ne__._mock_return_value is not DEFAULT:\n   return DEFAULT\n  return self is not other\n return __ne__\ndef _get_iter(self):\n def __iter__():\n  ret_val=self.__iter__._mock_return_value\n  if ret_val is DEFAULT:\n   return iter([])\n  return iter(ret_val)\n return __iter__\n_side_effect_methods={\n'__eq__':_get_eq,\n'__ne__':_get_ne,\n'__iter__':_get_iter,\n}\ndef _set_return_value(mock,method,name):\n fixed=_return_values.get(name,DEFAULT)\n if fixed is not DEFAULT:\n  method.return_value=fixed\n  return\n return_calulator=_calculate_return_value.get(name)\n if return_calulator is not None:\n  try:\n   return_value=return_calulator(mock)\n  except AttributeError:\n   return_value=AttributeError(name)\n  method.return_value=return_value\n  return\n side_effector=_side_effect_methods.get(name)\n if side_effector is not None:\n  method.side_effect=side_effector(mock)\nclass MagicMixin(object):\n def __init__(self,*args,**kw):\n  _safe_super(MagicMixin,self).__init__(*args,**kw)\n  self._mock_set_magics()\n def _mock_set_magics(self):\n  these_magics=_magics\n  if self._mock_methods is not None:\n   these_magics=_magics.intersection(self._mock_methods)\n   remove_magics=set()\n   remove_magics=_magics-these_magics\n   for entry in remove_magics:\n    if entry in type(self).__dict__:\n     delattr(self,entry)\n  these_magics=these_magics-set(type(self).__dict__)\n  _type=type(self)\n  for entry in these_magics:\n   setattr(_type,entry,MagicProxy(entry,self))\nclass NonCallableMagicMock(MagicMixin,NonCallableMock):\n def mock_add_spec(self,spec,spec_set=False):\n  ''  \n  self._mock_add_spec(spec,spec_set)\n  self._mock_set_magics()\nclass MagicMock(MagicMixin,Mock):\n '' \n def mock_add_spec(self,spec,spec_set=False):\n  ''  \n  self._mock_add_spec(spec,spec_set)\n  self._mock_set_magics()\nclass MagicProxy(object):\n def __init__(self,name,parent):\n  self.name=name\n  self.parent=parent\n def __call__(self,*args,**kwargs):\n  m=self.create_mock()\n  return m(*args,**kwargs)\n def create_mock(self):\n  entry=self.name\n  parent=self.parent\n  m=parent._get_child_mock(name=entry,_new_name=entry,\n  _new_parent=parent)\n  setattr(parent,entry,m)\n  _set_return_value(parent,m,entry)\n  return m\n def __get__(self,obj,_type=None):\n  return self.create_mock()\nclass _ANY(object):\n def __eq__(self,other):\n  return True\n def __ne__(self,other):\n  return False\n def __repr__(self):\n  return'<ANY>'\nANY=_ANY()\ndef _format_call_signature(name,args,kwargs):\n message='%s(%%s)'%name\n formatted_args=''\n args_string=', '.join([repr(arg)for arg in args])\n kwargs_string=', '.join([\n '%s=%r'%(key,value)for key,value in kwargs.items()\n ])\n if args_string:\n  formatted_args=args_string\n if kwargs_string:\n  if formatted_args:\n   formatted_args+=', '\n  formatted_args+=kwargs_string\n return message%formatted_args\nclass _Call(tuple):\n '' \n def __new__(cls,value=(),name=None,parent=None,two=False,\n from_kall=True):\n  name=''\n  args=()\n  kwargs={}\n  _len=len(value)\n  if _len==3:\n   name,args,kwargs=value\n  elif _len==2:\n   first,second=value\n   if isinstance(first,str):\n    name=first\n    if isinstance(second,tuple):\n     args=second\n    else:\n     kwargs=second\n   else:\n    args,kwargs=first,second\n  elif _len==1:\n   value,=value\n   if isinstance(value,str):\n    name=value\n   elif isinstance(value,tuple):\n    args=value\n   else:\n    kwargs=value\n  if two:\n   return tuple.__new__(cls,(args,kwargs))\n  return tuple.__new__(cls,(name,args,kwargs))\n def __init__(self,value=(),name=None,parent=None,two=False,\n from_kall=True):\n  self.name=name\n  self.parent=parent\n  self.from_kall=from_kall\n def __eq__(self,other):\n  if other is ANY:\n   return True\n  try:\n   len_other=len(other)\n  except TypeError:\n   return False\n  self_name=''\n  if len(self)==2:\n   self_args,self_kwargs=self\n  else:\n   self_name,self_args,self_kwargs=self\n  other_name=''\n  if len_other==0:\n   other_args,other_kwargs=(),{}\n  elif len_other==3:\n   other_name,other_args,other_kwargs=other\n  elif len_other==1:\n   value,=other\n   if isinstance(value,tuple):\n    other_args=value\n    other_kwargs={}\n   elif isinstance(value,str):\n    other_name=value\n    other_args,other_kwargs=(),{}\n   else:\n    other_args=()\n    other_kwargs=value\n  else:\n   first,second=other\n   if isinstance(first,str):\n    other_name=first\n    if isinstance(second,tuple):\n     other_args,other_kwargs=second,{}\n    else:\n     other_args,other_kwargs=(),second\n   else:\n    other_args,other_kwargs=first,second\n  if self_name and other_name!=self_name:\n   return False\n  return(other_args,other_kwargs)==(self_args,self_kwargs)\n def __ne__(self,other):\n  return not self.__eq__(other)\n def __call__(self,*args,**kwargs):\n  if self.name is None:\n   return _Call(('',args,kwargs),name='()')\n  name=self.name+'()'\n  return _Call((self.name,args,kwargs),name=name,parent=self)\n def __getattr__(self,attr):\n  if self.name is None:\n   return _Call(name=attr,from_kall=False)\n  name='%s.%s'%(self.name,attr)\n  return _Call(name=name,parent=self,from_kall=False)\n def __repr__(self):\n  if not self.from_kall:\n   name=self.name or'call'\n   if name.startswith('()'):\n    name='call%s'%name\n   return name\n  if len(self)==2:\n   name='call'\n   args,kwargs=self\n  else:\n   name,args,kwargs=self\n   if not name:\n    name='call'\n   elif not name.startswith('()'):\n    name='call.%s'%name\n   else:\n    name='call%s'%name\n  return _format_call_signature(name,args,kwargs)\n def call_list(self):\n  ''  \n  vals=[]\n  thing=self\n  while thing is not None:\n   if thing.from_kall:\n    vals.append(thing)\n   thing=thing.parent\n  return _CallList(reversed(vals))\ncall=_Call(from_kall=False)\ndef create_autospec(spec,spec_set=False,instance=False,_parent=None,\n_name=None,**kwargs):\n '' \n if _is_list(spec):\n  spec=type(spec)\n is_type=isinstance(spec,type)\n _kwargs={'spec':spec}\n if spec_set:\n  _kwargs={'spec_set':spec}\n elif spec is None:\n  _kwargs={}\n _kwargs.update(kwargs)\n Klass=MagicMock\n if type(spec)in DescriptorTypes:\n  _kwargs={}\n elif not _callable(spec):\n  Klass=NonCallableMagicMock\n elif is_type and instance and not _instance_callable(spec):\n  Klass=NonCallableMagicMock\n _new_name=_name\n if _parent is None:\n  _new_name=''\n mock=Klass(parent=_parent,_new_parent=_parent,_new_name=_new_name,\n name=_name,**_kwargs)\n if isinstance(spec,FunctionTypes):\n  mock=_set_signature(mock,spec)\n else:\n  _check_signature(spec,mock,is_type,instance)\n if _parent is not None and not instance:\n  _parent._mock_children[_name]=mock\n if is_type and not instance and'return_value'not in kwargs:\n  mock.return_value=create_autospec(spec,spec_set,instance=True,\n  _name='()',_parent=mock)\n for entry in dir(spec):\n  if _is_magic(entry):\n   continue\n  try:\n   original=getattr(spec,entry)\n  except AttributeError:\n   continue\n  kwargs={'spec':original}\n  if spec_set:\n   kwargs={'spec_set':original}\n  if not isinstance(original,FunctionTypes):\n   new=_SpecState(original,spec_set,mock,entry,instance)\n   mock._mock_children[entry]=new\n  else:\n   parent=mock\n   if isinstance(spec,FunctionTypes):\n    parent=mock.mock\n   new=MagicMock(parent=parent,name=entry,_new_name=entry,\n   _new_parent=parent,**kwargs)\n   mock._mock_children[entry]=new\n   skipfirst=_must_skip(spec,entry,is_type)\n   _check_signature(original,new,skipfirst=skipfirst)\n  if isinstance(new,FunctionTypes):\n   setattr(mock,entry,new)\n return mock\ndef _must_skip(spec,entry,is_type):\n if not isinstance(spec,type):\n  if entry in getattr(spec,'__dict__',{}):\n   return False\n  spec=spec.__class__\n for klass in spec.__mro__:\n  result=klass.__dict__.get(entry,DEFAULT)\n  if result is DEFAULT:\n   continue\n  if isinstance(result,(staticmethod,classmethod)):\n   return False\n  return is_type\n return is_type\ndef _get_class(obj):\n try:\n  return obj.__class__\n except AttributeError:\n  return type(obj)\nclass _SpecState(object):\n def __init__(self,spec,spec_set=False,parent=None,\n name=None,ids=None,instance=False):\n  self.spec=spec\n  self.ids=ids\n  self.spec_set=spec_set\n  self.parent=parent\n  self.instance=instance\n  self.name=name\nFunctionTypes=(\ntype(create_autospec),\ntype(ANY.__eq__),\n)\nfile_spec=None\ndef mock_open(mock=None,read_data=''):\n '' \n global file_spec\n if file_spec is None:\n  import _io\n  file_spec=list(set(dir(_io.TextIOWrapper)).union(set(dir(_io.BytesIO))))\n if mock is None:\n  mock=MagicMock(name='open',spec=open)\n handle=MagicMock(spec=file_spec)\n handle.write.return_value=None\n handle.__enter__.return_value=handle\n handle.read.return_value=read_data\n mock.return_value=handle\n return mock\nclass PropertyMock(Mock):\n '' \n def _get_child_mock(self,**kwargs):\n  return MagicMock(**kwargs)\n def __get__(self,obj,obj_type):\n  return self()\n def __set__(self,obj,val):\n  self(val)\n"]};


  __BRYTHON__.import_from_unittest function(mod_name){
  var stored = __BRYTHON__.libs['unittest'][mod_name]
  if(stored!==undefined){
    var module_contents = stored[0]
    var $is_package = stored[1]
    var path = 'py_unittest'
    var module = {name:mod_name,__class__:$B.$ModuleDict,$is_package:$is_package}
    if($is_package){var package=mod_name}
    else{
      var elts = mod_name.split('.')
      elts.pop()
      var package = elts.join('.')
    }
    $B.modules[mod_name].$package = $is_package
    $B.modules[mod_name].__package__ = package

    run_py(module,path,module_contents)
    return true
  }
  return null
}
// add this import function to brython by doing the following:
// <body onload="brython({custom_import_funcs:[__BRYTHON__.import_from_unittest]})">
// this will allow us to import unittest modules.
